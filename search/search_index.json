{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introdu\u00e7\u00e3o","text":"<p>Esse conte\u00fado foi planejado para ser algo direto ao ponto para iniciantes, mas em alguns momentos voc\u00ea poder\u00e1 ver diversas informa\u00e7\u00f5es importantes que podem tornar alguns t\u00f3picos relativamente extensos. Cada se\u00e7\u00e3o abordar\u00e1 temas espec\u00edficos, sendo como esp\u00e9cie de cap\u00edtulos, e ter\u00e1 refer\u00eancias tanto \u00e0 documenta\u00e7\u00e3o quanto a conte\u00fados que eu achar interessantes.</p> <p>As se\u00e7\u00f5es est\u00e3o organizadas numa ordem cronol\u00f3gica do que acredito ser interessante aprender primeiro, mas essa ordem pode mudar ou n\u00e3o ter grande efici\u00eancia. Se voc\u00ea n\u00e3o for um completo iniciante no Compose, n\u00e3o precisa se prender a ela, caso contr\u00e1rio, \u00e9 recomend\u00e1vel segui-la.</p> <p>Os c\u00f3digos de exemplos usados em cada se\u00e7\u00e3o podem ser encontrados no reposit\u00f3rio Compose Journey Samples .</p>"},{"location":"#requisitos-minimos","title":"Requisitos m\u00ednimos","text":"<p>\u00c9 necess\u00e1rio que voc\u00ea conhe\u00e7a a linguagem Kotlin e, de prefer\u00eancia, tenha familiaridade com Android nativo. Todas as se\u00e7\u00f5es cobrem apenas conte\u00fados relacionados ao Jetpack Compose. Conte\u00fados espec\u00edficos do Android, como Activities e Services, por exemplo, n\u00e3o s\u00e3o explorados aqui.</p> <p>Para fins de compatibilidade e evitar problemas, \u00e9 recomend\u00e1vel que voc\u00ea esteja usando:</p> <ul> <li>Android Studio Hedgehog - 2023.1.1 ou superior.</li> <li>Compose BOM 2023.10.01 ou superior.</li> <li>Kotlin 1.9.20 ou superior.</li> <li>kotlinCompilerExtensionVersion 1.5.6 ou superior.</li> <li>Material Design 3.</li> </ul> <p>Todo o conte\u00fado est\u00e1 sendo criado com base nos componentes do Material Design 3. H\u00e1 v\u00e1rias diferen\u00e7as em alguns componentes do MD2 e MD3 no Compose, portanto, \u00e9 recomend\u00e1vel seguir o MD3 para evitar problemas com o conte\u00fado. Ao criar um projeto Compose no Android Studio Hedgehog, o MD3 \u00e9 inclu\u00eddo por padr\u00e3o.</p> <ul> <li>Voc\u00ea pode usar o Material Theme Builder para criar seu tema rapidamente.</li> </ul> <p>Vamos utilizar as depend\u00eancias que v\u00eam configuradas ao criar um projeto Compose, que geralmente s\u00e3o:</p> <pre><code>dependencies {\n    implementation(\"androidx.core:core-ktx:$version\")\n    implementation(\"androidx.lifecycle:lifecycle-runtime-ktx:$version\")\n    implementation(\"androidx.activity:activity-compose:$version\")\n\n    implementation(platform(\"androidx.compose:compose-bom:$version\"))\n    implementation(\"androidx.compose.ui:ui\")\n    implementation(\"androidx.compose.ui:ui-graphics\")\n    implementation(\"androidx.compose.ui:ui-tooling-preview\")\n    implementation(\"androidx.compose.material3:material3\")\n\n    testImplementation(\"junit:junit:$version\")\n    androidTestImplementation(\"androidx.test.ext:junit:$version\")\n    androidTestImplementation(\"androidx.test.espresso:espresso-core:$version\")\n    androidTestImplementation(platform(\"androidx.compose:compose-bom:$version\"))\n    androidTestImplementation(\"androidx.compose.ui:ui-test-junit4\")\n    debugImplementation(\"androidx.compose.ui:ui-tooling\")\n    debugImplementation(\"androidx.compose.ui:ui-test-manifest\")\n}\n</code></pre> <p>As se\u00e7\u00f5es que precisarem de novas depend\u00eancias ter\u00e3o essa informa\u00e7\u00e3o inclusa.</p>"},{"location":"#nao-esqueca-a-documentacao-oficial","title":"N\u00e3o esque\u00e7a a documenta\u00e7\u00e3o oficial","text":"<p>O foco desse conte\u00fado n\u00e3o \u00e9 substituir a documenta\u00e7\u00e3o oficial nem voc\u00ea deve evitar de l\u00ea-la. A maioria do conte\u00fado ter\u00e1 como fonte de apoio a pr\u00f3pria documenta\u00e7\u00e3o. Em muitas se\u00e7\u00f5es voc\u00ea ler\u00e1 coisas que foram retiradas dela, \u00e0s vezes usando outras palavras, tentando tornar mais simples ou mais explicativo. Tentarei melhorar apenas o que eu achar necess\u00e1rio.</p>"},{"location":"animations/","title":"Anima\u00e7\u00f5es","text":"<p>Anima\u00e7\u00f5es s\u00e3o fundamentais e deixam nossos apps com um visual mais interessante. Nessa se\u00e7\u00e3o veremos algumas das anima\u00e7\u00f5es que podem ser usadas no Compose. Como existem v\u00e1rias e para m\u00faltiplos contextos diferentes, obviamente n\u00e3o veremos todas por aqui. A documenta\u00e7\u00e3o \u00e9 muito rica e possui diversos c\u00f3digos de exemplo sobre anima\u00e7\u00f5es, ent\u00e3o isso n\u00e3o ser\u00e1 um problema.</p>"},{"location":"animations/#escolher-a-api-de-animacao","title":"Escolher a API de anima\u00e7\u00e3o","text":"<p>Antes de come\u00e7ar a utilizar uma anima\u00e7\u00e3o, \u00e9 \u00fatil primeiro saber qual API utilizar para isso. A documenta\u00e7\u00e3o fornece um guia simples que voc\u00ea pode consultar rapidamente e ficar por dentro das principais op\u00e7\u00f5es e casos de uso. Abaixo temos um diagrama retirado da pr\u00f3pria documenta\u00e7\u00e3o para demonstrar isso.</p> <p></p>"},{"location":"animations/#animar-composable-aparecendodesaparecendo","title":"Animar Composable aparecendo/desaparecendo","text":"<p>Podemos usar a fun\u00e7\u00e3o AnimatedVisibility() para animar um Composable aparecendo/desaparecendo com facilidade. Veja o exemplo abaixo, ao inv\u00e9s de usarmos apenas um <code>if (selected) {...}</code>, envolvemos nosso Composable Icon() na AnimatedVisibility(). Ela possui como argumento obrigat\u00f3rio visible, que \u00e9 respons\u00e1vel por decidir se o conte\u00fado Composable passado nela ser\u00e1 exibido ou n\u00e3o. H\u00e1 tamb\u00e9m duas op\u00e7\u00f5es principais, enter e exit, respons\u00e1veis por decidir a anima\u00e7\u00e3o de entrada e sa\u00edda, que j\u00e1 possuem uma anima\u00e7\u00e3o padr\u00e3o. No nosso caso, substitu\u00edmos pelas fun\u00e7\u00f5es scaleIn() e scaleOut(), que funcionam bem nesse caso.</p> <pre><code>@Composable\nprivate fun SelectableImage() {\n    var selected by remember { mutableStateOf(false) }\n    Box(\n        contentAlignment = Alignment.Center,\n        modifier = Modifier\n            .size(200.dp)\n            .clickable { selected = !selected },\n    ) {\n        Image(\n            painter = painterResource(id = R.drawable.img_moon_space),\n            contentDescription = \"Image\",\n            contentScale = ContentScale.Crop,\n            modifier = Modifier.fillMaxSize()\n        )\n        AnimatedVisibility(\n            visible = selected,\n            enter = scaleIn(),\n            exit = scaleOut()\n        ) {\n            Icon(\n                imageVector = Icons.Default.Done,\n                contentDescription = null,\n                tint = Color.White,\n                modifier = Modifier\n                    .size((60.dp))\n                    .background(Color(0xFF0D47A1), CircleShape)\n                    .padding(8.dp)\n            )\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"animations/#alternar-entre-diferentes-tipos-de-conteudo","title":"Alternar entre diferentes tipos de conte\u00fado","text":"<p>\u00c0s vezes, queremos que uma anima\u00e7\u00e3o ocorra quando um conte\u00fado da tela muda, como por exemplo, baseado em estados diferentes, que geralmente s\u00e3o os casos de loading, sucesso e erro. N\u00f3s podemos fazer isso utilizando AnimatedContent. Ele possui um par\u00e2metro targetState que \u00e9 usado para definir o estado atual, e no lambda de retorno, o estado atual pode ser verificado para decidir que conte\u00fado exibir. J\u00e1 transitionSpec \u00e9 usado para definir a nossa anima\u00e7\u00e3o, que nesse caso \u00e9 apenas a jun\u00e7\u00e3o da scaleIn() com fadeOut(), ambas com uma dura\u00e7\u00e3o de 700 milissegundos. J\u00e1 o label \u00e9 usado aqui apenas para fins de prop\u00f3sito no Android Studio, para diferenciar as anima\u00e7\u00f5es.</p> <pre><code>@Composable\nfun ProfileScreen() {\n    var state by remember { mutableStateOf(State.Loading) }\n    AnimatedContent(\n        targetState = state,\n        transitionSpec = {\n            scaleIn(\n                animationSpec = tween(700)\n            ) togetherWith fadeOut(animationSpec = tween(700))\n        },\n        label = \"AnimatedContent\",\n        modifier = Modifier.clickable(\n            interactionSource = remember { MutableInteractionSource() },\n            indication = null\n        ) {\n            state = when (state) {\n                State.Loading -&gt; State.Success\n                State.Success -&gt; State.Error\n                State.Error -&gt; State.Loading\n            }\n        }\n    ) { targetState -&gt;\n        when (targetState) {\n            State.Loading -&gt; {\n                LoadingContent()\n            }\n            State.Success -&gt; {\n                ProfileContent()\n            }\n            State.Error -&gt; {\n                ErrorContent()\n            }\n        }\n    }\n}\n</code></pre> Ver restante do c\u00f3digo <pre><code>@Composable\nprivate fun LoadingContent() {\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .fillMaxSize()\n    ) {\n        CircularProgressIndicator()\n        Spacer(Modifier.height(8.dp))\n        Text(\n            text = \"Carregando perfil...\",\n            fontSize = 18.sp\n        )\n    }\n}\n\n@Composable\nprivate fun ProfileContent() {\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .fillMaxSize()\n    ) {\n        Image(\n            painter = painterResource(id = R.drawable.img_nature),\n            contentDescription = \"Image\",\n            contentScale = ContentScale.Crop,\n            modifier = Modifier\n                .size(250.dp)\n                .clip(RoundedCornerShape(16.dp))\n        )\n        Spacer(Modifier.height(8.dp))\n        Text(\n            text = \"Informa\u00e7\u00f5es carregadas com sucesso.\",\n            fontSize = 18.sp\n        )\n    }\n}\n\n@Composable\nprivate fun ErrorContent() {\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .fillMaxSize()\n    ) {\n        Icon(\n            imageVector = Icons.Default.Info,\n            contentDescription = null,\n            modifier = Modifier\n                .size(60.dp)\n        )\n        Spacer(Modifier.height(8.dp))\n        Text(\n            text = \"Erro ao obter informa\u00e7\u00f5es do perfil.\",\n            fontSize = 18.sp,\n        )\n    }\n}\n\nprivate enum class State {\n    Loading,\n    Success,\n    Error\n}\n</code></pre> <p></p>"},{"location":"animations/#animar-mudancas-de-tamanho-de-um-composable","title":"Animar mudan\u00e7as de tamanho de um Composable","text":"<p>O Compose fornece v\u00e1rias anima\u00e7\u00f5es atrav\u00e9s de Modifiers e uma delas \u00e9 o <code>Modifier.animateContentSize()</code>, que serve para animar mudan\u00e7as de tamanho de um Composable. Por exemplo, vamos criar um pequeno Card de informa\u00e7\u00e3o com a op\u00e7\u00e3o \"mostrar mais/menos\" para o texto exibido. Adicionamos <code>Modifier.animateContentSize(spring(dampingRatio = 3f))</code> na Column pai do Text(). animationSpec = spring(dampingRatio = 3f) \u00e9 adicionado apenas para ter uma anima\u00e7\u00e3o mais legal, mas a anima\u00e7\u00e3o padr\u00e3o tem um dampingRatio com valor 1f.</p> <ul> <li>A ordem dos modificadores \u00e9 importante aqui. Certifique-se de colocar <code>Modifier.animateContentSize()</code> antes de qualquer modificador de tamanho, como <code>Modifier.size()</code>.</li> </ul> <pre><code>@Composable\nprivate fun InfoCard() {\n    var expanded by remember { mutableStateOf(false) }\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp)\n    ) {\n        Card(shape = RoundedCornerShape(16.dp)) {\n            Column(\n                modifier = Modifier\n                    .animateContentSize(animationSpec = spring(dampingRatio = 3f))\n                    .padding(12.dp)\n            ) {\n                Image(\n                    painter = painterResource(id = R.drawable.img_car),\n                    contentDescription = \"Image\",\n                    contentScale = ContentScale.Crop,\n                    modifier = Modifier\n                        .size(150.dp)\n                        .clip(RoundedCornerShape(16.dp))\n                        .align(Alignment.CenterHorizontally)\n                )\n                Spacer(Modifier.height(12.dp))\n                Text(\n                    text = loremIpsumText,\n                    maxLines = if (expanded) Int.MAX_VALUE else 3,\n                    overflow = TextOverflow.Ellipsis\n                )\n                Spacer(Modifier.height(12.dp))\n                OutlinedButton(\n                    onClick = { expanded = !expanded },\n                    modifier = Modifier.align(Alignment.End)\n                ) {\n                    Icon(\n                        imageVector = if (expanded) Icons.Default.KeyboardArrowUp else Icons.Default.KeyboardArrowDown,\n                        contentDescription = null\n                    )\n                    Text(\n                        text = if (expanded) \"Mostrar menos\" else \"Mostrar mais\"\n                    )\n                }\n            }\n        }\n    }\n}\n\nprivate const val loremIpsumText = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do\" +\n                \" eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis\" +\n                \" nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute\" +\n                \" irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla\" +\n                \" pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia\" +\n                \" deserunt mollit anim id est laborum.\"\n</code></pre> <p></p>"},{"location":"animations/#animar-padding-e-rotacao","title":"Animar padding e rota\u00e7\u00e3o","text":"<p>Para animar as mudan\u00e7as de padding e rota\u00e7\u00e3o de um Composable, voc\u00ea pode utilizar as fun\u00e7\u00f5es <code>animateDpAsState()</code> e <code>animateFloatAsState()</code>. Vamos ver um pequeno exemplo abaixo de como podemos fazer isso, animando o padding de um texto e a rota\u00e7\u00e3o de um \u00edcone.</p> <pre><code>@Composable\nprivate fun Info() {\n    var expanded by remember { mutableStateOf(false) }\n    val textPadding by animateDpAsState(\n        targetValue = if (expanded) 14.dp else 4.dp,\n        animationSpec = spring(\n            dampingRatio = 3f,\n            stiffness = Spring.StiffnessLow\n        ),\n        label = \"textPadding\"\n    )\n    val iconRotationAngle by animateFloatAsState(\n        targetValue = if (expanded) 180f else 0f,\n        animationSpec = spring(\n            dampingRatio = 2f,\n            stiffness = Spring.StiffnessMediumLow\n        ),\n        label = \"iconRotationAngle\"\n    )\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp)\n    ) {\n        Text(\n            text = \"Jetpack Compose Journey!\",\n            color = Color.White,\n            modifier = Modifier\n                .background(\n                    color = Color.Black,\n                    shape = RoundedCornerShape(8.dp)\n                )\n                .padding(textPadding)\n        )\n        Spacer(Modifier.height(24.dp))\n        Button(onClick = { expanded = !expanded }) {\n            Icon(\n                imageVector = Icons.Default.KeyboardArrowDown,\n                contentDescription = null,\n                modifier = Modifier.rotate(iconRotationAngle)\n            )\n            Text(\n                text = if (expanded) \"Diminuir padding\" else \"Aumentar padding\"\n            )\n        }\n    }\n}\n</code></pre> <p></p> <p>Como pode ver, no caso do padding, usamos o <code>Modifier.padding()</code> no Text() como far\u00edamos normalmente, mas dessa vez usando o valor de animateDpAsState(). No caso da rota\u00e7\u00e3o do \u00edcone, usamos o <code>Modifier.rotate()</code> no Icon(), com o valor de animateFloatAsState(). Ambos utilizam um targetValue que varia dependendo do valor da vari\u00e1vel expanded, al\u00e9m de uma animationSpec levemente personalizada.</p>"},{"location":"animations/#bonus-animacoes-com-lottie","title":"B\u00f4nus: Anima\u00e7\u00f5es com Lottie","text":"<p>Al\u00e9m das anima\u00e7\u00f5es padr\u00e3o que o Compose fornece, tamb\u00e9m podemos utilizar anima\u00e7\u00f5es com Lottie. Um Lottie \u00e9 um formato de arquivo de anima\u00e7\u00e3o baseado em JSON que permite enviar anima\u00e7\u00f5es em qualquer plataforma com a mesma facilidade com que envia ativos est\u00e1ticos. \u00c9 um padr\u00e3o j\u00e1 bem utilizado em apps com o sistema de Views/XML e outras plataformas. </p> <p>Vamos utilizar a biblioteca do Lottie Compose para usar essas anima\u00e7\u00f5es. Primeiro, adicione a depend\u00eancia necess\u00e1ria no build.gradle (app):</p> <pre><code>dependencies {\n    implementation(\"com.airbnb.android:lottie-compose:$version\")\n}\n</code></pre> <p>Vamos ver uma pequena implementa\u00e7\u00e3o b\u00e1sica com uma anima\u00e7\u00e3o de loading. Voc\u00ea pode baixar o arquivo de anima\u00e7\u00e3o usado no exemplo abaixo aqui se desejar. Para baixar outras anima\u00e7\u00f5es, acesse o LottieFiles. Voc\u00ea deve colocar o arquivo json da anima\u00e7\u00e3o na pasta res/raw do seu projeto.</p> <pre><code>@Composable\nfun LoadingAnimation() {\n    val composition by rememberLottieComposition(LottieCompositionSpec.RawRes(R.raw.loading_animation))\n    val progress by animateLottieCompositionAsState(\n        composition = composition,\n        iterations = LottieConstants.IterateForever\n    )\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .fillMaxSize()\n    ) {\n        LottieAnimation(\n            composition = composition,\n            progress = { progress },\n            modifier = Modifier.size(200.dp)\n        )\n    }\n}\n</code></pre> <p></p> <p>Como pode ver, \u00e9 bem simples utilizar anima\u00e7\u00f5es Lottie no Compose. Voc\u00ea pode conferir a documenta\u00e7\u00e3o da biblioteca para ver outros tipos de implementa\u00e7\u00f5es.</p>"},{"location":"animations/#conclusao","title":"Conclus\u00e3o","text":"<p>Anima\u00e7\u00f5es com certeza d\u00e3o um up a mais em qualquer app e conhecer algumas delas no Compose \u00e9 essencial. Compose oferece muitos recursos e facilita muito o uso de anima\u00e7\u00f5es, como voc\u00ea p\u00f4de ver nos exemplos acima. N\u00e3o se esque\u00e7a de conferir a documenta\u00e7\u00e3o para conhecer mais sobre anima\u00e7\u00f5es no Compose.</p>"},{"location":"animations/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Quick guide to Animations in Compose (documenta\u00e7\u00e3o)</li> <li>Animation modifiers and composables (documenta\u00e7\u00e3o)</li> <li>Simple Animation with Jetpack Compose (codelab)</li> </ul>"},{"location":"basic/","title":"Conhecimentos b\u00e1sicos iniciais","text":"<p>Essa se\u00e7\u00e3o descreve algumas coisas b\u00e1sicas importantes para voc\u00ea entender e ficar um pouco mais familiarizado com o Compose. Ao longo de outras se\u00e7\u00f5es, muito do que est\u00e1 sendo dito aqui ser\u00e1 abordado de uma forma mais abrangente.</p>"},{"location":"basic/#funcoes-composable","title":"Fun\u00e7\u00f5es @Composable","text":"<p>Como voc\u00ea j\u00e1 deve ter notado ao criar seu primeiro projeto Compose, a MainActivity vem com uma fun\u00e7\u00e3o Greeting() com a anota\u00e7\u00e3o @Composable. Essa anota\u00e7\u00e3o serve para dizer ao compilador do Compose que essa fun\u00e7\u00e3o converter\u00e1 dados em UI, isso \u00e9, ir\u00e1 transformar nosso c\u00f3digo escrito em Kotlin (comumente com outras fun\u00e7\u00f5es @Composable) em uma bela tela ou componente. Nesse caso espec\u00edfico, ela est\u00e1 usando apenas a fun\u00e7\u00e3o Text(), que \u00e9 tamb\u00e9m uma @Composable e um componente padr\u00e3o do Material 3 para textos.</p> <p>Algumas notas importantes:</p> <ul> <li>Fun\u00e7\u00f5es Composable que emitem UI n\u00e3o precisam retornar nada, pois elas descrevem o estado da tela desejado em vez de construir widgets de UI.</li> <li>A conven\u00e7\u00e3o de nomenclatura para fun\u00e7\u00f5es Composable que n\u00e3o retornam nada (Unit) \u00e9 a PascalCase e devem ser substantivos, como \u00e9 o caso de Greeting(). J\u00e1 fun\u00e7\u00f5es Composable que retornam algo devem estar no formato camelCase, como stringResource().</li> <li>S\u00e3o idempotentes e livres de efeitos colaterais.</li> </ul>"},{"location":"basic/#fases-do-jetpack-compose","title":"Fases do Jetpack Compose","text":"<p>O Compose tem tr\u00eas fases principais:</p> <ol> <li>Composi\u00e7\u00e3o: Qual UI mostrar. O Compose executa fun\u00e7\u00f5es Composable e cria uma descri\u00e7\u00e3o da sua IU.</li> <li>Layout: Onde colocar a UI. Esta fase consiste em duas etapas: medi\u00e7\u00e3o e posicionamento. Os elementos de layout medem e posicionam a si mesmos e a quaisquer elementos filhos em coordenadas 2D, para cada n\u00f3 na \u00e1rvore de layout.</li> <li>Desenho: Como \u00e9 renderizado. Os elementos da UI s\u00e3o desenhados em um Canvas, geralmente uma tela de dispositivo.</li> </ol> <p></p> <p>A ordem dessas fases \u00e9 geralmente a mesma, permitindo que os dados fluam em uma dire\u00e7\u00e3o, da composi\u00e7\u00e3o ao layout e ao desenho, para produzir um quadro (tamb\u00e9m conhecido como fluxo de dados unidirecional). BoxWithConstraints e LazyColumn/LazyRow s\u00e3o exce\u00e7\u00f5es not\u00e1veis, onde a composi\u00e7\u00e3o de seus filhos depende da fase de layout dos pais.</p> <p>Voc\u00ea pode presumir com seguran\u00e7a que essas tr\u00eas fases acontecem virtualmente para cada quadro, mas, por uma quest\u00e3o de desempenho, o Compose evita repetir o trabalho que calcularia os mesmos resultados a partir das mesmas entradas em todas essas fases. O Compose ignora a execu\u00e7\u00e3o de uma fun\u00e7\u00e3o Composable se puder reutilizar um resultado anterior, e a UI do Compose n\u00e3o reorganiza ou redesenha a \u00e1rvore inteira se n\u00e3o for necess\u00e1rio. Ele executa apenas a quantidade m\u00ednima de trabalho necess\u00e1ria para atualizar a IU. Essa otimiza\u00e7\u00e3o \u00e9 poss\u00edvel porque o Compose rastreia leituras de estado nas diferentes fases.</p> <p>As informa\u00e7\u00f5es acima foram retiradas diretamente da documenta\u00e7\u00e3o sobre esse t\u00f3pico. Leia mais no link referenciado para ver mais detalhadamente sobre as fases do Compose, se desejar.</p>"},{"location":"basic/#recomposicao","title":"Recomposi\u00e7\u00e3o","text":"<p>Diferente do sistema de Views que usa o paradigma imperativo, o Compose utiliza o paradigma declarativo. Em um modelo de UI imperativo, para alterar um widget, voc\u00ea chama um setter no widget para alterar seu estado interno. Por exemplo: <code>textView.setText(\"Texto do TextView\")</code>. O Compose funciona de forma diferente. Ao inv\u00e9s de setarmos o valor do texto diretamente no componente Text() (o equivalente ao TextView aqui), o nosso componente Text() recebe o texto (estado) e sempre que esse texto for modificado (por conta de algum evento), Text() \u00e9 chamada novamente com esse novo valor. Esse processo que ocorre quando um estado muda e o Compose atualiza a UI \u00e9 chamado de recomposi\u00e7\u00e3o.</p> <p>Compose trabalha com estados e eventos. Um estado \u00e9 qualquer valor que pode mudar com o tempo. J\u00e1 um evento \u00e9 tudo aquilo que acontece que pode modificar a UI, ou seja, os estados. Por exemplo, um clique em algum componente.</p> <p>Portanto, recomposi\u00e7\u00e3o \u00e9 o processo de chamar suas fun\u00e7\u00f5es Composable novamente quando as entradas mudam. Esse processo \u00e9 feito pelo Compose. Quando o Compose recomp\u00f5e com base em novas entradas, ele chama apenas as fun\u00e7\u00f5es ou lambdas que podem ter sido alteradas e ignora o restante. Ao ignorar todas as fun\u00e7\u00f5es ou lambdas que n\u00e3o possuem par\u00e2metros alterados, o Compose pode recompor com efici\u00eancia.</p>"},{"location":"basic/#nao-espere-uma-ordem-na-chamada-de-funcoes-composable","title":"N\u00e3o espere uma ordem na chamada de fun\u00e7\u00f5es Composable","text":"<p>Se uma fun\u00e7\u00e3o Composable cont\u00e9m chamadas para outras fun\u00e7\u00f5es Composable, essas fun\u00e7\u00f5es poder\u00e3o ser executadas em qualquer ordem. O Compose pode reconhecer que alguns elementos da UI t\u00eam maior prioridade do que outros e desenh\u00e1-los primeiro. Por exemplo:</p> <pre><code>@Composable\nfun MyScreen() {\n    Column {\n        TopComponent()\n        ItemList()\n        BottomComponent()\n    }\n}\n</code></pre> <p>N\u00e3o espere que TopComponent() ser\u00e1 chamada primeiro, ItemList() depois e, por fim, BottomComponent(). Isso nem sempre pode ser verdade e essas fun\u00e7\u00f5es devem ser independentes uma da outra.</p>"},{"location":"basic/#compose-utiliza-muito-do-poder-do-kotlin","title":"Compose utiliza muito do poder do Kotlin","text":"<p>Como o Compose \u00e9 desenvolvido em torno do Kotlin, ele utiliza muito de seu poder e facilidades. Uma regalia praticamente onipresente gra\u00e7as a isso s\u00e3o os argumentos padr\u00e3o e argumentos nomeados nas fun\u00e7\u00f5es @Composable. Pegando a fun\u00e7\u00e3o Greeting() de exemplo, veja que temos 2 par\u00e2metros: name e modifier. No entanto, ao cham\u00e1-la, n\u00e3o usamos o modifier, apenas o name, pois j\u00e1 passamos um Modifier como valor padr\u00e3o. Isso s\u00f3 \u00e9 poss\u00edvel gra\u00e7as a essas caracter\u00edsticas do Kotlin citadas anteriormente.</p> <p>Voc\u00ea pode n\u00e3o ter notado, mas a fun\u00e7\u00e3o Text() segue essa mesma caracter\u00edstica. Ela possui v\u00e1rios outros par\u00e2metros, como color, fontSize, textAlign etc., mas como eles j\u00e1 est\u00e3o definidos com valores padr\u00e3o, n\u00e3o precisamos passar nenhum valor, com exce\u00e7\u00e3o do texto em si, que \u00e9 obrigat\u00f3rio (modifier \u00e9 usado apenas como exemplo, mas ele tamb\u00e9m n\u00e3o \u00e9 obrigat\u00f3rio).</p> <p>Voc\u00ea ver\u00e1 isso se repetindo em praticamente todos os componentes do Compose, inclusive usar\u00e1 bastante disso, j\u00e1 que como \u00e9 de se imaginar, facilita muito a componentiza\u00e7\u00e3o.</p>"},{"location":"basic/#nomear-argumentos-e-uma-boa-pratica","title":"Nomear argumentos \u00e9 uma boa pr\u00e1tica","text":"<p>\u00c9 recomend\u00e1vel na maioria das vezes nomear seus argumentos. Por exemplo:</p> <pre><code>@Composable\nfun Profile(\n    name: String,\n    age: Int,\n    online: Boolean\n) {...}\n</code></pre> <p>Ao inv\u00e9s disso: <code>Profile(\"John\", 20, true)</code></p> <p>Fa\u00e7a isso: <code>Profile(name = \"John\", age = 20, online = true)</code></p> <p>Essa n\u00e3o \u00e9 uma boa pr\u00e1tica exclusiva no contexto do Compose, mas no c\u00f3digo Kotlin no geral, por\u00e9m, como normalmente as fun\u00e7\u00f5es Composable t\u00eam diversos par\u00e2metros, essa pr\u00e1tica acaba sendo vantajosa. Obviamente isso nem sempre \u00e9 necess\u00e1rio, quando a fun\u00e7\u00e3o tem apenas 1 ou 2 par\u00e2metros, por exemplo, mas na maioria das vezes \u00e9 uma boa pr\u00e1tica para fins de legibilidade.</p>"},{"location":"basic/#funcoes-composable-com-sua-devida-visibilidade","title":"Fun\u00e7\u00f5es Composable com sua devida visibilidade","text":"<p>Tanto na documenta\u00e7\u00e3o oficial quanto nesse conte\u00fado voc\u00ea ver\u00e1 exemplos usando fun\u00e7\u00f5es sem nenhum modificador de acesso expl\u00edcito, o que significa fun\u00e7\u00f5es p\u00fablicas por padr\u00e3o no Kotlin. Como criamos muitas fun\u00e7\u00f5es Composable que n\u00e3o est\u00e3o presentes dentro de uma classe ou outro escopo espec\u00edfico, ao deixarmos uma fun\u00e7\u00e3o public, podemos us\u00e1-la em qualquer parte do projeto naquele m\u00f3dulo. Isso significa que se tivermos uma fun\u00e7\u00e3o ImageList() no arquivo HomeScreen.kt, por exemplo, poderemos cham\u00e1-la em qualquer parte do projeto naquele m\u00f3dulo. Mas se ImageList() s\u00f3 faz sentido para a HomeScreen, ent\u00e3o \u00e9 importante que voc\u00ea deixe-a privada para evitar esse problema.</p> <p>Sua fun\u00e7\u00e3o s\u00f3 ser\u00e1 usada naquele arquivo espec\u00edfico? N\u00e3o use:</p> <pre><code>@Composable\nfun ImageList() {...}\n</code></pre> <p>Use:</p> <pre><code>@Composable\nprivate fun ImageList() {...}\n</code></pre>"},{"location":"basic/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Thinking in Compose (documenta\u00e7\u00e3o)</li> <li>Thinking in Compose (artigo)</li> </ul>"},{"location":"canvas/","title":"Canvas e UI personalizada","text":"<p>Muitos aplicativos precisam ser capazes de controlar com precis\u00e3o o que \u00e9 desenhado na tela, seja algo pequeno como um c\u00edrculo em um lugar espec\u00edfico da tela, ou um arranjo elaborado de elementos gr\u00e1ficos em muitos estilos diferentes. O Compose oferece 3 modificadores \u00fateis para desenhar na tela e criar uma UI mais personalizada: <code>Modifier.drawBehind()</code>, <code>Modifier.drawWithContent()</code> e <code>Modifier.drawWithCache()</code>, cada um com suas particularidades. Al\u00e9m deles, tamb\u00e9m existe uma fun\u00e7\u00e3o Composable Canvas(), que por baixo dos panos \u00e9 apenas um Spacer() com um <code>Modifier.drawBehind()</code> para ser utilizada de forma mais conveniente.</p> <p>Todos os 3 modificadores exp\u00f5em um DrawScope, que \u00e9 um ambiente de desenho com escopo definido que mant\u00e9m seu pr\u00f3prio estado. Isso permite definir os par\u00e2metros para um grupo de elementos gr\u00e1ficos. O DrawScope fornece v\u00e1rios campos \u00fateis, como size, um objeto Size que especifica as dimens\u00f5es atuais do DrawScope.</p> <p>Nos bastidores, o Compose depende do Canvas baseado no sistema de Views e de outros objetos associados. No entanto, o Compose simplifica muitos dos aspectos mais confusos do Canvas.</p>"},{"location":"canvas/#sistema-de-coordenadas","title":"Sistema de coordenadas","text":"<p>Para desenhar algo na tela, voc\u00ea precisa saber o deslocamento (x e y) e o tamanho do seu item. Para isso, voc\u00ea precisa entender o sistema de coordenadas do Compose. A origem do sistema de coordenadas ([0,0]) est\u00e1 no pixel superior esquerdo da \u00e1rea de desenho. x aumenta \u00e0 medida que se move para a direita e y aumenta \u00e0 medida que se move para baixo.</p> <p>Todas as opera\u00e7\u00f5es de desenho s\u00e3o realizadas usando o dimensionamento de pixels. Para garantir um dimensionamento consistente em diferentes densidades de dispositivos e tamanhos de tela, converta de dp usando a fun\u00e7\u00e3o .toPx() ou trabalhe em fra\u00e7\u00f5es do tamanho.</p> <p></p>"},{"location":"canvas/#desenhando-formas-basicas","title":"Desenhando formas b\u00e1sicas","text":"<p>Agora que j\u00e1 vimos um pouco da teoria, vamos \u00e0 pr\u00e1tica!</p>"},{"location":"canvas/#desenhando-retangulos","title":"Desenhando ret\u00e2ngulos","text":"<p>Vamos come\u00e7ar desenhando um ret\u00e2ngulo com a fun\u00e7\u00e3o drawRect():</p> <pre><code>@Composable\nprivate fun Rect() {\n    Canvas(\n        modifier = Modifier\n            .fillMaxSize()\n    ) {\n        val rectSize = 150.dp.toPx()\n        drawRect(\n            color = Color.Red,\n            topLeft = Offset(0f, 0f),\n            size = Size(rectSize, rectSize),\n            style = Fill\n        )\n    }\n}\n</code></pre> <p></p> <p>Alguns pontos importantes sobre os par\u00e2metros da fun\u00e7\u00e3o drawRect():</p> <ul> <li>topLeft: Representa a posi\u00e7\u00e3o do ret\u00e2ngulo, um Offset do canto superior esquerdo. A maioria das fun\u00e7\u00f5es de desenho t\u00eam valores padr\u00e3o para a maioria dos par\u00e2metros, e drawRect() tem o valor Offset.Zero para topLeft, que \u00e9 o mesmo que Offset(0f, 0f) que utilizamos.</li> <li>size: O nome fala por si s\u00f3. No nosso caso, estamos usando o mesmo tamanho para altura e largura, o que seria o equivalente a um quadrado.</li> <li>style: Representa o estilo do desenho, do tipo DrawStyle. Fill significa que toda a \u00e1rea ser\u00e1 preenchida com a cor fornecida. A outra op\u00e7\u00e3o \u00e9 Stroke, que desenha com um tra\u00e7o.</li> </ul> <p>Tamb\u00e9m temos a fun\u00e7\u00e3o drawRoundRect(), que desenha um ret\u00e2ngulo arredondado. Veja um exemplo de um ret\u00e2ngulo com style do tipo Stroke e a fun\u00e7\u00e3o drawRoundRect() em a\u00e7\u00e3o:</p> <pre><code>@Composable\nprivate fun Rect() {\n    Canvas(\n        modifier = Modifier\n            .fillMaxSize()\n    ) {\n        val width = size.width\n        val height = size.height\n\n        val rectSize = 150.dp.toPx()\n        drawRect(\n            color = Color.Red,\n            topLeft = Offset(\n                x = (width - rectSize) / 2,\n                y = (height - rectSize) / 2 - rectSize - (30.dp.toPx())\n            ),\n            size = Size(rectSize, rectSize),\n            style = Stroke(width = 10.dp.toPx())\n        )\n\n        val corner = 24.dp.toPx()\n        drawRoundRect(\n            color = Color.Red,\n            topLeft = Offset(\n                x = (width - rectSize) / 2,\n                y = (height - rectSize) / 2\n            ),\n            size = Size(rectSize, rectSize),\n            style = Fill,\n            cornerRadius = CornerRadius(x = corner, y = corner)\n        )\n    }\n}\n</code></pre> <p></p>"},{"location":"canvas/#desenhando-circulos","title":"Desenhando c\u00edrculos","text":"<p>Tamb\u00e9m temos a fun\u00e7\u00e3o drawCircle(), que desenha um c\u00edrculo.</p> <pre><code>@Composable\nprivate fun Circle() {\n    Canvas(\n        modifier = Modifier\n            .fillMaxSize()\n    ) {\n        val circleRadius = 100.dp.toPx()\n        drawCircle(\n            color = Color.Blue,\n            radius = circleRadius,\n            center = Offset(center.x, center.y - circleRadius),\n            style = Fill\n        )\n        drawCircle(\n            color = Color.Blue,\n            radius = circleRadius,\n            center = Offset(center.x, center.y + (circleRadius + 20.dp.toPx())),\n            style = Stroke(width = 10.dp.toPx())\n        )\n    }\n}\n</code></pre> <ul> <li>radius: O raio do c\u00edrculo.</li> <li>center: A posi\u00e7\u00e3o central do c\u00edrculo.</li> </ul> <p></p>"},{"location":"canvas/#desenhando-arcos","title":"Desenhando arcos","text":"<p>Podemos desenhar arcos com a fun\u00e7\u00e3o drawArc().</p> <pre><code>@Composable\nprivate fun Arc() {\n    Canvas(\n        modifier = Modifier\n            .fillMaxSize()\n    ) {\n        val arcSize = 150.dp.toPx()\n        drawArc(\n            color = Color.Blue,\n            startAngle = 0f,\n            sweepAngle = 270f,\n            topLeft = Offset(5.dp.toPx(), arcSize),\n            size = Size(arcSize, arcSize),\n            useCenter = true\n        )\n        drawArc(\n            color = Color.Blue,\n            startAngle = 0f,\n            sweepAngle = 270f,\n            topLeft = Offset(arcSize + 20.dp.toPx(), arcSize),\n            size = Size(arcSize, arcSize),\n            useCenter = false\n        )\n\n        drawArc(\n            color = Color.Red,\n            startAngle = 90f,\n            sweepAngle = 180f,\n            topLeft = Offset(5.dp.toPx(), (arcSize * 2) + 30.dp.toPx()),\n            size = Size(arcSize, arcSize),\n            useCenter = true,\n            style = Stroke(width = 6.dp.toPx()),\n        )\n        drawArc(\n            color = Color.Red,\n            startAngle = 90f,\n            sweepAngle = 180f,\n            topLeft = Offset(arcSize + 20.dp.toPx(), (arcSize * 2) + 30.dp.toPx()),\n            size = Size(arcSize, arcSize),\n            useCenter = false,\n            style = Stroke(width = 6.dp.toPx()),\n        )\n    }\n}\n</code></pre> <p></p> <ul> <li>startAngle: \u00c2ngulo inicial em graus.</li> <li>sweepAngle: Tamanho do arco em graus desenhado no sentido hor\u00e1rio em rela\u00e7\u00e3o a startAngle. </li> <li>useCenter: Determina se o arco deve fechar o centro dos limites.</li> <li>topLeft: Um Offset que define a posi\u00e7\u00e3o inicial (canto superior esquerdo) do ret\u00e2ngulo que circunscreve o arco.</li> </ul>"},{"location":"canvas/#desenhando-paths","title":"Desenhando Paths","text":"<p>Um path \u00e9 uma s\u00e9rie de instru\u00e7\u00f5es matem\u00e1ticas que resultam em um desenho, uma vez executado. Podemos desenhar um path usando a fun\u00e7\u00e3o drawPath(), que precisa de um objeto do tipo Path e alguns outros argumentos.</p>"},{"location":"canvas/#desenhando-um-triangulo","title":"Desenhando um tri\u00e2ngulo","text":"<p>Vamos ver um exemplo de um tri\u00e2ngulo utilizando a fun\u00e7\u00e3o drawPath(). Veja o c\u00f3digo:</p> <pre><code>@Composable\nprivate fun Path() {\n    Spacer(\n        modifier = Modifier\n            .drawWithCache {\n                val path = Path().apply {\n                    moveTo(x = 0f, y = size.height / 2)\n                    lineTo(x = size.width / 2, y = 0f)\n                    lineTo(x = size.width, y = size.height / 2)\n                    close()\n                }\n                onDrawBehind {\n                    drawPath(\n                        path = path,\n                        style = Fill,\n                        color = Color.Red\n                    )\n                }\n            }\n            .fillMaxSize()\n    )\n}\n</code></pre> <p></p> <p>Vamos por partes. Dessa vez estamos utilizando a fun\u00e7\u00e3o Modifier.drawWithCache() em um Spacer(). Ela mant\u00e9m os objetos criados dentro dela em cache. Os objetos s\u00e3o armazenados em cache desde que o tamanho da \u00e1rea de desenho seja o mesmo ou que quaisquer objetos de estado lidos n\u00e3o tenham sido alterados. Esse modificador \u00e9 \u00fatil para melhorar o desempenho das chamadas de desenho, pois evita a necessidade de realocar objetos (como Brush, Shader, Path etc.) que s\u00e3o criados no desenho. Use Modifier.drawWithCache() apenas quando estiver criando objetos que devem ser armazenados em cache. Usar esse modificador sem a necessidade de armazenar objetos em cache pode resultar em aloca\u00e7\u00f5es lambda desnecess\u00e1rias.</p> <p>Como \u00faltima chamada, ela espera um onDrawWithContent ou onDrawBehind, que \u00e9 o que estamos utilizando.</p> <p>Agora vamos \u00e0 explica\u00e7\u00e3o do Path criado:</p> <ul> <li> <p>moveTo(x = 0f, y = size.height / 2): Inicia um subpath com a coordenada indicada, ou seja, x e y. No nosso c\u00f3digo, estamos \"se movendo\" para 0f e size.height / 2, que significa o in\u00edcio da tela horizontalmente (x = 0f) e o centro da tela verticalmente (size.height / 2). Como dito antes, dentro de um DrawScope temos acesso a algumas propriedades, como size. Ou seja, size.height = tamanho em pixels desse DrawScope.</p> </li> <li> <p>lineTo(x = size.width / 2, y = 0f): Adiciona um segmento de linha reta do ponto atual ao ponto determinado. No nosso c\u00f3digo, o ponto atual \u00e9 (x = 0f, y = size.height / 2), como j\u00e1 definimos antes com moveTo(). Como usamos lineTo(x = size.width / 2, y = 0f), criamos uma linha reta desse ponto atual at\u00e9 a coordenada indicada, ou seja, o centro da tela horizontalmente e o topo da tela verticalmente (x = size.width / 2, y = 0f).</p> </li> <li> <p>lineTo(x = size.width, y = size.height / 2): Como usamos lineTo() anteriormente, o nosso ponto atual agora \u00e9 (x = size.width / 2, y = 0f). Portanto, criamos uma linha desse ponto at\u00e9 o final da tela horizontalmente e o centro da tela verticalmente (x = size.width, y = size.height / 2).</p> </li> <li> <p>close(): Fecha o \u00faltimo subpath, como se uma linha reta tivesse sido desenhada do ponto atual at\u00e9 o primeiro ponto do subpath. Em resumo, usando close() no final criaremos uma linha do ponto atual (x = size.width, y = size.height / 2) at\u00e9 o primeiro subpath que criamos, que foi definido com o moveTo(x = 0f, y = size.height / 2). Voc\u00ea n\u00e3o ver\u00e1 nenhuma grande diferen\u00e7a se estiver usando o style como Fill, mas se utilizar Stroke, poder\u00e1 notar o que acontece mais claramente. Veja as imagens abaixo utilizando style = Stroke(width = 8.dp.toPx()) com e sem close() no final.</p> </li> </ul> <p> </p> <p>Veja a imagem abaixo para ver um exemplo mais visual do que foi dito acima:</p> <p></p>"},{"location":"canvas/#desenhando-uma-curva-de-bezier","title":"Desenhando uma curva de B\u00e9zier","text":"<p>Vamos usar a fun\u00e7\u00e3o quadraticBezierTo() para criar uma curva de B\u00e9zier. Veja o c\u00f3digo:</p> <pre><code>@Composable\nprivate fun Path() {\n    Spacer(\n        modifier = Modifier\n            .drawWithCache {\n                val width = size.width\n                val height = size.height\n                val path = Path().apply {\n                    moveTo(x = 0f, y = size.height / 2)\n                    quadraticBezierTo(\n                        x1 = size.width / 2,\n                        y1 = 0f,\n                        x2 = size.width,\n                        y2 = size.height / 2\n                    )\n                    close()\n                }\n                onDrawBehind {\n                    drawPath(\n                        path = path,\n                        style = Fill,\n                        color = Color.Red\n                    )\n                }\n            }\n            .fillMaxSize()\n    )\n}\n</code></pre> <p></p> <ul> <li>moveTo(x = 0f, y = size.height / 2): J\u00e1 explicamos sobre essa fun\u00e7\u00e3o e estamos usando os exatos mesmos valores de antes.</li> <li>quadraticBezierTo(): Adiciona um segmento b\u00e9zier quadr\u00e1tico que faz uma curva do ponto atual at\u00e9 o ponto determinado (x2, y2), usando o ponto de controle (x1, y1). Olhando para o nosso c\u00f3digo, o ponto atual \u00e9 (x = 0f, y = size.height / 2). A curva que criamos vai do ponto atual at\u00e9 a coordenada x2 = size.width e y2 = size.height / 2, que significa o fim da tela horizontalmente e o centro da tela verticalmente. J\u00e1 os valores x1 = size.width / 2 e y1 = 0f s\u00e3o usados para criar o ponto de controle da curva, em outras palavras, aplicar o efeito na curva. Com os valores fornecidos, \u00e9 o centro da tela horizontalmente e o in\u00edcio da tela verticalmente (o centro no topo). O close() segue o mesmo princ\u00edpio que j\u00e1 falamos antes.</li> </ul> <p>Veja a imagem abaixo para ver um exemplo mais visual do que foi dito acima:</p> <p></p> <pre><code>@Composable\nprivate fun Path() {\n    Spacer(\n        modifier = Modifier\n            .drawWithCache {\n                val path = Path().apply {\n                    moveTo(x = 0f, y = size.height / 2)\n                    quadraticBezierTo(\n                        x1 = 30.dp.toPx(),\n                        y1 = 0f,\n                        x2 = size.width,\n                        y2 = size.height / 2\n                    )\n                }\n                onDrawBehind {\n                    drawPath(\n                        path = path,\n                        style = Stroke(width = 8.dp.toPx()),\n                        color = Color.Red\n                    )\n                }\n            }\n            .fillMaxSize()\n    )\n}\n</code></pre> <p></p>"},{"location":"canvas/#desenhando-sobre-o-conteudo","title":"Desenhando sobre o conte\u00fado","text":"<p>J\u00e1 vimos o uso da <code>Modifier.drawBehind()</code> e <code>Modifier.drawWithCache()</code>, agora veremos a <code>Modifier.drawWithContent()</code> em pr\u00e1tica. A <code>Modifier.drawWithContent()</code> permite executar opera\u00e7\u00f5es DrawScope antes ou depois do conte\u00fado do Composable. \u00c9 necess\u00e1rio chamar a fun\u00e7\u00e3o drawContent() para renderizar o conte\u00fado Composable, caso contr\u00e1rio ele n\u00e3o ser\u00e1 desenhado. Voc\u00ea pode escolher a ordem de chamada dele, influenciando na UI final.</p> <p>Veja o exemplo abaixo, com 2 Text(). No primeiro, o ret\u00e2ngulo \u00e9 desenhado antes do conte\u00fado do Text() (o texto em si, nesse caso), pois chamamos drawContent() antes da opera\u00e7\u00e3o de desenho drawRect(). J\u00e1 no segundo Text(), o ret\u00e2ngulo \u00e9 desenhado por tr\u00e1s, pois chamamos drawContent() depois de drawRect().</p> <pre><code>@Composable\nprivate fun DrawWithContent() {\n    Column(modifier = Modifier.padding(12.dp)) {\n        Text(\n            text = \"Jetpack Compose Journey\",\n            color = Color.Black,\n            fontSize = 24.sp,\n            modifier = Modifier.drawWithContent {\n                drawContent()\n                drawRect(\n                    color = Color.Red,\n                    topLeft = Offset(x = 0f, y = size.height / 2),\n                    size = Size(width = size.width, height = 5.dp.toPx()),\n                    style = Fill\n                )\n            }\n        )\n        Spacer(Modifier.height(12.dp))\n        Text(\n            text = \"Jetpack Compose Journey\",\n            color = Color.Black,\n            fontSize = 24.sp,\n            modifier = Modifier.drawWithContent {\n                drawRect(\n                    color = Color.Red,\n                    topLeft = Offset(x = 0f, y = size.height / 2),\n                    size = Size(width = size.width, height = 5.dp.toPx()),\n                    style = Fill\n                )\n                drawContent()\n            }\n        )\n    }\n}\n</code></pre> <p></p>"},{"location":"canvas/#tela-de-login-com-decoracoes","title":"Tela de Login com decora\u00e7\u00f5es","text":"<p>Para n\u00e3o ficar apenas em desenhos simples de exemplos, vamos criar uma tela de login com algumas pequenas decora\u00e7\u00f5es utilizando fun\u00e7\u00f5es como drawCircle() e drawPath(). Antes de tudo, vamos criar uma extension function para desenhar as decora\u00e7\u00f5es. Pouparei as explica\u00e7\u00f5es sobre ela, pois j\u00e1 vimos tudo ao longo dessa se\u00e7\u00e3o.</p> <pre><code>private fun DrawScope.drawDecoration(color: Color) {\n    drawCircle(\n        color = color,\n        radius = 150.dp.toPx(),\n        center = Offset(x = 0f, y = 0f),\n        style = Fill\n    )\n    drawCircle(\n        color = color,\n        radius = 120.dp.toPx(),\n        center = Offset(x = 120.dp.toPx(), y = -30.dp.toPx()),\n        style = Fill\n    )\n\n    val path = Path().apply {\n        moveTo(x = 0f, y = size.height)\n        quadraticBezierTo(\n            x1 = size.width / 2,\n            y1 = size.height - 150.dp.toPx(),\n            x2 = size.width,\n            y2 = size.height\n        )\n        close()\n    }\n    drawPath(\n        path = path,\n        color = color,\n        style = Fill\n    )\n}\n</code></pre> <p>Agora vamos criar a LoginScreen de exemplo, utilizando <code>Modifier.drawBehind()</code> com a nossa drawDecoration().</p> <pre><code>@Composable\nfun LoginScreen() {\n    var email by remember { mutableStateOf(\"\") }\n    var password by remember { mutableStateOf(\"\") }\n    val decorationColor = MaterialTheme.colorScheme.primary\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .fillMaxSize()\n            .drawBehind {\n                drawDecoration(color = decorationColor)\n            }\n            .padding(26.dp)\n    ) {\n        Text(\n            text = \"Login\",\n            fontSize = 42.sp,\n            fontWeight = FontWeight.Bold\n        )\n        Spacer(Modifier.height(24.dp))\n        OutlinedTextField(\n            value = email,\n            onValueChange = { email = it },\n            label = {\n                Text(text = \"E-mail\")\n            },\n            leadingIcon = {\n                Icon(\n                    imageVector = Icons.Default.Email,\n                    contentDescription = null\n                )\n            },\n            shape = CircleShape,\n            modifier = Modifier.fillMaxWidth()\n        )\n        Spacer(Modifier.height(12.dp))\n        OutlinedTextField(\n            value = password,\n            onValueChange = { password = it },\n            label = {\n                Text(text = \"Senha\")\n            },\n            leadingIcon = {\n                Icon(\n                    imageVector = Icons.Default.Lock,\n                    contentDescription = null\n                )\n            },\n            shape = CircleShape,\n            modifier = Modifier.fillMaxWidth()\n        )\n        Spacer(Modifier.height(18.dp))\n        Button(\n            onClick = {},\n            contentPadding = PaddingValues(16.dp),\n            modifier = Modifier.fillMaxWidth()\n        ) {\n            Text(text = \"Login\")\n        }\n    }\n}\n</code></pre> <p></p> <p>Como \u00e9 poss\u00edvel observar, as decora\u00e7\u00f5es d\u00e3o um visual mais interessante \u00e0 tela.</p>"},{"location":"canvas/#conclusao","title":"Conclus\u00e3o","text":"<p>Canvas \u00e9 uma ferramenta muito poderosa e entender sua utiliza\u00e7\u00e3o \u00e9 importante para criar componentes e uma UI mais personalizada. Assim como praticamente tudo em rela\u00e7\u00e3o ao XML, Compose simplifica muito o desenho na tela com Canvas, como foi poss\u00edvel ver ao longo dessa se\u00e7\u00e3o. Voc\u00ea pode ler mais na documenta\u00e7\u00e3o para descobrir algumas outras funcionalidades que n\u00e3o foram abordadas aqui, como por exemplo, transforma\u00e7\u00f5es b\u00e1sicas.</p>"},{"location":"canvas/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Graphics in Compose (documenta\u00e7\u00e3o)</li> <li>Easing in to Easing Curves in Jetpack Compose (artigo)</li> <li>Exploring Canvas in Jetpack Compose \u2014 Crafting Graphics, Animations, and Game Experiences (artigo)</li> <li>How to Draw an Arc in Jetpack Compose Canvas (artigo)</li> <li>Jetpack Compose Canvas (artigo)</li> <li>Creating a Custom Microsoft Icon with Jetpack Compose (artigo)</li> </ul>"},{"location":"conclusion/","title":"Conclus\u00e3o","text":"<p>Chegamos ao fim desse conte\u00fado, mas \u00e9 s\u00f3 o in\u00edcio da jornada! Muito obrigado por ter lido e espero que esse conte\u00fado tenha sido \u00fatil para voc\u00ea de alguma forma. H\u00e1 muito mais para se ver no Jetpack Compose, mas agora voc\u00ea tem os conhecimentos b\u00e1sicos principais para continuar.</p> <p>Como dito no in\u00edcio, os c\u00f3digos de exemplos usados em cada se\u00e7\u00e3o podem ser encontrados no reposit\u00f3rio Compose Journey Samples.</p> <p>Se de alguma forma voc\u00ea achou esse conte\u00fado \u00fatil, n\u00e3o se esque\u00e7a de apoiar deixando a sua  no reposit\u00f3rio.</p>"},{"location":"conclusion/#compose-samples-e-now-in-android","title":"Compose samples e Now in AndroidBoa jornada!","text":"<p>H\u00e1 alguns reposit\u00f3rios oficiais do Android que podem ser usados para refer\u00eancias de estudos e boas pr\u00e1ticas, como os listados abaixo.</p> <ul> <li> <p>Compose samples: Cont\u00e9m um conjunto de projetos individuais do Android Studio para ajudar voc\u00ea a aprender sobre o Compose no Android. Cada amostra demonstra diferentes casos de uso, n\u00edveis de complexidade e APIs. \u00c9 ideal para quem est\u00e1 iniciando e deseja ver pr\u00e1ticas comuns no Compose.</p> </li> <li> <p>Now in Android: \u00c9 um aplicativo Android totalmente funcional desenvolvido inteiramente com Kotlin e Jetpack Compose. Ele segue as pr\u00e1ticas recomendadas de design e desenvolvimento do Android e pretende ser uma refer\u00eancia \u00fatil para desenvolvedores. Como um aplicativo em execu\u00e7\u00e3o, seu objetivo \u00e9 ajudar os desenvolvedores a se manterem atualizados com o mundo do desenvolvimento Android, fornecendo atualiza\u00e7\u00f5es regulares de not\u00edcias. Diferente do Compose samples, esse \u00e9 um reposit\u00f3rio mais complexo e pode n\u00e3o ser muito recomendado para iniciantes, por\u00e9m, pode te ajudar ao longo da jornada, contendo boas pr\u00e1ticas de desenvolvimento.</p> </li> </ul> <p></p>"},{"location":"interoperability/","title":"Interoperabilidade: Usando Views no Compose","text":"<p>O Compose j\u00e1 possui suporte a muitos recursos e bibliotecas, no entanto, o ecossistema Android como um todo ainda tem depend\u00eancias com o sistema de Views/XML e algumas bibliotecas ainda n\u00e3o oferecem suporte ao Jetpack Compose. Isso tamb\u00e9m \u00e9 especialmente v\u00e1lido em um contexto de migra\u00e7\u00e3o, onde um app com o sistema de Views est\u00e1 em processo de migra\u00e7\u00e3o para o Compose. Como reescrever toda a base de c\u00f3digo de uma vez muitas vezes \u00e9 impens\u00e1vel, Compose tamb\u00e9m oferece o recurso de interoperabilidade, onde podemos tanto usar Views no Compose, quanto usar Compose em Views, o que facilita reescrever apenas as partes essenciais por etapas.</p> <p>Nessa se\u00e7\u00e3o vamos ver uma breve introdu\u00e7\u00e3o a esse recurso de interoperabilidade.</p>"},{"location":"interoperability/#androidview","title":"AndroidView","text":"<p>Compose possui o componente AndroidView() para utilizar Views em Composables. Vamos usar o TextView como um pequeno exemplo b\u00e1sico.</p> <pre><code>@Composable\nprivate fun ComposeTextView() {\n    var count by remember { mutableIntStateOf(0) }\n    AndroidView(\n        factory = { context -&gt;\n            // Cria e retorna a View (TextView)\n            TextView(context).apply {\n                // Aplica customiza\u00e7\u00f5es iniciais\n                textSize = 22f\n                setTextColor(Color.Blue.toArgb())\n                setOnClickListener {\n                    count++\n                }\n            }\n        },\n        update = { textView -&gt;\n            // Atualiza a View de acordo com alguma mudan\u00e7a de estado\n            textView.text = \"Jetpack Compose Journey $count\"\n        },\n        modifier = Modifier.fillMaxWidth()\n    )\n}\n</code></pre> <p></p> <p>Temos dois par\u00e2metros importantes:</p> <ul> <li>factory \u00e9 onde inicializamos a View a ser utilizada. O trecho de c\u00f3digo em factory ser\u00e1 executado exatamente uma vez e \u00e9 o lugar ideal para inicializar propriedades importantes iniciais. No c\u00f3digo acima, definimos algumas pequenas propriedades do TextView e tamb\u00e9m adicionamos um setOnClickListener(), que ser\u00e1 acionado sempre que o TextView for tocado.</li> <li>update ser\u00e1 chamado m\u00faltiplas vezes e \u00e9 o lugar certo para realizar atualiza\u00e7\u00f5es de propriedades da View com base em alguma mudan\u00e7a de estado. Como ele \u00e9 chamado m\u00faltiplas vezes nas recomposi\u00e7\u00f5es, \u00e9 importante estar atento para n\u00e3o realizar opera\u00e7\u00f5es muito caras aqui.</li> </ul> <p>Duas bibliotecas populares que ainda n\u00e3o oferecem suporte oficial ao Compose e podem ser utilizadas com AndroidView() s\u00e3o a Media3/ExoPlayer e AdMob.</p>"},{"location":"interoperability/#androidviewbinding-e-fragments-no-compose","title":"AndroidViewBinding e Fragments no Compose","text":"<p>Tamb\u00e9m \u00e9 poss\u00edvel utilizar o componente AndroidViewBinding para carregar layouts gerados pelo ViewBinding. Por\u00e9m, diferente do AndroidView, \u00e9 preciso adicionar a depend\u00eancia abaixo e ativar o ViewBinding no build.gradle (app) (se voc\u00ea estiver usando XML, provavelmente j\u00e1 est\u00e1 fazendo esse \u00faltimo):</p> <pre><code>android {\n    ...\n    buildFeatures {\n        compose = true\n        viewBinding = true\n    }\n    ...\n\ndependencies {\n    ...\n    implementation(\"androidx.compose.ui:ui-viewbinding\")\n    ...\n}\n</code></pre> <p>Dessa forma podemos utilizar o layout da seguinte forma abaixo, com o exemplo retirado da documenta\u00e7\u00e3o:</p> <pre><code>@Composable\nfun AndroidViewBindingExample() {\n    AndroidViewBinding(ExampleLayoutBinding::inflate) {\n        exampleView.setBackgroundColor(Color.GRAY)\n    }\n}\n</code></pre> <p>E para utilizar Fragments, tamb\u00e9m utilizamos AndroidViewBinding, que tem manipula\u00e7\u00e3o espec\u00edfica de Fragment, como a remo\u00e7\u00e3o do Fragment quando o Composable sai da composi\u00e7\u00e3o. Fa\u00e7a isso inflando um XML contendo um FragmentContainerView como suporte para o Fragment.</p> <p>Por exemplo, se voc\u00ea tiver my_fragment_layout.xml, poder\u00e1 usar um c\u00f3digo como o abaixo ao substituir o atributo XML android:name pelo nome da classe do Fragment:</p> <pre><code>&lt;androidx.fragment.app.FragmentContainerView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/fragment_container_view\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:name=\"com.example.compose.snippets.interop.MyFragment\" /&gt;\n</code></pre> <p>E no Compose, use da seguinte forma:</p> <pre><code>@Composable\nfun FragmentInComposeExample() {\n    AndroidViewBinding(MyFragmentLayoutBinding::inflate) {\n        val myFragment = fragmentContainerView.getFragment&lt;MyFragment&gt;()\n        // ...\n    }\n}\n</code></pre>"},{"location":"interoperability/#conclusao","title":"Conclus\u00e3o","text":"<p>Evitei exemplos mais elaborados nos t\u00f3picos de AndroidViewBinding e Fragments porque precisaria usar XML para ter algo mais pr\u00e1tico. Como n\u00e3o \u00e9 a inten\u00e7\u00e3o desse conte\u00fado abordar XML, achei melhor utilizar apenas os exemplos da pr\u00f3pria documenta\u00e7\u00e3o, pois caso voc\u00ea de fato precise disso, j\u00e1 deve estar familiarizado com XML para tal e essa pequena introdu\u00e7\u00e3o pode ser o suficiente para saber que \u00e9 poss\u00edvel.</p> <p>Vimos apenas o uso de Views no Compose, mas como dito antes, tamb\u00e9m podemos utilizar Compose em Views. Pelos mesmos motivos citados acima, evitarei falar sobre esse t\u00f3pico nessa se\u00e7\u00e3o e voc\u00ea pode ler mais sobre isso na documenta\u00e7\u00e3o.</p>"},{"location":"interoperability/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Using Compose in Views (documenta\u00e7\u00e3o)</li> <li>Using Views in Compose (documenta\u00e7\u00e3o)</li> </ul>"},{"location":"lists/","title":"Listas","text":"<p>Exibir listas \u00e9 uma fun\u00e7\u00e3o bastante comum em qualquer app e nessa se\u00e7\u00e3o vamos aprender um pouco sobre como listas funcionam e podem ser implementadas no Compose.</p>"},{"location":"lists/#scroll-com-modifier","title":"Scroll com Modifier","text":"<p>\u00c0s vezes n\u00e3o precisamos de uma lista em si, mas queremos apenas um conte\u00fado rol\u00e1vel, como o ScrollView do XML. Existem 2 modificadores \u00fateis que podem ser usados com layouts como Column para obter esse comportamento: <code>Modifier.verticalScroll()</code> e <code>Modifier.horizontalScroll()</code>. Veja um exemplo abaixo:</p> <pre><code>@Composable\nfun MyScreen() {\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .verticalScroll(rememberScrollState())\n    ) {\n       // Conte\u00fado que pode ultrapassar a resolu\u00e7\u00e3o da tela verticalmente\n    }\n}\n</code></pre> <p>Isso \u00e9 \u00fatil para layouts ou listas pequenas que ultrapassam a tela, por\u00e9m, pode causar problemas de desempenho com listas grandes ou com tamanho desconhecido, pois todos os itens ser\u00e3o compostos e processados, estejam ou n\u00e3o vis\u00edveis na tela.</p>"},{"location":"lists/#lazycolumn-e-lazyrow","title":"LazyColumn e LazyRow","text":"<p>Compose fornece um conjunto de componentes que apenas comp\u00f5em e processa os itens atualmente vis\u00edveis. Um comportamento bem similar ao RecyclerView do XML. Alguns desses componentes s\u00e3o o LazyColumn e LazyRow, que como os nomes sugerem, fornecem uma lista de rolagem vertical e horizontal, respectivamente.</p> <p>Vamos criar uma lista b\u00e1sica de imagens utilizando LazyColumn. Primeiro vamos criar uma data class para representar as imagens:</p> <pre><code>data class ResourceImage(\n    @DrawableRes val resourceId: Int,\n    val title: String\n)\n</code></pre> <p>Agora vamos criar o item da lista:</p> <pre><code>@Composable\nprivate fun ImageItem(\n    image: ResourceImage,\n    onClick: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n    val shape = RoundedCornerShape(16.dp)\n    OutlinedCard(\n        shape = shape,\n        border = BorderStroke(1.dp, Color.Black),\n        modifier = modifier\n            .fillMaxWidth()\n            .padding(8.dp)\n            .clip(shape)\n            .clickable { onClick.invoke() }\n    ) {\n        Row(verticalAlignment = Alignment.CenterVertically) {\n            Image(\n                painter = painterResource(id = image.resourceId),\n                contentDescription = image.title,\n                contentScale = ContentScale.Crop,\n                modifier = Modifier\n                    .size(100.dp)\n                    .clip(shape)\n            )\n            Spacer(Modifier.width(8.dp))\n            Text(\n                text = image.title,\n                fontSize = 18.sp\n            )\n        }\n    }\n}\n</code></pre> <p>E agora a nossa fun\u00e7\u00e3o utilizando a LazyColumn:</p> <pre><code>@Composable\nprivate fun ImageList(\n    imageList: List&lt;ResourceImage&gt;,\n    modifier: Modifier = Modifier\n) {\n    val context = LocalContext.current\n    LazyColumn(modifier = modifier) {\n        items(imageList) { image -&gt;\n            ImageItem(\n                image = image,\n                onClick = {\n                    Toast.makeText(context, image.title, Toast.LENGTH_SHORT).show()\n                }\n            )\n        }\n    }\n}\n</code></pre> <p>Para fins de exemplo, um Toast ser\u00e1 exibido quando tocar no item da lista. Por fim, temos a nossa ImageScreen:</p> <pre><code>@Composable\nfun ImageScreen() {\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n    ) {\n        val imageList = remember {\n            List(25) { index -&gt;\n                ResourceImage(\n                    resourceId = if (index % 2 == 0) R.drawable.img_nature else R.drawable.img_moon_space,\n                    title = \"Image $index\"\n                )\n            }\n        }\n        ImageList(imageList = imageList)\n    }\n}\n</code></pre> <p></p> <p>Uma LazyRow segue o mesmo princ\u00edpio e \u00e9 f\u00e1cil implementar. Para evitar uma se\u00e7\u00e3o longa, n\u00e3o teremos exemplos dela por aqui.</p>"},{"location":"lists/#lazylistscope","title":"LazyListScope","text":"<p>Diferente de outros componentes no Compose onde o \u00faltimo par\u00e2metro \u00e9 um content que espera um Composable qualquer, as lazy lists funcionam de uma maneira um pouco diferente, fornecendo um LazyListScope.(). Como pode ver no c\u00f3digo da ImageList(), n\u00f3s usamos a fun\u00e7\u00e3o items() que recebe como argumento a nossa lista de imagens. Al\u00e9m de items(), podemos utilizar a itemsIndexed(), que segue praticamente o mesmo princ\u00edpio do items(), mas incluindo um index; e tamb\u00e9m a item(), que pode ser usada para criar um item espec\u00edfico sem necessariamente fazer parte da lista.</p> <p>Vamos modificar um pouco a fun\u00e7\u00e3o ImageList(), adicionando um item() antes e depois da nossa lista de imagens. Veja o exemplo:</p> <pre><code>@Composable\nprivate fun ImageListWithItem(\n    imageList: List&lt;ResourceImage&gt;,\n    modifier: Modifier = Modifier,\n) {\n    val context = LocalContext.current\n    LazyColumn(modifier = modifier) {\n        item {\n            Box(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(50.dp)\n                    .background(Color.Blue)\n                    .padding(8.dp)\n            ) {\n                Text(\n                    text = \"Minhas imagens\",\n                    color = Color.White,\n                    fontSize = 16.sp,\n                    modifier = Modifier.align(Alignment.CenterStart)\n                )\n            }\n        }\n\n        items(imageList) { image -&gt;\n            ImageItem(\n                image = image,\n                onClick = {\n                    Toast.makeText(context, image.title, Toast.LENGTH_SHORT).show()\n                }\n            )\n        }\n\n        item {\n            Box(\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(50.dp)\n                    .background(Color.Red)\n                    .padding(8.dp)\n            ) {\n                Text(\n                    text = \"Nenhuma nova imagem por enquanto.\",\n                    color = Color.White,\n                    fontSize = 16.sp,\n                    modifier = Modifier.align(Alignment.CenterStart)\n                )\n            }\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"lists/#lazy-grids","title":"Lazy grids","text":"<p>Al\u00e9m da LazyColumn e LazyRow, Compose oferece as op\u00e7\u00f5es LazyVerticalGrid e LazyHorizontalGrid. Assim como as citadas anteriormente, as listas em formato grid s\u00e3o bem f\u00e1ceis de utilizar. Vamos reutilizar o c\u00f3digo que j\u00e1 fizemos antes e modificar apenas as fun\u00e7\u00f5es ImageList() e ImageItem().</p> <pre><code>@Composable\nprivate fun ImageList(\n    imageList: List&lt;ResourceImage&gt;,\n    modifier: Modifier = Modifier\n) {\n    val context = LocalContext.current\n    LazyVerticalGrid(\n        columns = GridCells.Fixed(3),\n        modifier = modifier\n    ) {\n        items(imageList) { image -&gt;\n            ImageItem(\n                image = image,\n                onClick = {\n                    Toast.makeText(context, image.title, Toast.LENGTH_SHORT).show()\n                }\n            )\n        }\n    }\n}\n\n@Composable\nprivate fun ImageItem(\n    image: ResourceImage,\n    onClick: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n) {\n    Card(\n        shape = RoundedCornerShape(0.dp),\n        modifier = modifier\n            .aspectRatio(1f)\n            .padding(2.dp)\n            .clickable { onClick.invoke() }\n    ) {\n        Image(\n            painter = painterResource(id = image.resourceId),\n            contentDescription = image.title,\n            contentScale = ContentScale.Crop,\n            modifier = Modifier\n                .aspectRatio(1f)\n        )\n    }\n}\n</code></pre> <p></p> <p>Como pode ver, a utiliza\u00e7\u00e3o \u00e9 bem simples. Precisamos apenas definir obrigatoriamente um n\u00famero de columns da grid, que no caso definimos com um n\u00famero fixo de 3 itens com <code>GridCells.Fixed(3)</code>. Tamb\u00e9m podemos utilizar um n\u00famero adapt\u00e1vel, como <code>GridCells.Adaptive(128.dp)</code>, para definir cada coluna como tendo pelo menos 128.dp. Isso pode ser \u00fatil para diferentes tamanhos de tela, j\u00e1 que ela tentar\u00e1 se adaptar de acordo.</p> <p>Se fizermos a modifica\u00e7\u00e3o de <code>columns = GridCells.Fixed(3)</code> para <code>columns = GridCells.Adaptive(128.dp)</code>, podemos obter os mesmos 3 itens dependendo do tamanho da tela. Por\u00e9m, ao girarmos a tela e ficarmos no modo landscape, veremos bem mais itens, como mostra a imagem abaixo.</p> <p></p>"},{"location":"lists/#conclusao","title":"Conclus\u00e3o","text":"<p>H\u00e1 muito mais para se ver sobre listas no Compose. Cada componente oferece tamb\u00e9m outras op\u00e7\u00f5es de personaliza\u00e7\u00e3o que n\u00e3o foram mostrados nessa se\u00e7\u00e3o, como contentPadding, verticalArrangement e horizontalAlignment. Tamb\u00e9m h\u00e1 a op\u00e7\u00e3o de Lazy staggered grid que pode ser \u00fatil em diferentes casos, al\u00e9m de anima\u00e7\u00e3o de itens com <code>Modifier.animateItemPlacement()</code>.</p> <p>Essa se\u00e7\u00e3o focou em mostrar um pouco sobre como as listas funcionam no Compose. Para quem veio do RecyclerView, as lazy lists no Compose s\u00e3o o para\u00edso. Leia a documenta\u00e7\u00e3o para saber muito mais sobre listas.</p>"},{"location":"lists/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Lists and grids (documenta\u00e7\u00e3o)</li> </ul>"},{"location":"modifiers/","title":"Modifiers","text":"<p>J\u00e1 vimos em se\u00e7\u00f5es anteriores v\u00e1rios usos do Modifier. Essa se\u00e7\u00e3o \u00e9 dedicada em falar um pouco sobre ele e algumas outras fun\u00e7\u00f5es que ele fornece.</p> <p>Os modificadores s\u00e3o praticamente onipresentes e permitem decorar as fun\u00e7\u00f5es Composables de v\u00e1rias formas. Como j\u00e1 vimos antes, al\u00e9m de v\u00e1rias outras op\u00e7\u00f5es, com ele \u00e9 poss\u00edvel fazer coisas como:</p> <ul> <li>Adicionar uma cor de fundo com <code>Modifier.background()</code>;</li> <li>Alterar o tamanho com <code>Modifier.size()</code>;</li> <li>Adicionar um padding com <code>Modifier.padding()</code>.</li> </ul>"},{"location":"modifiers/#a-ordem-dos-modificadores-importa","title":"A ordem dos modificadores importa","text":"<p>A ordem dos Modifiers \u00e9 significativa. Como cada fun\u00e7\u00e3o faz altera\u00e7\u00f5es no Modifier anterior, a sequ\u00eancia afeta o resultado final. Vejamos um exemplo disso:</p> <pre><code>@Composable\nprivate fun Item() {\n    Box(\n        modifier = Modifier\n            .size(150.dp)\n            .background(Color.Blue)\n            .padding(24.dp)\n    ) {\n        Text(\n            text = \"Ordem importa!\",\n            color = Color.White\n        )\n    }\n}\n</code></pre> <p></p> <p>Agora vamos mudar a ordem do <code>background()</code> e do <code>padding()</code>:</p> <pre><code>@Composable\nprivate fun Item() {\n    Box(\n        modifier = Modifier\n            .size(150.dp)\n            .padding(24.dp)\n            .background(Color.Blue)\n    ) {\n        Text(\n            text = \"Ordem importa!\",\n            color = Color.White\n        )\n    }\n}\n</code></pre> <p></p> <p>Isso aconteceu porque no primeiro exemplo definimos a cor de fundo antes de definirmos um espa\u00e7amento, o que fez com que a cor preenchesse todo o Box. J\u00e1 no segundo exemplo, definimos um espa\u00e7amento antes e, por consequ\u00eancia, a cor de fundo s\u00f3 preencheu o espa\u00e7o j\u00e1 modificado pelo <code>padding()</code>.</p> <p>Vamos ver mais um exemplo, agora de como o <code>Modifier.clickable()</code> pode ser afetado com outros modificadores. Veja o c\u00f3digo abaixo:</p> <pre><code>@Composable\nprivate fun CarItem() {\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .clickable {}\n            .padding(26.dp)\n            .fillMaxWidth()\n    ) {\n        Image(\n            painter = painterResource(id = R.drawable.img_car),\n            contentDescription = null,\n            contentScale = ContentScale.Crop,\n            modifier = Modifier\n                .size(width = 300.dp, height = 250.dp)\n                .clip(RoundedCornerShape(16.dp))\n        )\n    }\n}\n</code></pre> <p></p> <p>\u00c9 poss\u00edvel clicar e o efeito de clique \u00e9 aplicado em toda a \u00e1rea da Column. Por\u00e9m, mudando a ordem dos modificadores, colocando o <code>padding()</code> primeiro e o <code>clickable()</code> ap\u00f3s ele, n\u00f3s temos o seguinte resultado:</p> <p></p> <p>Agora veja que a Column n\u00e3o \u00e9 mais completamente clic\u00e1vel, pois o <code>Modifier.clickable()</code> foi afetado pelo <code>Modifier.padding()</code>.</p>"},{"location":"modifiers/#margin-no-compose","title":"Margin no Compose","text":"<p>Diferente do sistema de Views, o Compose n\u00e3o possui uma op\u00e7\u00e3o para margin como no XML. Como basicamente margin \u00e9 o espa\u00e7amento entre o componente e outros componentes, e padding \u00e9 o espa\u00e7amento interno do conte\u00fado do componente, ambas funcionalidades podem ser obtidas com <code>Modifier.padding()</code> utilizando o mesmo princ\u00edpio da ordem de modificadores que vimos anteriormente.  </p> <p>Vamos ver um pequeno exemplo. Veja o c\u00f3digo abaixo:</p> <pre><code>@Composable\nprivate fun MarginAndPadding() {\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .background(Color.Black)\n            .width(150.dp)\n    ) {\n        Text(\n            text = \"Texto 1\",\n            color = Color.White,\n            modifier = Modifier\n                .background(Color(0xFF004D40))\n        )\n        Text(\n            text = \"Texto 2\",\n            color = Color.White,\n            modifier = Modifier\n                .background(Color(0xFF004D40))\n        )\n    }\n}\n</code></pre> <p></p> <p>Agora vamos aplicar uma margin em ambos os textos utilizando <code>Modifier.padding()</code>:</p> <pre><code>@Composable\nprivate fun MarginAndPadding() {\n    Column(\n       ...\n    ) {\n        Text(\n            ...\n            modifier = Modifier\n                .padding(6.dp) // Margin\n                .background(Color(0xFF004D40))\n        )\n        Text(\n            ...\n            modifier = Modifier\n                .padding(6.dp) // Margin\n                .background(Color(0xFF004D40))\n        )\n    }\n}\n</code></pre> <p></p> <p>Agora vamos adicionar um padding:</p> <pre><code>@Composable\nprivate fun MarginAndPadding() {\n    Column(\n       ...\n    ) {\n        Text(\n            ...\n            modifier = Modifier\n                .padding(6.dp) // Margin\n                .background(Color(0xFF004D40))\n                .padding(6.dp) // Padding\n        )\n        Text(\n            ...\n            modifier = Modifier\n                .padding(6.dp) // Margin\n                .background(Color(0xFF004D40))\n                .padding(6.dp) // Padding\n        )\n    }\n}\n</code></pre> <p></p> <p>Como voc\u00ea pode ver, ambas as funcionalidades de margin e padding podem ser atingidas com <code>Modifier.padding()</code>, apenas tendo em mente a ordem dos modificadores. Note que da forma que estamos usando, o espa\u00e7amento ser\u00e1 aplicado em todas as dire\u00e7\u00f5es, pois o par\u00e2metro padr\u00e3o \u00e9 all. Existem outras fun\u00e7\u00f5es <code>Modifier.padding()</code> que aceitam argumentos diferentes, como dire\u00e7\u00f5es (start, end, top e bottom) ou orienta\u00e7\u00f5es (vertical e horizontal). Por exemplo:</p> <pre><code>@Composable\nprivate fun MarginAndPadding() {\n    Column(\n       ...\n    ) {\n        Text(\n            ...\n             modifier = Modifier\n                .padding(bottom = 6.dp) // Margin\n                .background(Color(0xFF004D40))\n                .padding(\n                    start = 4.dp,\n                    end = 4.dp,\n                    top = 8.dp,\n                    bottom = 8.dp\n                ) // Padding\n        )\n        Text(\n            ...\n             modifier = Modifier\n                .padding(top = 6.dp) // Margin\n                .background(Color(0xFF004D40))\n                .padding(\n                    start = 4.dp,\n                    end = 4.dp,\n                    top = 8.dp,\n                    bottom = 8.dp\n                ) // Padding\n        )\n    }\n}\n</code></pre> <p></p> <p>Como usamos os mesmos valores para as dire\u00e7\u00f5es com a mesma orienta\u00e7\u00e3o, podemos apenas utilizar horizontal e vertical para atingir o mesmo resultado:</p> <pre><code>@Composable\nprivate fun MarginAndPadding() {\n    Column(\n       ...\n    ) {\n        Text(\n            ...\n            modifier = Modifier\n                .padding(bottom = 6.dp) // Margin\n                .background(Color(0xFF004D40))\n                .padding(horizontal = 4.dp, vertical = 8.dp) // Padding\n        )\n        Text(\n            ...\n            modifier = Modifier\n                .padding(top = 6.dp) // Margin\n                .background(Color(0xFF004D40))\n                .padding(horizontal = 4.dp, vertical = 8.dp) // Padding\n        )\n    }\n}\n</code></pre> <p></p> <p>Se tudo que voc\u00ea precisa \u00e9 de uma margin em um componente para criar um espa\u00e7o em rela\u00e7\u00e3o ao outro, como um marginTop do XML, voc\u00ea pode utilizar o componente Spacer() com <code>Modifier.height()</code> ou <code>Modifier.width()</code>, que pode ser um pouco mais intuitivo. Por exemplo, ao inv\u00e9s disso:</p> <pre><code>@Composable\nprivate fun MarginAndPadding() {\n    Column(\n       ...\n    ) {\n        Text(\n            ...\n            modifier = Modifier\n                .background(Color(0xFF004D40))\n                .padding(horizontal = 4.dp, vertical = 8.dp) // Padding\n        )\n        Text(\n            ...\n            modifier = Modifier\n                .padding(top = 8.dp) // Equivalente ao marginTop do XML\n                .background(Color(0xFF004D40))\n                .padding(horizontal = 4.dp, vertical = 8.dp) // Padding\n        )\n    }\n}\n</code></pre> <p>Voc\u00ea pode fazer isso:</p> <pre><code>@Composable\nprivate fun MarginAndPadding() {\n    Column(\n       ...\n    ) {\n        Text(\n            ...\n            modifier = Modifier\n                .background(Color(0xFF004D40))\n                .padding(horizontal = 4.dp, vertical = 8.dp) // Padding\n        )\n        Spacer(Modifier.height(8.dp))\n        Text(\n            ...\n            modifier = Modifier\n                .background(Color(0xFF004D40))\n                .padding(horizontal = 4.dp, vertical = 8.dp) // Padding\n        )\n    }\n}\n</code></pre>"},{"location":"modifiers/#modificadores-condicionais","title":"Modificadores condicionais","text":"<p>\u00c0s vezes queremos utilizar modificadores de acordo com uma condi\u00e7\u00e3o. Existe uma fun\u00e7\u00e3o <code>Modifier.then()</code> que concatena um Modifier com outro, permitindo criar modificadores condicionais com facilidade. Veja um exemplo disso:</p> <pre><code>@Composable\nprivate fun ConditionalModifier(showBackgroundAndBorderColor: Boolean) {\n    Text(\n        text = \"Compose Journey\",\n        modifier = Modifier\n            .padding(12.dp)\n            .then(\n                if (showBackgroundAndBorderColor) {\n                    Modifier\n                        .background(MaterialTheme.colorScheme.primaryContainer)\n                        .border(BorderStroke(2.dp, MaterialTheme.colorScheme.primary))\n                        .padding(6.dp)\n                } else {\n                    Modifier\n                }\n            )\n    )\n}\n</code></pre> <p>No c\u00f3digo acima, se showBackgroundAndBorderColor for verdadeiro, concatenamos o Modifier atual do Text() com o Modifier que criamos na condi\u00e7\u00e3o. Se n\u00e3o, apenas criamos um Modifier vazio que n\u00e3o far\u00e1 nada. N\u00e3o estamos adicionando mais nenhum Modifier no Text() ap\u00f3s o <code>then()</code>, mas voc\u00ea tamb\u00e9m pode fazer isso, se necess\u00e1rio. Lembre-se que o Modifier criado no <code>Modifier.then()</code> tamb\u00e9m segue a regra de ordem de modificadores que foi discutida antes.</p>"},{"location":"modifiers/#extraindo-e-reutilizando-modificadores","title":"Extraindo e reutilizando modificadores","text":"<p>\u00c0s vezes, pode ser ben\u00e9fico reutilizar as mesmas inst\u00e2ncias de cadeia de modificadores em v\u00e1rios Composables, extraindo-os em vari\u00e1veis \u200b\u200be elevando-os para escopos superiores. Ele pode melhorar a legibilidade do c\u00f3digo ou ajudar a melhorar o desempenho do aplicativo por alguns motivos:</p> <ul> <li>A realoca\u00e7\u00e3o dos modificadores n\u00e3o ser\u00e1 repetida quando ocorrer a recomposi\u00e7\u00e3o de elementos que podem ser compostos que os utilizam.</li> <li>As cadeias de modificadores podem ser potencialmente muito longas e complexas, portanto, reutilizar a mesma inst\u00e2ncia de uma cadeia pode aliviar a carga de trabalho que o Compose runtime precisa realizar ao compar\u00e1-las.</li> <li>Esta extra\u00e7\u00e3o promove uma limpeza de c\u00f3digo, consist\u00eancia e capacidade de manuten\u00e7\u00e3o em toda a base de c\u00f3digo.</li> </ul> <p>Por exemplo, no c\u00f3digo abaixo usamos o mesmo Modifier para 2 textos:</p> <pre><code>private const val loremIpsumText = \"...\"\n\n@Composable\nprivate fun ReaderScreen() {\n    Column(\n        modifier = Modifier\n            .padding(24.dp)\n            .verticalScroll(rememberScrollState())\n    ) {\n        Text(\n            text = \"In\u00edcio do cap\u00edtulo\",\n            color = Color.White,\n            textAlign = TextAlign.Center,\n            modifier = Modifier\n                .fillMaxWidth()\n                .background(Color.Black)\n                .padding(8.dp)\n                .border(\n                    width = 4.dp,\n                    color = Color.White,\n                    shape = RoundedCornerShape(8.dp)\n                )\n                .padding(12.dp)\n        )\n        Text(\n            text = loremIpsumText,\n            modifier = Modifier.padding(vertical = 12.dp)\n        )\n        Text(\n            text = \"Fim do cap\u00edtulo\",\n            color = Color.White,\n            textAlign = TextAlign.Center,\n            modifier = Modifier\n                .fillMaxWidth()\n                .background(Color.Black)\n                .padding(8.dp)\n                .border(\n                    width = 4.dp,\n                    color = Color.White,\n                    shape = RoundedCornerShape(8.dp)\n                )\n                .padding(12.dp)\n        )\n    }\n}\n</code></pre> <p>Ent\u00e3o podemos extrair e reutilizar:</p> <pre><code>private const val loremIpsumText = \"...\"\n\nval reusableModifier = Modifier\n    .fillMaxWidth()\n    .background(Color.Black)\n    .padding(8.dp)\n    .border(\n        width = 4.dp,\n        color = Color.White,\n        shape = RoundedCornerShape(8.dp)\n    )\n    .padding(12.dp)\n\n@Composable\nprivate fun ReaderScreen() {\n    Column(\n        modifier = Modifier\n            .padding(24.dp)\n            .verticalScroll(rememberScrollState())\n    ) {\n        Text(\n            text = \"In\u00edcio do cap\u00edtulo\",\n            color = Color.White,\n            textAlign = TextAlign.Center,\n            modifier = reusableModifier\n        )\n        Text(\n            text = loremIpsumText,\n            modifier = Modifier.padding(vertical = 12.dp)\n        )\n        Text(\n            text = \"Fim do cap\u00edtulo\",\n            color = Color.White,\n            textAlign = TextAlign.Center,\n            modifier = reusableModifier\n        )\n    }\n}\n</code></pre> <p></p> <p>No exemplo de c\u00f3digo acima, o Modifier \u00e9 extra\u00eddo da fun\u00e7\u00e3o Composable. Os modificadores podem estar com ou sem escopo para um Composable. Nesse caso, estamos usando um Modifier sem escopo. Mas \u00e9 importante notar que alguns modificadores s\u00f3 podem ser usados dentro de escopos espec\u00edficos, como voc\u00ea ver\u00e1 em seguida sobre seguran\u00e7a de escopo, o que pode exigir que o modificador seja criado dentro do Composable.</p> <p>Esse tipo de pr\u00e1tica pode ser especialmente ben\u00e9fica quando combinado com lazy layouts, como LazyColumn. Na maioria dos casos, voc\u00ea deseja que toda a quantidade potencialmente significativa de itens tenha exatamente os mesmos modificadores. Veja o exemplo abaixo retirado da documenta\u00e7\u00e3o:</p> <pre><code>val reusableItemModifier = Modifier\n    .padding(bottom = 12.dp)\n    .size(216.dp)\n    .clip(CircleShape)\n\n@Composable\nprivate fun AuthorList(authors: List&lt;Author&gt;) {\n    LazyColumn {\n        items(authors) {\n            AsyncImage(\n                // ...\n                modifier = reusableItemModifier,\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"modifiers/#seguranca-de-escopo-no-compose","title":"Seguran\u00e7a de escopo no Compose","text":"<p>No Compose, h\u00e1 modificadores que s\u00f3 podem ser usados \u200b\u200bquando aplicados a filhos de determinados Composables. O Compose imp\u00f5e isso por meio de escopos personalizados.</p> <p>Por exemplo, se voc\u00ea quiser deixar um filho t\u00e3o grande quanto o Box pai sem afetar o tamanho do Box, use o <code>Modificador.matchParentSize()</code>. Ele s\u00f3 est\u00e1 dispon\u00edvel em um <code>BoxScope</code>. Portanto, ele s\u00f3 pode ser usado em um filho dentro de um dos Box pais.</p> <p>A seguran\u00e7a do escopo evita que voc\u00ea adicione modificadores que n\u00e3o funcionariam em outros Composables e escopos, al\u00e9m de economizar tempo de tentativa e erro. Por exemplo:</p> <pre><code>@Composable\nprivate fun Item() {\n    Box(\n        modifier = Modifier\n            .size(100.dp)\n            .background(Color.Blue)\n    ) {\n        Box(\n            modifier = Modifier\n                .background(Color.Red)\n                // Funciona, pois est\u00e1 em um BoxScope\n                .matchParentSize()\n        )\n    }\n}\n</code></pre> <pre><code>@Composable\nprivate fun Item() {\n    Column(\n        modifier = Modifier\n            .size(100.dp)\n            .background(Color.Blue)\n    ) {\n        Box(\n            modifier = Modifier\n                .background(Color.Red)\n                // N\u00e3o funciona, pois est\u00e1 em um ColumnScope\n                .matchParentSize()\n        )\n    }\n}\n</code></pre>"},{"location":"modifiers/#modifierweight","title":"Modifier.weight()","text":"<p>Voc\u00ea pode definir o tamanho do Composable para ser flex\u00edvel dentro de seu pai usando o <code>Modifier.weight()</code>. Ele est\u00e1 dispon\u00edvel apenas em RowScope e ColumnScope. Veja alguns exemplos de seu uso com diferentes pesos:</p> <pre><code>@Composable\nprivate fun ModifierWeight() {\n    Column(\n        verticalArrangement = Arrangement.Center,\n        modifier = Modifier.fillMaxSize()\n    ) {\n        Row(modifier = Modifier.fillMaxWidth()) {\n            Box(\n                contentAlignment = Alignment.Center,\n                modifier = Modifier\n                    .background(Color.Red)\n                    .height(80.dp)\n                    .weight(1f)\n            ) { Text(text = \"weight(1f)\") }\n\n            Box(\n                contentAlignment = Alignment.Center,\n                modifier = Modifier\n                    .background(Color.Blue)\n                    .height(80.dp)\n                    .weight(1f)\n            ) { Text(text = \"weight(1f)\") }\n        }\n\n        Spacer(Modifier.height(16.dp))\n\n        Row(modifier = Modifier.fillMaxWidth()) {\n            Box(\n                contentAlignment = Alignment.Center,\n                modifier = Modifier\n                    .background(Color.Red)\n                    .height(80.dp)\n                    .weight(2f)\n            ) { Text(text = \"weight(2f)\") }\n\n            Box(\n                contentAlignment = Alignment.Center,\n                modifier = Modifier\n                    .background(Color.Blue)\n                    .height(80.dp)\n                    .weight(1f)\n            ) { Text(text = \"weight(1f)\") }\n        }\n\n        Spacer(Modifier.height(16.dp))\n\n        Row(modifier = Modifier.fillMaxWidth()) {\n            Box(\n                contentAlignment = Alignment.Center,\n                modifier = Modifier\n                    .background(Color.Red)\n                    .height(80.dp)\n                    .weight(1f)\n            ) { Text(text = \"weight(1f)\") }\n\n            Box(\n                contentAlignment = Alignment.Center,\n                modifier = Modifier\n                    .background(Color.Blue)\n                    .size(height = 80.dp, width = 60.dp)\n            ) {\n                Text(\n                    text = \"Sem weight()\",\n                    fontSize = 12.sp,\n                    textAlign = TextAlign.Center\n                )\n            }\n        }\n\n        Spacer(Modifier.height(16.dp))\n\n        Row(modifier = Modifier.fillMaxWidth()) {\n            Box(\n                contentAlignment = Alignment.Center,\n                modifier = Modifier\n                    .background(Color.Red)\n                    .height(80.dp)\n                    .weight(1f)\n            ) { Text(text = \"weight(1f)\") }\n\n            Box(\n                contentAlignment = Alignment.Center,\n                modifier = Modifier\n                    .background(Color.Blue)\n                    .height(80.dp)\n                    .weight(1f)\n            ) { Text(text = \"weight(1f)\") }\n\n            Box(\n                contentAlignment = Alignment.Center,\n                modifier = Modifier\n                    .background(Color.Green)\n                    .height(80.dp)\n                    .weight(1f)\n            ) { Text(text = \"weight(1f)\") }\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"modifiers/#um-parametro-modifier-opcional","title":"Um par\u00e2metro Modifier opcional","text":"<p>Voc\u00ea j\u00e1 deve ter notado que praticamente todo componente no Compose possui um par\u00e2metro Modifier opcional, certo? Isso acontece porque \u00e9 uma boa pr\u00e1tica sempre adicionar um par\u00e2metro Modifier opcional aos Composables, pois como j\u00e1 foi discutido antes, com ele voc\u00ea pode alterar alguns comportamentos do Composable sem muito esfor\u00e7o. Por exemplo, com o Modifier como op\u00e7\u00e3o, o chamador pode usar <code>Modifier.align()</code> para alinhar o componente como desejar, dependendo do layout que est\u00e1 criando.</p> <p>Portanto, quando estiver criando seu componente, \u00e9 recomend\u00e1vel sempre colocar um par\u00e2metro Modifier opcional. \u00c9 importante ser opcional porque o chamador nem sempre ir\u00e1 usar o Modifier. Ele deve ser o primeiro par\u00e2metro opcional. Veja o exemplo abaixo, os par\u00e2metros text e onClick n\u00e3o s\u00e3o opcionais, portanto, ele fica logo abaixo deles:</p> <pre><code>@Composable\nfun MyCustomButton(\n    text: String,\n    onClick: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    colors: MyButtonColors = MyButtonColors.colors()\n)\n</code></pre> <p>EVITE:</p> <pre><code>@Composable\nfun MyCustomButton(\n    text: String,\n    onClick: () -&gt; Unit\n)\n</code></pre> <p>EVITE:</p> <pre><code>@Composable\nfun IconButton(\n    buttonBitmap: ImageBitmap,\n    modifier: Modifier = Modifier,\n    tint: Color = Color.Black\n) {\n    Box(Modifier.padding(16.dp)) {\n        Icon(\n            buttonBitmap,\n            tint = tint,\n            // Modifier deve ser colocado no layout mais externo\n            // e deve ser o primeiro na cadeia. Aqui ele deveria \n            // estar no Box\n            modifier = Modifier.aspectRatio(1f).then(modifier),\n        )\n    }\n}\n</code></pre> <p>EVITE:</p> <pre><code>@Composable\nfun Icon(\n    bitmap: ImageBitmap,\n    // padding(8.dp) ser\u00e1 perdido assim que o chamador definir seu pr\u00f3prio Modifier\n    modifier: Modifier = Modifier.padding(8.dp)\n    tint: Color = Color.Black\n) {\n    Box(modifier) {\n        ...\n    }\n}\n</code></pre> <p>FA\u00c7A:</p> <pre><code>@Composable\nfun IconButton(\n    buttonBitmap: ImageBitmap,\n    modifier: Modifier = Modifier,\n    tint: Color = Color.Black\n) {\n    Box(modifier.padding(16.dp)) {\n        ...\n    }\n}\n</code></pre> <p>EVITE:</p> <pre><code>@Composable\nfun CheckboxRow(\n    checked: Boolean,\n    onCheckedChange: (Boolean) -&gt; Unit,\n    // Modifier destina-se a especificar o comportamento\n    // externo do CheckboxRow nesse caso, n\u00e3o suas subpartes\n    rowModifier: Modifier = Modifier,\n    checkboxModifier: Modifier = Modifier\n)\n</code></pre>"},{"location":"modifiers/#modifier-como-ultimo-argumento","title":"Modifier como \u00faltimo argumento","text":"<p>N\u00e3o \u00e9 nenhuma regra espec\u00edfica, mas como o Modifier costuma ter v\u00e1rios modificadores, \u00e0s vezes \u00e9 interessante coloc\u00e1-lo como \u00faltimo argumento para uma melhor legibilidade. Por exemplo, ao inv\u00e9s disso:</p> <pre><code>@Composable\nprivate fun Item() {\n    Text(\n        text = \"Jetpack Compose\",\n        color = Color.White,\n        modifier = Modifier\n            .background(Color.Black)\n            .padding(4.dp)\n            .clickable {},\n        fontSize = 18.sp,\n        fontFamily = FontFamily.Cursive\n    )\n}\n</code></pre> <p>Voc\u00ea pode fazer isso:</p> <pre><code>@Composable\nprivate fun Item() {\n    Text(\n        text = \"Jetpack Compose\",\n        color = Color.White,\n        fontSize = 18.sp,\n        fontFamily = FontFamily.Cursive,\n        modifier = Modifier\n            .background(Color.Black)\n            .padding(4.dp)\n            .clickable {}\n    )\n}\n</code></pre>"},{"location":"modifiers/#conclusao","title":"Conclus\u00e3o","text":"<p>Voc\u00ea pode ler mais sobre Modifiers na documenta\u00e7\u00e3o e nos artigos auxiliares. Como p\u00f4de ver, eles s\u00e3o bem importantes e sempre utilizados no Compose. H\u00e1 uma vasta lista de Modifiers, essa se\u00e7\u00e3o focou mais na teoria do que pr\u00e1tica sobre Modifiers espec\u00edficos. Ao longo do tempo, voc\u00ea aprender\u00e1 e usar\u00e1 v\u00e1rios deles.</p>"},{"location":"modifiers/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Modifiers (documenta\u00e7\u00e3o)</li> <li>Modifier parameter (guidelines)</li> <li>What can Advanced / Lesser Known Modifiers do for your UI? \u2014 A Comprehensive Exploration in Jetpack Compose (artigo)</li> </ul>"},{"location":"previews/","title":"Previews: Visualize seus layouts","text":"<p>Jetpack Compose fornece um meio de visualizar seus layouts e componentes atrav\u00e9s de Previews. Previews nada mais s\u00e3o do que fun\u00e7\u00f5es Composable com mais uma anota\u00e7\u00e3o: <code>@Preview</code>. Ao anotar a fun\u00e7\u00e3o com <code>@Preview</code>, o Android Studio carregar\u00e1 uma visualiza\u00e7\u00e3o desse Composable. Veja o exemplo:</p> <p></p> <p>Normalmente, voc\u00ea adiciona o conte\u00fado da Preview com o tema do seu app, que \u00e9 uma fun\u00e7\u00e3o Composable (normalmente) localizada no arquivo Theme.kt, onde s\u00e3o definidas as configura\u00e7\u00f5es do tema, como cores, shapes, typography etc. Como geralmente voc\u00ea define as cores e outros atributos dos componentes usando o tema do app, como um Text() com <code>color = MaterialTheme.colorScheme.onPrimary</code> (pode mudar dependendo do light e dark mode) ao inv\u00e9s de <code>Color.White</code> (valor literal), por exemplo, voc\u00ea se beneficia de algumas propriedades da Preview que v\u00e3o ser abordadas em seguida.</p> <p>Nesse caso, no exemplo da imagem acima, ao inv\u00e9s disso:</p> <pre><code>@Preview\n@Composable\nprivate fun Preview() { \n    Item()\n}\n</code></pre> <p>Teremos isso:</p> <pre><code>@Preview\n@Composable\nprivate fun Preview() {\n    MyAppTheme {\n        Item()\n    }\n}\n</code></pre>"},{"location":"previews/#propriedades","title":"Propriedades","text":"<p>Preview possui v\u00e1rias propriedades que voc\u00ea pode definir para alterar o comportamento da visualiza\u00e7\u00e3o. Veja alguns exemplos a seguir.</p>"},{"location":"previews/#mostrando-ui-do-sistema","title":"Mostrando UI do sistema","text":"<p><code>@Preview(showSystemUi = true)</code></p> <p></p>"},{"location":"previews/#tema-light-e-dark","title":"Tema light e dark","text":"<p>Para ver uma real diferen\u00e7a, teremos um exemplo usando cores do tema, como <code>MaterialTheme.colorScheme.surface</code> e <code>MaterialTheme.colorScheme.onSurface</code>.</p> <p><pre><code>@Composable\nprivate fun Profile() {\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .width(250.dp)\n            .background(MaterialTheme.colorScheme.surface)\n    ) {\n        Icon(\n            painter = painterResource(id = R.drawable.baseline_person_24),\n            contentDescription = \"Profile image\",\n            tint = MaterialTheme.colorScheme.onSurface,\n            modifier = Modifier\n                .size(50.dp)\n        )\n        Text(\n            text = \"John\",\n            color = MaterialTheme.colorScheme.onSurface\n        )\n    }\n}\n</code></pre> Podemos usar v\u00e1rias @Preview numa mesma fun\u00e7\u00e3o, dessa forma carregar\u00e1 m\u00faltiplas previews do nosso conte\u00fado com as modifica\u00e7\u00f5es que adicionarmos. Estamos modificando a propriedade name para a legibilidade no Android Studio e a uiMode de uma das Previews para usar o dark mode do tema.</p> <pre><code>@Preview(name = \"Light theme\")\n@Preview(name = \"Dark theme\", uiMode = Configuration.UI_MODE_NIGHT_YES)\n@Composable\nprivate fun Preview() {\n    MyAppTheme {\n        Profile()\n    }\n}\n</code></pre> <p></p>"},{"location":"previews/#aparencia-e-resolucao-da-preview-com-system-ui","title":"Apar\u00eancia e resolu\u00e7\u00e3o da Preview com System UI","text":"<p>Podemos mudar a apar\u00eancia da Preview para um dos dispositivos inclu\u00eddos em Devices, dessa forma, mudamos tamb\u00e9m a resolu\u00e7\u00e3o da mesma ao usarmos junto de showSystemUi = true. Isso \u00e9 bastante \u00fatil para ver como seu layout se comporta em diferentes tamanhos de tela.</p> <pre><code>@Preview(\n    name = \"Devices.PIXEL_3A_XL\",\n    uiMode = Configuration.UI_MODE_NIGHT_YES,\n    showSystemUi = true,\n    device = Devices.PIXEL_3A_XL\n)\n@Preview(\n    name = \"Devices.NEXUS_7\",\n    uiMode = Configuration.UI_MODE_NIGHT_YES,\n    showSystemUi = true,\n    device = Devices.NEXUS_7\n)\n@Composable\nprivate fun Preview() {\n    MyAppTheme {\n        Profile()\n    }\n}\n</code></pre> <p></p>"},{"location":"previews/#outras-propriedades","title":"Outras propriedades","text":"<p>H\u00e1 algumas outras propriedades que voc\u00ea pode utilizar para alterar sua Preview, sendo algumas delas:</p> <ul> <li>showBackground e backgroundColor.</li> <li>locale, que voc\u00ea pode utilizar para carregar recursos alternativos com base no locale passado, como valores de strings.xml.</li> </ul>"},{"location":"previews/#anotacoes-preview-personalizadas","title":"Anota\u00e7\u00f5es Preview personalizadas","text":"<p>Voc\u00ea pode criar anota\u00e7\u00f5es personalizadas para fornecer multipreviews de uma forma mais facilitada. Por exemplo, ao inv\u00e9s de definirmos manualmente em cada preview do nosso projeto algo assim:</p> <pre><code>@Preview(name = \"Light theme\")\n@Preview(name = \"Dark theme\", uiMode = Configuration.UI_MODE_NIGHT_YES)\n@Composable\nprivate fun Preview() { ... }\n</code></pre> <p>Podemos criar uma anota\u00e7\u00e3o personalizada:</p> <pre><code>@Preview(name = \"Light theme\")\n@Preview(name = \"Dark theme\", uiMode = Configuration.UI_MODE_NIGHT_YES)\nannotation class PreviewLightDark\n</code></pre> <p>Dessa forma podemos utilizar PreviewLightDark em nossas Previews facilmente:</p> <pre><code>@PreviewLightDark\n@Composable\nprivate fun Preview() { ... }\n</code></pre> <ul> <li>A partir da vers\u00e3o 1.6.0 do Jetpack Compose (Compose BOM 2024.01.00, mais especificamente o androidx.compose.ui:ui-tooling-preview:1.6.0), foram introduzidas diversas novas anota\u00e7\u00f5es focadas em MultiPreview, como @PreviewScreenSizes, @PreviewFontScales, @PreviewLightDark e @PreviewDynamicColors. Voc\u00ea pode utiliz\u00e1-las para evitar criar anota\u00e7\u00f5es manualmente para esses casos mais comuns.</li> </ul>"},{"location":"previews/#outros-pontos-importantes","title":"Outros pontos importantes","text":"<p>Voc\u00ea tamb\u00e9m pode executar sua Preview como se fosse uma tela normal do seu app, num dispositivo f\u00edsico ou emulador. Basta tocar em Run Preview. \u00c9 bastante \u00fatil se quiser ver uma tela inteira sem a necessidade de executar todo o app. A op\u00e7\u00e3o aparece tanto ao lado do nome da fun\u00e7\u00e3o Preview no c\u00f3digo quanto no design. </p> <p>Al\u00e9m dos modos de lista e grade, que exibem todas as Previews de uma vez, uma outra fun\u00e7\u00e3o \u00fatil \u00e9 o modo de galeria (Gallery), onde \u00e9 poss\u00edvel visualizar uma Preview por vez, assim economizando recursos de renderiza\u00e7\u00e3o. \u00c9 recomend\u00e1vel utiliz\u00e1-lo quando estiver focando em apenas uma Preview. Voc\u00ea pode alterar facilmente entre os modos na guia de design.</p> <p>Tamb\u00e9m h\u00e1 uma op\u00e7\u00e3o para configurar rapidamente sua Preview com as propriedades que foram abordadas nessa se\u00e7\u00e3o, como pode ver no \u00edcone de configura\u00e7\u00e3o na imagem abaixo.</p> <p></p> <p>Tamb\u00e9m \u00e9 poss\u00edvel interagir com as Previews no modo interativo do Android Studio. Esse recurso \u00e9 muito \u00fatil para visualizar alguns comportamentos simples, como mudan\u00e7as de estados ap\u00f3s um clique, anima\u00e7\u00f5es etc. Veja o exemplo abaixo na imagem retirada da documenta\u00e7\u00e3o.</p> <p></p>"},{"location":"previews/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Previews (documenta\u00e7\u00e3o)</li> <li>Animation Preview (documenta\u00e7\u00e3o)</li> </ul>"},{"location":"state/","title":"Estado no Compose","text":"<p>J\u00e1 falamos um pouco sobre estados em se\u00e7\u00f5es anteriores, mas nessa vamos ver de uma forma mais detalhada como isso funciona no Jetpack Compose. Um estado \u00e9 qualquer valor que pode mudar com o tempo. Esta \u00e9 uma defini\u00e7\u00e3o muito ampla e abrange tudo, desde um banco de dados Room at\u00e9 uma vari\u00e1vel em uma classe.</p>"},{"location":"state/#estado-composicao-e-recomposicao","title":"Estado, composi\u00e7\u00e3o e recomposi\u00e7\u00e3o","text":"<p>Compose \u00e9 declarativo e, como tal, a \u00fanica maneira de atualizar nossa interface \u00e9 chamando a mesma fun\u00e7\u00e3o Composable com novos argumentos. Mas n\u00f3s n\u00e3o chamamos a fun\u00e7\u00e3o Composable manualmente, \u00e9 claro, \u00e9 o Compose que gerencia isso. Toda vez que um estado \u00e9 alterado, o Compose aciona a recomposi\u00e7\u00e3o, atualizando ent\u00e3o a interface.</p> <p>Ao ler o texto acima, pode-se pensar que podemos usar uma vari\u00e1vel qualquer como estado e quando alterada, o Compose acionar\u00e1 a recomposi\u00e7\u00e3o. Mas n\u00e3o \u00e9 assim que funciona. Vamos a um exemplo simples:</p> <pre><code>@Composable\nprivate fun State() {\n    var name = \"John\"\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\n            text = name,\n            fontSize = 22.sp\n        )\n        Button(onClick = { name = \"Mary\" }) {\n            Text(\"Mudar nome\")\n        }\n    }\n}\n</code></pre> <p>Nesse c\u00f3digo, name \u00e9 o estado e est\u00e1 sendo usado por Text(). Na teoria, ao clicar no bot\u00e3o para mudar o nome de \"John\" para \"Mary\", name seria alterada e Text() seria atualizado, certo? Por\u00e9m, isso n\u00e3o vai acontecer. Ao tocar no bot\u00e3o, name ser\u00e1 alterada, mas nosso Composable Text() n\u00e3o ser\u00e1 atualizado pois o Compose n\u00e3o sabe que name \u00e9 um estado e que deve acionar a recomposi\u00e7\u00e3o quando ela for atualizada. Precisamos fazer apenas uma pequena modifica\u00e7\u00e3o no c\u00f3digo para ele funcionar como queremos:</p> <p><code>var name by remember { mutableStateOf(\"John\") }</code></p>"},{"location":"state/#remember-e-mutablestateof","title":"remember e mutableStateOf","text":"<p>Fizemos duas pequenas altera\u00e7\u00f5es no c\u00f3digo anterior: usamos remember { } e mutableStateOf(). Um valor calculado com remember \u00e9 armazenado na composi\u00e7\u00e3o durante a composi\u00e7\u00e3o inicial e o valor armazenado \u00e9 retornado durante a recomposi\u00e7\u00e3o. J\u00e1 mutableStateOf() cria um MutableState, que \u00e9 um tipo observ\u00e1vel integrado ao Compose runtime. Como argumento, mutableStateOf() espera um valor padr\u00e3o inicial, que no nosso caso \u00e9 \"John\". <p>Como visto na documenta\u00e7\u00e3o, a recomposi\u00e7\u00e3o pode acontecer com bastante frequ\u00eancia.</p> <p>Em resumo, remember serve para evitar que o estado seja perdido durante as recomposi\u00e7\u00f5es, j\u00e1 o mutableStateOf() serve para dizer ao Compose para observar as altera\u00e7\u00f5es naquele valor.</p> <p>Existem tr\u00eas maneiras de declarar um objeto MutableState em um Composable:</p> <ul> <li><code>val mutableState = remember { mutableStateOf(default) }</code></li> <li><code>var value by remember { mutableStateOf(default) }</code></li> <li><code>val (value, setValue) = remember { mutableStateOf(default) }</code></li> </ul> <p>Normalmente, se utiliza muito mais a segunda op\u00e7\u00e3o, com by. Ao utilizar a primeira op\u00e7\u00e3o voc\u00ea precisaria sempre chamar o .value para obter o valor, o que n\u00e3o \u00e9 muito o desejado.</p> <p>Utilizar by exige as seguintes importa\u00e7\u00f5es:</p> <pre><code>import androidx.compose.runtime.getValue\nimport androidx.compose.runtime.setValue\n</code></pre>"},{"location":"state/#usando-remembersaveable","title":"Usando rememberSaveable","text":"<p>Os valores salvos com remember s\u00e3o perdidos em altera\u00e7\u00f5es de configura\u00e7\u00e3o, como uma rota\u00e7\u00e3o de tela. Para isso existe a op\u00e7\u00e3o rememberSaveable, que salva automaticamente qualquer valor que possa ser salvo em um Bundle, como Strings e tipos primitivos.</p>"},{"location":"state/#remember-sem-mutablestate","title":"remember sem mutableState","text":"<p>Apesar de ser usado com frequ\u00eancia em conjunto com o mutableState, a fun\u00e7\u00e3o do remember n\u00e3o \u00e9 apenas guardar um valor observ\u00e1vel MutableState. Voc\u00ea tamb\u00e9m pode usar remember para armazenar qualquer objeto ou resultado de uma opera\u00e7\u00e3o que seja caro para inicializar ou calcular no Composable. Talvez voc\u00ea n\u00e3o queira repetir esse c\u00e1lculo em cada recomposi\u00e7\u00e3o. Um exemplo \u00e9 a cria\u00e7\u00e3o do objeto ShaderBrush abaixo, que \u00e9 uma opera\u00e7\u00e3o cara:</p> <pre><code>val brush = remember {\n    ShaderBrush(\n        BitmapShader(\n            ImageBitmap.imageResource(res, avatarRes).asAndroidBitmap(),\n            Shader.TileMode.REPEAT,\n            Shader.TileMode.REPEAT\n        )\n    )\n}\n</code></pre>"},{"location":"state/#remember-com-chaves-keys","title":"remember com chaves (keys)","text":"<p>Tamb\u00e9m \u00e9 poss\u00edvel passar alguns argumentos para remember, nomeados como keys (chaves). Voc\u00ea pode usar um n\u00famero vari\u00e1vel de keys, ou at\u00e9 mesmo nenhuma, como j\u00e1 fizemos acima. Quando o valor de uma das keys muda, o c\u00f3digo do remember \u00e9 reexecutado para obter o novo valor. Vamos ver um exemplo pr\u00e1tico disso.</p> <p>Temos a fun\u00e7\u00e3o abaixo para destacar em negrito um texto de uma String que esteja entre <code>&lt;b&gt;</code> e <code>&lt;/b&gt;</code> (esse parser n\u00e3o funciona em textos muito complexos e serve apenas de exemplo). Adicionei um <code>Log.d()</code> para exibir posteriormente quantas vezes essa fun\u00e7\u00e3o \u00e9 chamada.</p> <pre><code>private fun createAnnotatedString(text: String): AnnotatedString {\n    Log.d(\"Caption\", \"createAnnotatedString() chamada\")\n    val parts = text.split(\"&lt;b&gt;\", \"&lt;/b&gt;\")\n    return buildAnnotatedString {\n        var bold = false\n        for (part in parts) {\n            if (bold) {\n                withStyle(\n                    style = SpanStyle(\n                        color = Color.Red,\n                        fontWeight = FontWeight.Bold\n                    )\n                ) { append(part) }\n            } else {\n                append(part)\n            }\n            bold = !bold\n        }\n    }\n}\n</code></pre> <p>Ent\u00e3o, temos a Composable Caption() abaixo que faz uso dessa createAnnotatedString(), aplicando o destaque a um Text(), j\u00e1 que esse componente tamb\u00e9m tem uma op\u00e7\u00e3o para AnnotatedString, que \u00e9 o que queremos.</p> <pre><code>@Composable\nprivate fun Caption() {\n    var caption by remember { mutableStateOf(\"Jetpack &lt;b&gt;Compose&lt;/b&gt; Journey\") }\n    var backgroundColor by remember { mutableStateOf(Color.White) }\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .fillMaxSize()\n            .background(backgroundColor)\n            .clickable {\n                backgroundColor = if (backgroundColor == Color.White) Color.LightGray else Color.White\n            }\n            .padding(24.dp)\n    ) {\n        Text(\n            text = createAnnotatedString(text = caption),\n            fontSize = 18.sp,\n            modifier = Modifier\n                .padding(12.dp)\n        )\n        Spacer(Modifier.height(18.dp))\n        OutlinedTextField(\n            value = caption,\n            onValueChange = { newCaption -&gt;\n                caption = newCaption\n            },\n            label = { Text(text = \"Legenda\") },\n            shape = RoundedCornerShape(16.dp),\n            modifier = Modifier\n                .fillMaxWidth()\n        )\n    }\n}\n</code></pre> <p>Veja o resultado disso:</p> <p></p> <p>Como pode ver, a fun\u00e7\u00e3o createAnnotatedString() est\u00e1 sendo chamada mais do que deveria e isso obviamente \u00e9 por conta da recomposi\u00e7\u00e3o e a forma como a estamos usando. N\u00e3o queremos que createAnnotatedString() seja chamada quando a cor de fundo da Column mudar ou outra recomposi\u00e7\u00e3o sem correla\u00e7\u00e3o acontecer. Para resolver isso, podemos utilizar o remember com uma key. Usaremos caption como key, ent\u00e3o s\u00f3 iremos obter uma AnnotatedString na primeira composi\u00e7\u00e3o e quando de fato o texto de caption mudar.</p> <pre><code>@Composable\nprivate fun Caption() {\n    var caption by remember { mutableStateOf(\"Jetpack &lt;b&gt;Compose&lt;/b&gt; Journey\") }\n    var backgroundColor by remember { mutableStateOf(Color.White) }\n    val captionAnnotatedString = remember(key1 = caption) {\n        createAnnotatedString(text = caption)\n    }\n    Column(\n       ...\n    ) {\n        Text(\n            text = captionAnnotatedString,\n            fontSize = 18.sp,\n            modifier = Modifier\n                .padding(12.dp)\n        )\n        ...\n    }\n}\n</code></pre> <p></p>"},{"location":"state/#outros-tipos-de-estados","title":"Outros tipos de estados","text":"<p>O Compose suporta outros tipos observ\u00e1veis, contanto que eles sejam convertidos em um State. Compose vem com fun\u00e7\u00f5es para criar State a partir de tipos observ\u00e1veis \u200b\u200bcomuns usados \u200b\u200bem apps Android. Para usar essas integra\u00e7\u00f5es, \u00e9 necess\u00e1rio adicionar uma depend\u00eancia, dependendo do tipo. Voc\u00ea pode ler mais na documenta\u00e7\u00e3o sobre tipos como LiveData e RxJava e suas respectivas depend\u00eancias. Vou mencionar apenas um exemplo com Flow, que atualmente \u00e9 o caminho mais recomendado no Android. \u00c9 necess\u00e1rio adicionar a depend\u00eancia: <pre><code>implementation(\"androidx.lifecycle:lifecycle-runtime-compose:$version\")\n</code></pre> <p>Ap\u00f3s isso, podemos usar collectAsStateWithLifecycle() para coletar um Flow consciente do ciclo de vida, permitindo que o app economize recursos desnecess\u00e1rios, que \u00e9 a maneira recomendada para apps Android.</p>"},{"location":"state/#stateful-versus-stateless","title":"Stateful versus stateless","text":"<p>Basicamente, um Composable com estado (stateful) cria e mant\u00e9m o estado internamente, j\u00e1 um Composable sem estado (stateless) n\u00e3o cont\u00e9m nenhum estado. O c\u00f3digo que criamos de exemplo no in\u00edcio \u00e9 stateful, pois name foi criada e \u00e9 controlada internamente pelo pr\u00f3pria Composable State().</p> <p>Uma forma de tornar um Composable stateless \u00e9 usando eleva\u00e7\u00e3o de estado (state hoisting), que veremos logo a seguir. Veja dois pequenos exemplos de um Composable com e sem estado.</p> <pre><code>/**\n * Stateful, pois text est\u00e1 sendo controlado internamente pela MyTextField().\n * Dificulta a reutiliza\u00e7\u00e3o do componente usando outros valores.\n */\n@Composable\nfun MyTextField(modifier: Modifier = Modifier) {\n    var text by remember { mutableStateOf(\"\") }\n    OutlinedTextField(\n        value = text,\n        onValueChange = { updatedText -&gt;\n            text = updatedText\n        },\n        label = { Text(text = \"Texto\") },\n        shape = CircleShape,\n        modifier = modifier\n    )\n}\n</code></pre> <pre><code>/**\n * Stateless, pois elevamos o estado principal do MyTextField().\n * Facilita a reutiliza\u00e7\u00e3o, pois o estado \u00e9 elevado e gerenciado externamente.\n */\n@Composable\nfun MyTextField(\n    text: String,\n    onTextChange: (String) -&gt; Unit,\n    modifier: Modifier = Modifier\n) {\n    OutlinedTextField(\n        value = text,\n        onValueChange = onTextChange,\n        label = { Text(text = \"Texto\") },\n        shape = CircleShape,\n        modifier = modifier\n    )\n}\n</code></pre> <ul> <li>Nem sempre \u00e9 necess\u00e1rio elevar o estado. \u00c0s vezes, o componente pode lidar com o estado internamente sem passar essa responsabilidade para o chamador. Por\u00e9m, como pode ver no exemplo acima, manter o componente com estado dificulta a reutiliza\u00e7\u00e3o.</li> </ul>"},{"location":"state/#elevacao-de-estado-state-hoisting","title":"Eleva\u00e7\u00e3o de estado (state hoisting)","text":"<p>A eleva\u00e7\u00e3o de estado no Compose \u00e9 um padr\u00e3o de movimenta\u00e7\u00e3o de estado para o chamador do Composable para torn\u00e1-lo sem estado, como vimos no exemplo acima. O padr\u00e3o geral para eleva\u00e7\u00e3o de estado no Compose \u00e9 substituir a vari\u00e1vel de estado por dois par\u00e2metros:</p> <ul> <li><code>value: T</code>: O valor atual a ser exibido.</li> <li><code>onValueChange: (T) -&gt; Unit</code>: Um evento que solicita a altera\u00e7\u00e3o do valor, onde T \u00e9 o novo valor.</li> </ul> <p>Voc\u00ea j\u00e1 viu isso em diversos componentes na se\u00e7\u00e3o sobre componentes, como o TextField. </p> <p>Vale lembrar que voc\u00ea n\u00e3o est\u00e1 limitado a onValueChange. Se eventos mais espec\u00edficos forem apropriados para o Composable, voc\u00ea dever\u00e1 defini-los usando lambdas.</p> <p>Voc\u00ea pode ler mais sobre state hoisting na documenta\u00e7\u00e3o. Al\u00e9m do pequeno exemplo que j\u00e1 vimos, veja tamb\u00e9m um pequeno exemplo retirado da pr\u00f3pria documenta\u00e7\u00e3o:</p> <pre><code>@Composable\nfun HelloScreen() {\n    var name by rememberSaveable { mutableStateOf(\"\") }\n\n    HelloContent(name = name, onNameChange = { name = it })\n}\n\n@Composable\nfun HelloContent(name: String, onNameChange: (String) -&gt; Unit) {\n    Column(modifier = Modifier.padding(16.dp)) {\n        Text(\n            text = \"Hello, $name\",\n            modifier = Modifier.padding(bottom = 8.dp),\n            style = MaterialTheme.typography.bodyMedium\n        )\n        OutlinedTextField(\n            value = name, \n            onValueChange = onNameChange, \n            label = { Text(\"Name\") }\n        )\n    }\n}\n</code></pre> <p></p>"},{"location":"state/#detentores-de-estado-state-holders","title":"Detentores de estado (state holders)","text":"<p>Para n\u00e3o tornar essa se\u00e7\u00e3o mais longa e como esse conte\u00fado n\u00e3o est\u00e1 sendo feito para substituir a documenta\u00e7\u00e3o oficial, vou mencionar apenas mais um tema importante sobre esse t\u00f3pico: state holders. Leia mais sobre eles na documenta\u00e7\u00e3o. Em resumo, ao inv\u00e9s de gerenciar o estado internamento nos Composables (com v\u00e1rias vari\u00e1veis com remember() e mutableState()), voc\u00ea delega a fun\u00e7\u00e3o de gerenciar os estados a outras classes, que nesse caso se tornam as ditas state holders.</p> <p>Voc\u00ea ver\u00e1 um exemplo simples de um ViewModel servindo de state holder na se\u00e7\u00e3o sobre telas, ViewModels e navega\u00e7\u00e3o.</p>"},{"location":"state/#conclusao","title":"Conclus\u00e3o","text":"<p>Essa \u00e9 uma parte muito importante e fundamental no Compose, ent\u00e3o \u00e9 recomend\u00e1vel que voc\u00ea leia mais sobre esses t\u00f3picos abordados na documenta\u00e7\u00e3o oficial, que cont\u00e9m diversos exemplos e outros casos.</p>"},{"location":"state/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>State and Jetpack Compose (documenta\u00e7\u00e3o)</li> <li>Where to hoist state (documenta\u00e7\u00e3o)</li> <li>Save UI state in Compose (documenta\u00e7\u00e3o)</li> </ul>"},{"location":"testing/","title":"Testes de interface","text":"<p>Testes s\u00e3o essenciais em qualquer app. Essa se\u00e7\u00e3o far\u00e1 uma pequena introdu\u00e7\u00e3o aos testes de interface com Jetpack Compose. \u00c9 importante ressaltar que n\u00e3o teremos nada relacionado a testes unit\u00e1rios que envolvam l\u00f3gicas de neg\u00f3cios, ViewModels ou coisas do tipo. Essa se\u00e7\u00e3o tamb\u00e9m n\u00e3o \u00e9 sobre o que testar, pois cada app e UI t\u00eam suas particularidades.</p>"},{"location":"testing/#local-dos-testes","title":"Local dos testes","text":"<p>Como testes de interface do Compose s\u00e3o testes instrumentados, eles ficam localizados na pasta androidTest. Tamb\u00e9m por esse motivo, os testes dependem de um emulador ou dispositivo f\u00edsico para rodarem.</p> <p></p>"},{"location":"testing/#semantica","title":"Sem\u00e2ntica","text":"<p>Os testes de UI no Compose usam sem\u00e2ntica para interagir com a hierarquia da UI. A sem\u00e2ntica, como o nome indica, d\u00e1 significado a uma parte da UI. Uma \"parte da UI\" (ou elemento) pode significar qualquer coisa, desde um \u00fanico Composable at\u00e9 uma tela inteira. A \u00e1rvore sem\u00e2ntica \u00e9 gerada junto com a hierarquia da UI e a descreve. A estrutura sem\u00e2ntica \u00e9 usada principalmente para acessibilidade, portanto os testes aproveitam as informa\u00e7\u00f5es expostas pela sem\u00e2ntica sobre a hierarquia da UI. Voc\u00ea decide o que e quanto expor.</p> <p></p> <p>A partir de um teste, podemos usar <code>onRoot().printToLog()</code> para mostrar a \u00e1rvore sem\u00e2ntica:</p> <p><code>composeTestRule.onRoot().printToLog(\"TAG\")</code></p> <p>Por exemplo, temos o seguinte c\u00f3digo:</p> <pre><code>MyButton {\n    Text(\"Hello\")\n    Text(\"World\")\n}\n</code></pre> <p>Esse c\u00f3digo imprime a seguinte sa\u00edda:</p> <pre><code>Node #1 at (...)px\n |-Node #2 at (...)px\n   Role = 'Button'\n   Text = '[Hello, World]'\n   Actions = [OnClick, GetTextLayoutResult]\n   MergeDescendants = 'true'\n</code></pre> <p>Veja que os 2 textos foram mesclados. Alguns n\u00f3s mesclam as informa\u00e7\u00f5es sem\u00e2nticas de seus filhos. Por exemplo, um bot\u00e3o com dois elementos de texto mescla seus r\u00f3tulos, como vimos acima. Se voc\u00ea precisar corresponder a um n\u00f3 do que seria a \u00e1rvore n\u00e3o mesclada, poder\u00e1 definir <code>useUnmergedTree</code> como true no <code>onNode</code> (ou suas varia\u00e7\u00f5es). Por exemplo:</p> <pre><code>composeTestRule\n    .onNodeWithText(text = \"Texto\", useUnmergedTree = true)\n    .assertIsNotEnabled()\n</code></pre> <p>Imprimir a \u00e1rvore sem\u00e2ntica do c\u00f3digo anterior com <code>composeTestRule.onRoot(useUnmergedTree = true).printToLog(\"TAG\")</code> geraria a seguinte sa\u00edda:</p> <pre><code>Node #1 at (...)px\n |-Node #2 at (...)px\n   OnClick = '...'\n   MergeDescendants = 'true'\n    |-Node #3 at (...)px\n    | Text = '[Hello]'\n    |-Node #5 at (...)px\n      Text = '[World]'\n</code></pre>"},{"location":"testing/#dependencias-de-teste","title":"Depend\u00eancias de teste","text":"<p>Para essa se\u00e7\u00e3o, vamos precisar das seguintes depend\u00eancias no build.gradle (app):</p> <pre><code>// Regras de teste e depend\u00eancias transitivas\nandroidTestImplementation(\"androidx.compose.ui:ui-test-junit4\")\n// Necess\u00e1ria para usar createAndroidComposeRule(), mas n\u00e3o para createComposeRule()\ndebugImplementation(\"androidx.compose.ui:ui-test-manifest\")\n// Testes de navega\u00e7\u00e3o\nandroidTestImplementation(\"androidx.navigation:navigation-testing:$navigationVersion\")\n</code></pre> <p>As duas primeiras geralmente v\u00eam inclu\u00eddas ao criar um novo projeto Compose, mas a de navega\u00e7\u00e3o precisa ser inclu\u00edda manualmente. Ela ser\u00e1 necess\u00e1ria para fazer alguns testes de navega\u00e7\u00e3o posteriormente.</p>"},{"location":"testing/#apis-de-teste","title":"APIs de teste","text":"<p>Existem tr\u00eas maneiras principais de interagir com os elementos:</p> <ul> <li>Localizadores permitem selecionar um ou v\u00e1rios elementos (ou n\u00f3s na \u00e1rvore sem\u00e2ntica) para fazer afirma\u00e7\u00f5es ou executar a\u00e7\u00f5es sobre eles.</li> <li>Asser\u00e7\u00f5es s\u00e3o usadas para verificar se os elementos existem ou possuem determinados atributos.</li> <li>A\u00e7\u00f5es injetam eventos simulados do usu\u00e1rio nos elementos, como cliques ou outros gestos.</li> </ul> <p>Abaixo n\u00f3s temos uma imagem retirada da documenta\u00e7\u00e3o que demonstra bem as op\u00e7\u00f5es acima:</p> <p></p>"},{"location":"testing/#estrutura-basica-de-um-teste","title":"Estrutura b\u00e1sica de um teste","text":"<p>Abaixo n\u00f3s temos um c\u00f3digo com uma estrutura b\u00e1sica de teste.</p> <pre><code>class MyComposeTest {\n\n    @get:Rule\n    val composeTestRule = createComposeRule()\n\n    @Test\n    fun myTest() {\n        composeTestRule.setContent {\n            MyAppTheme {\n                HomeScreen(\n                    uiState = fakeUiState,\n                    // ...\n                )\n            }\n        }\n\n        composeTestRule.onNodeWithText(\"Continuar\").performClick()\n\n        composeTestRule.onNodeWithText(\"Bem-vindo\").assertIsDisplayed()\n    }\n}\n</code></pre> <p>composeTestRule.setContent(composable: @Composable () -&gt; Unit) nos fornece um escopo onde podemos chamar fun\u00e7\u00f5es Composable, onde inserimos a fun\u00e7\u00e3o Composable que vamos testar. No entanto, ele s\u00f3 pode ser usado uma vez em cada fun\u00e7\u00e3o de teste. N\u00e3o podemos definir 2 conte\u00fados com composeTestRule.setContent() por teste.</p> <p>No c\u00f3digo acima, temos um teste b\u00e1sico onde o texto \"Continuar\" \u00e9 buscado no Composable da HomeScreen e um clique nele \u00e9 simulado. Ap\u00f3s isso, espera-se que um texto \"Bem-vindo\" seja exibido na tela. Lembrando que MyAppTheme n\u00e3o seria obrigat\u00f3rio nesse contexto de teste.</p>"},{"location":"testing/#modifiersemantics-e-modifiertesttag","title":"Modifier.semantics() e Modifier.testTag()","text":"<p>Normalmente, para encontrar um componente, voc\u00ea pode utilizar localizadores como onNodeWithText() ou onNodeWithContentDescription(), por exemplo, mas \u00e0s vezes o componente/Composable que voc\u00ea est\u00e1 tentando encontrar n\u00e3o possui um elemento como text ou contentDescription na \u00e1rvore sem\u00e2ntica. Existe o <code>Modifier.semantics { contentDescription = \"Descri\u00e7\u00e3o\" }</code> que pode ser usado para fins de acessibilidade e tamb\u00e9m de testes, pois ele cria um contentDescription e podemos utilizar onNodeWithContentDescription() para localizar.</p> <p>Uma outra forma seria utilizar Modifier.testTag(\"TAG\") no Composable em quest\u00e3o e usar onNodeWithTag() no teste. Diferente do <code>Modifier.semantics()</code>, esse Modifier \u00e9 \u00fatil apenas para fins de testes, o que pode poluir seu c\u00f3digo de produ\u00e7\u00e3o se usado em exagero e quando n\u00e3o necess\u00e1rio.</p>"},{"location":"testing/#combinacoes-de-condicoes","title":"Combina\u00e7\u00f5es de condi\u00e7\u00f5es","text":"<p>Tamb\u00e9m podemos fazer algumas combina\u00e7\u00f5es para garantir o que queremos. Para isso podemos usar a forma <code>composeTestRule.onNode()</code> (ou onAllNodes()). Por exemplo, temos uma tela com um bot\u00e3o de ajuda, mas essa tela tem um Button() com um texto \"Ajuda\" e tamb\u00e9m um Text() com \"Ajuda\" em outra parte. Escrevemos o seguinte teste:</p> <p><code>composeTestRule.onNodeWithText(\"Ajuda\").performClick()</code></p> <p>Ele falharia com uma mensagem de erro do tipo \"Expected exactly '1' node but found '2' nodes that satisfy...\". Para garantir a asser\u00e7\u00e3o, poder\u00edamos usar a combina\u00e7\u00e3o abaixo:</p> <pre><code>composeTestRule\n    .onNode(hasText(\"Ajuda\") and hasClickAction())\n    .performClick()\n</code></pre> <p>Dessa forma, apenas o elemento que cont\u00e9m o texto \"Ajuda\" e possui uma a\u00e7\u00e3o de clique, ou seja, o Button(), ser\u00e1 encontrado.</p>"},{"location":"testing/#testando-o-app-de-rastreio-de-encomendas","title":"Testando o app de rastreio de encomendas","text":"<p>Para essa se\u00e7\u00e3o, n\u00f3s usaremos o app que criamos na se\u00e7\u00e3o anterior sobre telas, ViewModels e navega\u00e7\u00e3o. Como j\u00e1 fizemos a estrutura b\u00e1sica principal do app, \u00e9 um bom ponto de partida. N\u00f3s testaremos a HomeScreen e tamb\u00e9m a navega\u00e7\u00e3o do app, isto \u00e9, o AppNavHost.</p>"},{"location":"testing/#testando-a-homescreen","title":"Testando a HomeScreen","text":"<p>Como a HomeScreen n\u00e3o usa strings literais, mas strings do arquivo strings.xml, \u00e9 necess\u00e1rio utilizar <code>createAndroidComposeRule&lt;Activity&gt;()</code> para ser capaz de obter strings de recursos. Vamos criar o primeiro teste b\u00e1sico que apenas testa se todos os dados est\u00e3o sendo exibidos, inclusive os inseridos atrav\u00e9s da classe de estado:</p> <pre><code>class HomeScreenTest {\n\n    @get:Rule\n    val composeTestRule = createAndroidComposeRule&lt;ComponentActivity&gt;()\n\n    private lateinit var tracker: String\n    private lateinit var trackingCode: String\n    private lateinit var cep: String\n    private lateinit var track: String\n\n    @Before\n    fun setUp() {\n        composeTestRule.activity.apply {\n            tracker = getString(R.string.tracker)\n            trackingCode = getString(R.string.tracking_code)\n            cep = getString(R.string.cep)\n            track = getString(R.string.track)\n        }\n    }\n\n    @Test\n    fun homeScreenIsDisplayedCorrectly() {\n        val myCode = \"AMZ123456789\"\n        val myCep = 123456\n        composeTestRule.setContent {\n            MyAppTheme {\n                HomeContent(\n                    uiState = HomeUiState(code = myCode, cep = myCep),\n                    onUiEvent = {},\n                    onNavigateToTracking = {}\n                )\n            }\n        }\n\n        composeTestRule.onNodeWithText(tracker).assertIsDisplayed()\n        composeTestRule.onNodeWithText(trackingCode).assertIsDisplayed()\n        composeTestRule.onNodeWithText(cep).assertIsDisplayed()\n        composeTestRule.onNodeWithText(track).assertIsDisplayed()\n\n        composeTestRule.onNodeWithText(myCode).assertIsDisplayed()\n        composeTestRule.onNodeWithText(myCep.toString()).assertIsDisplayed()\n    }\n}\n</code></pre> <p>O m\u00e9todo setUp() ser\u00e1 chamado antes de cada teste. Ele \u00e9 \u00fatil para fazer configura\u00e7\u00f5es iniciais que os m\u00e9todos de testes precisam. No c\u00f3digo acima, apenas inicializamos as strings que vamos usar ao longo dessa classe para facilitar.</p> <p>Voc\u00ea deve ter notado que estamos testando a HomeContent() e n\u00e3o a HomeScreen(). A HomeScreen() tem uma depend\u00eancia com ViewModel. N\u00e3o \u00e9 o caso do projeto que criamos, mas normalmente ViewModels possuem diversas depend\u00eancias extras, como reposit\u00f3rios, use cases, entre outras. Ao isolar essas duas fun\u00e7\u00f5es e ter uma fun\u00e7\u00e3o que depende apenas do estado, podemos testar facilmente como o conte\u00fado da tela reage a diferentes estados. Tamb\u00e9m n\u00e3o \u00e9 o caso do projeto que criamos por fins de simplicidade, mas \u00e9 comum que as telas possuam muitos dados. Testar o estado dela de acordo com os dados passados \u00e9 bem \u00fatil. Como a HomeContent() s\u00f3 precisa do estado (HomeUiState), podemos passar os dados que quisermos para fins de testes.</p> <p>Agora que j\u00e1 criamos e vemos um pouco da explica\u00e7\u00e3o do primeiro teste, vamos criar mais 2 testes b\u00e1sicos que verificam se o bot\u00e3o de rastrear est\u00e1 sendo ativado/desativado de acordo com os dados de rastreamento:</p> <pre><code>class HomeScreenTest {\n\n    ...\n\n    @Test\n    fun whenTrackingDataIsNotEmpty_thenTrackButtonShouldBeEnabled() {\n        composeTestRule.setContent {\n            MyAppTheme {\n                HomeContent(\n                    uiState = HomeUiState(code = \"AMZ123456\", cep = 123456),\n                    onUiEvent = {},\n                    onNavigateToTracking = {}\n                )\n            }\n        }\n\n        composeTestRule.onNodeWithText(track).assertIsEnabled()\n    }\n\n    @Test\n    fun whenTrackingDataIsEmpty_thenTrackButtonShouldBeDisabled() {\n        composeTestRule.setContent {\n            MyAppTheme {\n                HomeContent(\n                    uiState = HomeUiState(code = \"\", cep = -1),\n                    onUiEvent = {},\n                    onNavigateToTracking = {}\n                )\n            }\n        }\n\n        composeTestRule.onNodeWithText(track).assertIsNotEnabled()\n    }\n}\n</code></pre> <p>Mas e se quisermos simular inputs de texto nos 2 TextFields de code e cep? Da forma como est\u00e1 n\u00e3o funcionaria, pois o onUiEvent n\u00e3o altera nada e os dados n\u00e3o mudam. Como nossa classe de dados \u00e9 simples, n\u00f3s podemos criar um state diretamente no teste. Vamos criar mais 2 testes. Como definimos antes na HomeScreen, o TextField de cep s\u00f3 aceita n\u00fameros, ent\u00e3o vamos testar se isso realmente est\u00e1 funcionando quando tentamos inserir outros caracteres. O outro teste \u00e9 para verificar se o bot\u00e3o de rastrear \u00e9 ativado/desativado de acordo com o input do usu\u00e1rio, pois definimos que se o code e cep estiverem vazios, ele deve ficar desativado.</p> <pre><code>class HomeScreenTest {\n\n    ...\n\n    @Test\n    fun whenTypingNonNumberCharactersInTheCep_thenTextFieldShouldIgnore() {\n        composeTestRule.setContent {\n            MyAppTheme {\n                var homeUiState: HomeUiState by remember { mutableStateOf(HomeUiState()) }\n                HomeContent(\n                    uiState = homeUiState,\n                    onUiEvent = { event -&gt;\n                        homeUiState = when (event) {\n                            is HomeUiEvent.CodeChanged -&gt; homeUiState.copy(code = event.code)\n                            is HomeUiEvent.CepChanged -&gt; homeUiState.copy(cep = event.cep)\n                        }\n                    },\n                    onNavigateToTracking = {}\n                )\n            }\n        }\n\n        val invalidCep1 = \"abcdef\"\n        composeTestRule.onNodeWithText(cep).performTextInput(invalidCep1)\n        composeTestRule.onNodeWithText(invalidCep1).assertIsNotDisplayed()\n\n        val invalidCep2 = \"-,.{}/@#\"\n        composeTestRule.onNodeWithText(cep).performTextInput(invalidCep2)\n        composeTestRule.onNodeWithText(invalidCep2).assertIsNotDisplayed()\n\n        val invalidCep3 = \" \"\n        composeTestRule.onNodeWithText(cep).performTextInput(invalidCep3)\n        composeTestRule.onNodeWithText(invalidCep3).assertIsNotDisplayed()\n\n        val validCep1 = \"1\"\n        composeTestRule.onNodeWithText(cep).performTextInput(validCep1)\n        composeTestRule.onNodeWithText(validCep1).assertIsDisplayed()\n\n        val validCep2 = \"23456\"\n        composeTestRule.onNodeWithText(cep).performTextInput(validCep2)\n        composeTestRule.onNodeWithText(validCep1 + validCep2).assertIsDisplayed()\n\n        val validCep3 = \"abc\"\n        composeTestRule.onNodeWithText(cep).performTextInput(validCep3)\n        composeTestRule.onNodeWithText(validCep2 + validCep3).assertIsNotDisplayed()\n        composeTestRule.onNodeWithText(validCep1 + validCep2).assertIsDisplayed()\n    }\n\n    @Test\n    fun whenInsertCodeAndCep_thenEnableTrackButton() {\n        composeTestRule.setContent {\n            MyAppTheme {\n                var homeUiState: HomeUiState by remember { mutableStateOf(HomeUiState()) }\n                HomeContent(\n                    uiState = homeUiState,\n                    onUiEvent = { event -&gt;\n                        homeUiState = when (event) {\n                            is HomeUiEvent.CodeChanged -&gt; homeUiState.copy(code = event.code)\n                            is HomeUiEvent.CepChanged -&gt; homeUiState.copy(cep = event.cep)\n                        }\n                    },\n                    onNavigateToTracking = {}\n                )\n            }\n        }\n\n        composeTestRule.onNodeWithText(track).assertIsNotEnabled()\n        composeTestRule.onNodeWithText(trackingCode).performTextInput(\"AMZ123456\")\n        composeTestRule.onNodeWithText(track).assertIsNotEnabled()\n\n        composeTestRule.onNodeWithText(cep).performTextInput(\"123456\")\n        composeTestRule.onNodeWithText(track).assertIsEnabled()\n\n        composeTestRule.onNodeWithText(trackingCode).performTextReplacement(\"\")\n        composeTestRule.onNodeWithText(track).assertIsNotEnabled()\n    }\n}\n</code></pre> <p>Utilizamos <code>var homeUiState: HomeUiState by remember { mutableStateOf(HomeUiState()) }</code> para manter uma refer\u00eancia ao estado que podemos alterar posteriormente no onUiEvent. Para manipular os inputs, usamos as fun\u00e7\u00f5es <code>performTextInput()</code> e <code>performTextReplacement()</code>.</p> <p>Para n\u00e3o se alongar demais, esses ser\u00e3o os \u00fanicos testes que vamos criar da HomeScreen. Abaixo voc\u00ea pode ver o c\u00f3digo completo da classe.</p> Ver c\u00f3digo da HomeScreenTest <pre><code>class HomeScreenTest {\n\n    @get:Rule\n    val composeTestRule = createAndroidComposeRule&lt;ComponentActivity&gt;()\n\n    private lateinit var tracker: String\n    private lateinit var trackingCode: String\n    private lateinit var cep: String\n    private lateinit var track: String\n\n    @Before\n    fun setUp() {\n        composeTestRule.activity.apply {\n            tracker = getString(R.string.tracker)\n            trackingCode = getString(R.string.tracking_code)\n            cep = getString(R.string.cep)\n            track = getString(R.string.track)\n        }\n    }\n\n    @Test\n    fun homeScreenIsDisplayedCorrectly() {\n        val myCode = \"AMZ123456789\"\n        val myCep = 123456\n        composeTestRule.setContent {\n            MyAppTheme {\n                HomeContent(\n                    uiState = HomeUiState(code = myCode, cep = myCep),\n                    onUiEvent = {},\n                    onNavigateToTracking = {}\n                )\n            }\n        }\n\n        composeTestRule.onNodeWithText(tracker).assertIsDisplayed()\n        composeTestRule.onNodeWithText(trackingCode).assertIsDisplayed()\n        composeTestRule.onNodeWithText(cep).assertIsDisplayed()\n        composeTestRule.onNodeWithText(track).assertIsDisplayed()\n\n        composeTestRule.onNodeWithText(myCode).assertIsDisplayed()\n        composeTestRule.onNodeWithText(myCep.toString()).assertIsDisplayed()\n    }\n\n    @Test\n    fun whenTrackingDataIsNotEmpty_thenTrackButtonShouldBeEnabled() {\n        composeTestRule.setContent {\n            MyAppTheme {\n                HomeContent(\n                    uiState = HomeUiState(code = \"AMZ123456\", cep = 123456),\n                    onUiEvent = {},\n                    onNavigateToTracking = {}\n                )\n            }\n        }\n\n        composeTestRule.onNodeWithText(track).assertIsEnabled()\n    }\n\n    @Test\n    fun whenTrackingDataIsEmpty_thenTrackButtonShouldBeDisabled() {\n        composeTestRule.setContent {\n            MyAppTheme {\n                HomeContent(\n                    uiState = HomeUiState(code = \"\", cep = -1),\n                    onUiEvent = {},\n                    onNavigateToTracking = {}\n                )\n            }\n        }\n\n        composeTestRule.onNodeWithText(track).assertIsNotEnabled()\n    }\n\n    @Test\n    fun whenTypingNonNumberCharactersInTheCep_thenTextFieldShouldIgnore() {\n        composeTestRule.setContent {\n            MyAppTheme {\n                var homeUiState: HomeUiState by remember { mutableStateOf(HomeUiState()) }\n                HomeContent(\n                    uiState = homeUiState,\n                    onUiEvent = { event -&gt;\n                        homeUiState = when (event) {\n                            is HomeUiEvent.CodeChanged -&gt; homeUiState.copy(code = event.code)\n                            is HomeUiEvent.CepChanged -&gt; homeUiState.copy(cep = event.cep)\n                        }\n                    },\n                    onNavigateToTracking = {}\n                )\n            }\n        }\n\n        val invalidCep1 = \"abcdef\"\n        composeTestRule.onNodeWithText(cep).performTextInput(invalidCep1)\n        composeTestRule.onNodeWithText(invalidCep1).assertIsNotDisplayed()\n\n        val invalidCep2 = \"-,.{}/@#\"\n        composeTestRule.onNodeWithText(cep).performTextInput(invalidCep2)\n        composeTestRule.onNodeWithText(invalidCep2).assertIsNotDisplayed()\n\n        val invalidCep3 = \" \"\n        composeTestRule.onNodeWithText(cep).performTextInput(invalidCep3)\n        composeTestRule.onNodeWithText(invalidCep3).assertIsNotDisplayed()\n\n        val validCep1 = \"1\"\n        composeTestRule.onNodeWithText(cep).performTextInput(validCep1)\n        composeTestRule.onNodeWithText(validCep1).assertIsDisplayed()\n\n        val validCep2 = \"23456\"\n        composeTestRule.onNodeWithText(cep).performTextInput(validCep2)\n        composeTestRule.onNodeWithText(validCep1 + validCep2).assertIsDisplayed()\n\n        val validCep3 = \"abc\"\n        composeTestRule.onNodeWithText(cep).performTextInput(validCep3)\n        composeTestRule.onNodeWithText(validCep2 + validCep3).assertIsNotDisplayed()\n        composeTestRule.onNodeWithText(validCep1 + validCep2).assertIsDisplayed()\n    }\n\n    @Test\n    fun whenInsertCodeAndCep_thenEnableTrackButton() {\n        composeTestRule.setContent {\n            MyAppTheme {\n                var homeUiState: HomeUiState by remember { mutableStateOf(HomeUiState()) }\n                HomeContent(\n                    uiState = homeUiState,\n                    onUiEvent = { event -&gt;\n                        homeUiState = when (event) {\n                            is HomeUiEvent.CodeChanged -&gt; homeUiState.copy(code = event.code)\n                            is HomeUiEvent.CepChanged -&gt; homeUiState.copy(cep = event.cep)\n                        }\n                    },\n                    onNavigateToTracking = {}\n                )\n            }\n        }\n\n        composeTestRule.onNodeWithText(track).assertIsNotEnabled()\n        composeTestRule.onNodeWithText(trackingCode).performTextInput(\"AMZ123456\")\n        composeTestRule.onNodeWithText(track).assertIsNotEnabled()\n\n        composeTestRule.onNodeWithText(cep).performTextInput(\"123456\")\n        composeTestRule.onNodeWithText(track).assertIsEnabled()\n\n        composeTestRule.onNodeWithText(trackingCode).performTextReplacement(\"\")\n        composeTestRule.onNodeWithText(track).assertIsNotEnabled()\n    }\n}\n</code></pre>"},{"location":"testing/#testando-a-navegacao-do-app","title":"Testando a navega\u00e7\u00e3o do app","text":"<p>Vamos criar tamb\u00e9m 2 testes b\u00e1sicos para verificar se a navega\u00e7\u00e3o do app est\u00e1 funcionando corretamente. Veja o c\u00f3digo completo da classe:</p> Ver c\u00f3digo da NavigationTest <pre><code>class NavigationTest {\n\n    @get:Rule\n    val composeTestRule = createAndroidComposeRule&lt;ComponentActivity&gt;()\n    private lateinit var navController: TestNavHostController\n\n    @Before\n    fun setUpAppNavHost() {\n        composeTestRule.setContent {\n            MyAppTheme {\n                navController = TestNavHostController(LocalContext.current)\n                navController.navigatorProvider.addNavigator(ComposeNavigator())\n                AppNavHost(navController = navController)\n            }\n        }\n    }\n\n    @Test\n    fun verifyStartDestination() {\n        composeTestRule.onNodeWithText(getString(R.string.tracker)).assertIsDisplayed()\n    }\n\n    @Test\n    fun whenClickOnTrackButton_thenShouldNavigateToTrackingScreen() {\n        val currentRoute1 = navController.currentBackStackEntry?.destination?.route\n        assertEquals(currentRoute1, Screen.HomeScreen.route)\n        composeTestRule\n            .onNodeWithText(getString(R.string.tracker))\n            .assertIsDisplayed()\n\n        composeTestRule\n            .onNodeWithText(getString(R.string.tracking_code))\n            .performTextInput(\"AMZ123456\")\n        composeTestRule\n            .onNodeWithText(getString(R.string.cep))\n            .performTextInput(\"123456789\")\n        composeTestRule\n            .onNodeWithText(getString(R.string.track))\n            .performClick()\n\n        val currentRoute2 = navController.currentBackStackEntry?.destination?.route\n        assertEquals(currentRoute2, Screen.TrackingScreen.route)\n        composeTestRule\n            .onNodeWithText(getString(R.string.tracking))\n            .assertIsDisplayed()\n    }\n\n    private fun getString(resourceId: Int) = composeTestRule.activity.getString(resourceId)\n}\n</code></pre> <p>No setUpAppNavHost() n\u00f3s fazemos as configura\u00e7\u00f5es iniciais do nosso AppNavHost, criando um NavHostController de testes com TestNavHostController.</p> <p>No primeiro teste, verificamos se o destino inicial \u00e9 a HomeScreen, testando se um texto que apenas ela possui est\u00e1 sendo exibido. J\u00e1 no segundo, checamos se a navega\u00e7\u00e3o para a TrackingScreen est\u00e1 ocorrendo normalmente, verificando a rota atual.</p>"},{"location":"testing/#conclusao","title":"Conclus\u00e3o","text":"<p>Testes s\u00e3o essenciais e \u00e9 muito importante saber como implement\u00e1-los. Essa se\u00e7\u00e3o focou apenas em dar uma pequena introdu\u00e7\u00e3o e um ponto de partida sobre como os testes de interface funcionam no Compose. Como o projeto de app que criamos na se\u00e7\u00e3o anterior \u00e9 bem simples, talvez n\u00e3o d\u00ea para ver uma grande utilidade nos testes feitos nessa se\u00e7\u00e3o, e alguns deles parecem de fato in\u00fateis. No entanto, \u00e9 poss\u00edvel perceber que com a estrutura que foi montada, os testes foram facilitados e pudemos ver isso na pr\u00e1tica. \u00c9 sempre importante pensar se o c\u00f3digo que voc\u00ea est\u00e1 criando \u00e9 f\u00e1cil de testar.</p> <p>O Compose facilita muito isso, pois podemos criar UIs isoladas e componentizadas com facilidade, al\u00e9m de possuir muitos recursos e m\u00e9todos de f\u00e1cil usabilidade que ajudam nos testes, como foi poss\u00edvel observar ao longo da se\u00e7\u00e3o.</p> <p>Voc\u00ea pode ler mais sobre testes na documenta\u00e7\u00e3o.</p>"},{"location":"testing/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Testing your Compose layout (documenta\u00e7\u00e3o)</li> <li>Navigation with Compose - Testing the NavHost (documenta\u00e7\u00e3o)</li> <li>Testing in Jetpack Compose (codelab)</li> </ul>"},{"location":"theme/","title":"Theme","text":"<p>Essa se\u00e7\u00e3o \u00e9 dedicada a entender um pouco sobre como funciona e como modificar o tema dos nossos apps. Como mencionado na introdu\u00e7\u00e3o, esse conte\u00fado utiliza o Material Design 3, que \u00e9 a evolu\u00e7\u00e3o do Material Design. Ao criar um projeto Compose nas vers\u00f5es mais recentes do Android Studio, o tema j\u00e1 inclui a depend\u00eancia do Material Design 3.</p> <p>Normalmente, as configura\u00e7\u00f5es de tema ficam no pacote theme ap\u00f3s o projeto ser criado, onde o Theme.kt possui a implementa\u00e7\u00e3o principal do tema.</p>"},{"location":"theme/#criando-um-tema","title":"Criando um tema","text":"<p>Voc\u00ea pode escolher as cores que preferir para o tema. Vou utilizar o Material Theme Builder, que \u00e9 um site bastante \u00fatil para criar nosso tema. Ap\u00f3s personalizar as cores, voc\u00ea pode exportar o tema em um formato .zip para diversas plataformas e sistemas, como Views ou Jetpack Compose. Para Compose, ele exporta 2 arquivos principais no pacote theme: Color.kt e Theme.kt, contendo as cores e configura\u00e7\u00f5es do tema, respectivamente.</p>"},{"location":"theme/#theme_1","title":"Theme","text":"<p>O arquivo Theme.kt geralmente cont\u00e9m a fun\u00e7\u00e3o Composable principal do tema, contendo a chamada para a <code>MaterialTheme</code>. Veja o pequeno exemplo:</p> <pre><code>private val LightColors = lightColorScheme(\n    primary = md_theme_light_primary,\n    onPrimary = md_theme_light_onPrimary,\n    // outras cores\n)\n\nprivate val DarkColors = darkColorScheme(\n    primary = md_theme_dark_primary,\n    onPrimary = md_theme_dark_onPrimary,\n    // outras cores\n)\n\n@Composable\nfun MyAppTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    // Dynamic color is available on Android 12+\n    dynamicColor: Boolean = true,\n    content: @Composable () -&gt; Unit\n) {\n    val colorScheme = when {\n        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        }\n        darkTheme -&gt; DarkColors\n        else -&gt; LightColors\n    }\n\n    val view = LocalView.current\n    if (!view.isInEditMode) {\n        SideEffect {\n            (view.context as Activity).window.statusBarColor = colorScheme.primary.toArgb()\n        }\n    }\n\n    MaterialTheme(\n        colorScheme = colorScheme,\n        typography = Typography,\n        content = content\n    )\n}\n</code></pre> <p>O c\u00f3digo padr\u00e3o do Compose ao criar um novo projeto j\u00e1 vem com a configura\u00e7\u00e3o de cores din\u00e2micas, como pode ver na MyAppTheme. A partir do Android 12, o tema usar\u00e1 cores din\u00e2micas se estiver habilitado. Ele tamb\u00e9m vem com a fun\u00e7\u00e3o <code>isSystemInDarkTheme()</code>, que como o pr\u00f3prio nome j\u00e1 diz, checa se o dispositivo est\u00e1 usando o tema dark.</p> <p>Al\u00e9m da tipografia, voc\u00ea tamb\u00e9m pode definir shapes personalizados. Por exemplo, criando um novo arquivo Shape.kt no pacote theme com o c\u00f3digo:</p> <pre><code>val shapes = Shapes(\n    extraSmall = RoundedCornerShape(4.dp),\n    small = RoundedCornerShape(8.dp),\n    medium = RoundedCornerShape(12.dp),\n    large = RoundedCornerShape(16.dp),\n    extraLarge = RoundedCornerShape(24.dp)\n)\n</code></pre> <p>Agora basta alterar nossa MyAppTheme para incluir os shapes personalizados:</p> <pre><code>@Composable\nfun MyAppTheme(\n   ...\n) {\n    ...\n    MaterialTheme(\n        colorScheme = colorScheme,\n        typography = Typography,\n        shapes = shapes,\n        content = content\n    )\n}\n</code></pre>"},{"location":"theme/#utilizando-propriedades-do-tema","title":"Utilizando propriedades do tema","text":"<p>Ap\u00f3s definir as configura\u00e7\u00f5es do tema, voc\u00ea pode usar suas propriedades atrav\u00e9s da <code>MaterialTheme</code>. Por exemplo:</p> <pre><code>Text(\n    text = \"Material Design 3\",\n    color = MaterialTheme.colorScheme.primary,\n    style = MaterialTheme.typography.titleLarge\n)\n\nCard(\n    shape = MaterialTheme.shapes.medium\n) {\n    ...\n}\n</code></pre>"},{"location":"theme/#conclusao","title":"Conclus\u00e3o","text":"<p>N\u00e3o h\u00e1 muito mais para falar sobre temas. Voc\u00ea pode ler a documenta\u00e7\u00e3o e conte\u00fados auxiliares se quiser saber mais.</p>"},{"location":"theme/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Material Design 3 in Compose (documenta\u00e7\u00e3o)</li> <li>Theming in Compose with Material 3 (codelab)</li> </ul>"},{"location":"components/button/","title":"Button","text":"<p>Bot\u00f5es tamb\u00e9m s\u00e3o uma parte fundamental em qualquer app. No Jetpack Compose n\u00f3s temos v\u00e1rias op\u00e7\u00f5es de bot\u00f5es para se utilizar. Para evitar deixar essa se\u00e7\u00e3o longa, voc\u00ea pode ler a descri\u00e7\u00e3o de cada bot\u00e3o na documenta\u00e7\u00e3o.</p> <p>A implementa\u00e7\u00e3o b\u00e1sica de um Button segue o c\u00f3digo abaixo:</p> <pre><code>@Composable\nprivate fun Button() {\n    Button(onClick = {}) {\n        Text(\"Button\")\n    }\n}\n</code></pre> <p>Voc\u00ea pode alterar o nome Button no c\u00f3digo acima para qualquer uma das seguintes op\u00e7\u00f5es: FilledTonalButton, OutlinedButton, ElevatedButton ou TextButton. O resultado voc\u00ea v\u00ea logo abaixo, onde Filled \u00e9 a implementa\u00e7\u00e3o b\u00e1sica mostrada no c\u00f3digo anterior.</p> <p></p> <p>Obviamente, voc\u00ea tem diversas op\u00e7\u00f5es de customiza\u00e7\u00e3o do Button. Veja um pequeno exemplo modificando o contentPadding e a containerColor, al\u00e9m de um \u00edcone ao lado do texto:</p> <pre><code>@Composable\nprivate fun CustomButton() {\n    Button(\n        onClick = {},\n        contentPadding = PaddingValues(16.dp),\n        colors = ButtonDefaults.buttonColors(\n            containerColor = Color(0xFFAF0101)\n        )\n    ) {\n        Icon(\n            imageVector = Icons.Default.Delete,\n            contentDescription = \"Delete icon\"\n        )\n        Spacer(Modifier.width(6.dp))\n        Text(\"Excluir arquivo\")\n    }\n}\n</code></pre> <p></p> <ul> <li>N\u00e3o precisamos especificar uma Row para obter o efeito do Icon() estar ao lado do Text() porque o content (o \u00faltimo par\u00e2metro) que o Button espera j\u00e1 \u00e9 uma RowScope, ou seja, \u00e9 como se estiv\u00e9ssemos dentro de uma Row por padr\u00e3o.</li> </ul>"},{"location":"components/button/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Button (documenta\u00e7\u00e3o)</li> <li>Buttons (Material Design 3)</li> </ul>"},{"location":"components/card/","title":"Card","text":"<p>Cards tamb\u00e9m s\u00e3o bastante importantes e nessa se\u00e7\u00e3o vamos ver um pouco sobre eles. Assim como outros components que j\u00e1 vimos, Card tem diversas varia\u00e7\u00f5es. Veja uma implementa\u00e7\u00e3o b\u00e1sica:</p> <pre><code>@Composable\nprivate fun Card() {\n    Card(shape = RoundedCornerShape(16.dp)) {\n        Image(\n            painter = painterResource(id = R.drawable.img_nature),\n            contentDescription = \"Image\",\n            contentScale = ContentScale.Crop,\n            modifier = Modifier\n                .size(200.dp)\n        )\n        Column(modifier = Modifier.padding(16.dp)) {\n            Text(\n                text = \"Nature image\",\n                color = Color.Black,\n                fontSize = 16.sp\n            )\n            Text(\n                text = \"1.2 MB\",\n                fontSize = 12.sp,\n            )\n        }\n    }\n}\n</code></pre> <p></p> <p>Um ElevatedCard, que como o nome diz, possui uma eleva\u00e7\u00e3o e shadow de acordo com a eleva\u00e7\u00e3o:</p> <pre><code>@Composable\nprivate fun Card() {\n    ElevatedCard(\n        shape = RoundedCornerShape(16.dp),\n        elevation = CardDefaults.cardElevation(\n            defaultElevation = 12.dp\n        ),\n        colors = CardDefaults.cardColors(\n            containerColor = Color.White\n        )\n    ) {\n        ...\n    }\n}\n</code></pre> <p></p> <p>E tamb\u00e9m temos o OutlinedCard:</p> <pre><code>@Composable\nprivate fun Card() {\n    OutlinedCard(\n        shape = RoundedCornerShape(16.dp),\n        border = BorderStroke(1.dp, Color.Black)\n    ) {\n        ...\n    }\n}\n</code></pre> <p></p>"},{"location":"components/card/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Card (documenta\u00e7\u00e3o)</li> <li>Cards (Material Design 3)</li> </ul>"},{"location":"components/image/","title":"Image","text":"<p>Praticamente todo app tem imagens. Essa se\u00e7\u00e3o abordar\u00e1 um pouco sobre como utilizar imagens no Compose, bem como algumas pequenas personaliza\u00e7\u00f5es.</p>"},{"location":"components/image/#icon","title":"Icon","text":"<p>Antes de falarmos sobre o componente Image(), vamos falar sobre o Icon(). Voc\u00ea pode obter o mesmo comportamento usando Image(), mas Icon() \u00e9 uma forma mais conveniente para carregar \u00edcones, como drawables vetoriais. Isso porque ele fornece um par\u00e2metro tint que pode ser usado para mudar a cor do \u00edcone facilmente. J\u00e1 usamos ele em se\u00e7\u00f5es anteriores, mas vamos ver mais um exemplo.</p> <p>Compose possui alguns \u00edcones padr\u00e3o fornecido atrav\u00e9s de Icons, como por exemplo: <code>Icons.Default.Delete</code>. Voc\u00ea pode usar \u00edcones tanto com imageVector quanto painter, como no exemplo abaixo, que utiliza um \u00edcone de Icons e um \u00edcone criado com o Asset Studio do Android Studio:</p> <pre><code>@Composable\nprivate fun Icon1() {\n    Icon(\n        imageVector = Icons.Default.Person,\n        contentDescription = \"Person icon\",\n        tint = Color.Blue\n    )\n}\n\n@Composable\nprivate fun Icon2() {\n    Icon(\n        painter = painterResource(id = R.drawable.baseline_person_24),\n        contentDescription = \"Person icon\",\n        tint = Color.Red\n    )\n}\n</code></pre> <p></p>"},{"location":"components/image/#carregando-imagens-locais","title":"Carregando imagens locais","text":"<p>Vamos come\u00e7ar carregando imagens que est\u00e3o na pasta res/drawable. Veja o exemplo simples:</p> <pre><code>@Composable\nprivate fun Image() {\n    Box(\n        contentAlignment = Alignment.Center,\n        modifier = Modifier.fillMaxSize()\n    ) {\n        Image(\n            painter = painterResource(id = R.drawable.img_nature),\n            contentDescription = \"Image\",\n            contentScale = ContentScale.Crop,\n            modifier = Modifier.size(width = 300.dp, height = 250.dp)\n        )\n    }\n}\n</code></pre> <p></p> <p>Adicionamos um <code>ContentScale.Crop</code> e mudamos o tamanho da imagem com o <code>Modifier.size(width = 300.dp, height = 250.dp)</code>. Veja a documenta\u00e7\u00e3o para ter mais no\u00e7\u00e3o sobre o ContentScale e como ele modifica a exibi\u00e7\u00e3o da imagem.</p>"},{"location":"components/image/#carregando-imagens-da-internet","title":"Carregando imagens da internet","text":"<p>Assim como no sistema View, Compose n\u00e3o oferece uma maneira nativa de carregar imagens da internet. Precisamos utilizar bibliotecas de terceiros. Existem v\u00e1rias op\u00e7\u00f5es, como Coil, Glide e tamb\u00e9m a Landscapist, que oferece op\u00e7\u00f5es de carregamento usando as duas anteriores. Particularmente, costumo utilizar muito a Landscapist, pois ela oferece diversas op\u00e7\u00f5es de personaliza\u00e7\u00e3o interessantes. Mas vamos ver um exemplo utilizando a Coil, que \u00e9 bastante popular. Primeiro temos que adicionar sua depend\u00eancia:</p> <pre><code>implementation(\"io.coil-kt:coil-compose:$version\")\n</code></pre> <p>Lembre-se tamb\u00e9m de adicionar a permiss\u00e3o de acesso \u00e0 internet no AndroidManifest:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n</code></pre> <pre><code>@Composable\nprivate fun Image() {\n    AsyncImage(\n        model = \"https://...\",\n        contentDescription = \"Image\"\n    )\n}\n</code></pre> <p></p>"},{"location":"components/image/#customizando-images","title":"Customizando images","text":"<p>Voc\u00ea tamb\u00e9m pode personalizar a exibi\u00e7\u00e3o da imagem. Por exemplo, tornando ela circular ou com um shape personalizado. Basta utilizar o poder do <code>Modifier.clip()</code>. Essa fun\u00e7\u00e3o n\u00e3o \u00e9 do componente Image() em si, mas pode ser aplicada em qualquer Composable (quando fizer sentido, claro). Vamos ver mais sobre o Modifier em sua pr\u00f3pria se\u00e7\u00e3o.</p> CircleShapeRoundedCornerShape(16.dp)CircleShape com borda <p></p> <pre><code>@Composable\nprivate fun Image() {\n    Image(\n        painter = painterResource(id = R.drawable.img_nature),\n        contentDescription = \"Image\",\n        contentScale = ContentScale.Crop,\n        modifier = Modifier\n            .size(150.dp)\n            .clip(CircleShape)\n    )\n}\n</code></pre> <p></p> <pre><code>@Composable\nprivate fun Image() {\n    Image(\n        ...\n        modifier = Modifier\n            .size(150.dp)\n            .clip(RoundedCornerShape(16.dp))\n    )\n}\n</code></pre> <p></p> <pre><code>@Composable\nprivate fun Image() {\n    val borderWidth = 4.dp\n    Image(\n        painter = painterResource(id = R.drawable.img_nature),\n        contentDescription = \"Image\",\n        contentScale = ContentScale.Crop,\n        modifier = Modifier\n            .size(150.dp)\n            .border(\n                border = BorderStroke(borderWidth, Color.Red),\n                shape = CircleShape\n            )\n            .clip(CircleShape)\n    )\n}\n</code></pre> <p>Podemos adicionar tamb\u00e9m um colorFilter:</p> <pre><code>@Composable\nprivate fun Image() {\n    Image(\n        painter = painterResource(id = R.drawable.img_nature),\n        contentDescription = \"Image\",\n        contentScale = ContentScale.Crop,\n        colorFilter = ColorFilter.tint(color = Color.Green, blendMode = BlendMode.Darken),\n        modifier = Modifier.size(width = 200.dp, height = 150.dp)\n    )\n}\n</code></pre> <p></p>"},{"location":"components/image/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Customize an image (documenta\u00e7\u00e3o)</li> </ul>"},{"location":"components/navigationdrawer/","title":"Navigation Drawer","text":"<p>Navigation Drawer \u00e9 um componente bem conhecido e utilizado em apps. Na vers\u00e3o de componentes do Material Design 2 no Compose, o Navigation Drawer era parte do Scaffold. Nos componentes do M3, ele se tornou independente.</p> <p>Vamos criar uma implementa\u00e7\u00e3o b\u00e1sica dele e ver como fica. Primeiro, vamos criar uma sealed class que servir\u00e1 para agrupar os itens do nosso Navigation Drawer.</p> <pre><code>sealed class NavDrawerItem(\n    @DrawableRes val iconResId: Int,\n    @StringRes val titleResId: Int,\n) {\n    data object Home : NavDrawerItem(R.drawable.baseline_home_24, R.string.home)\n    data object PrivacyPolicy : NavDrawerItem(R.drawable.baseline_privacy_tip_24, R.string.privacy_policy)\n    data object SavedFiles : NavDrawerItem(R.drawable.baseline_save_24, R.string.saved_files)\n    data object ShareApp : NavDrawerItem(R.drawable.baseline_share_24, R.string.share_app)\n}\n</code></pre> <p>Agora vamos criar o Navigation Drawer em si fazendo uso da ModalNavigationDrawer.</p> <pre><code>@Composable\nfun MyNavigationDrawer(\n    drawerState: DrawerState,\n    modifier: Modifier = Modifier,\n    content: @Composable () -&gt; Unit\n) {\n    val coroutineScope = rememberCoroutineScope()\n    val items = listOf(\n        NavDrawerItem.Home,\n        NavDrawerItem.PrivacyPolicy,\n        NavDrawerItem.SavedFiles,\n        NavDrawerItem.ShareApp,\n    )\n    ModalNavigationDrawer(\n        drawerState = drawerState,\n        drawerContent = {\n            ModalDrawerSheet {\n                Spacer(Modifier.height(22.dp))\n                Text(\n                    text = stringResource(id = R.string.app_name),\n                    fontWeight = FontWeight.Bold,\n                    fontSize = 16.sp,\n                    modifier = Modifier.padding(start = 30.dp)\n                )\n                Spacer(Modifier.height(22.dp))\n                items.forEach { item -&gt;\n                    NavigationDrawerItem(\n                        icon = {\n                            Icon(\n                                painter = painterResource(id = item.iconResId),\n                                contentDescription = stringResource(id = item.titleResId)\n                            )\n                        },\n                        label = {\n                            Text(\n                                text = stringResource(id = item.titleResId)\n                            )\n                        },\n                        selected = (item == NavDrawerItem.Home),\n                        onClick = {\n                            coroutineScope.launch { drawerState.close() }\n                            when (item) {\n                                is NavDrawerItem.Home -&gt; {}\n                                is NavDrawerItem.PrivacyPolicy -&gt; {}\n                                is NavDrawerItem.SavedFiles -&gt; {}\n                                is NavDrawerItem.ShareApp -&gt; {}\n                            }\n                        },\n                        modifier = modifier.padding(NavigationDrawerItemDefaults.ItemPadding)\n                    )\n                }\n            }\n        },\n        modifier = modifier,\n        content = content\n    )\n}\n</code></pre> <p>Com isso, j\u00e1 temos o nosso Navigation Drawer sem muitos segredos. O destaque fica para a ModalDrawerSheet e NavigationDrawerItem, onde temos algumas op\u00e7\u00f5es de personaliza\u00e7\u00e3o a mais. Poder\u00edamos usar qualquer Composable no drawerContent da ModalNavigationDrawer, afinal ela \u00e9 apenas o container, mas para fins de conveni\u00eancia e como o Compose oferece esses componentes, usamos ModalDrawerSheet e NavigationDrawerItem que d\u00e3o vida ao Navigation Drawer.</p> <p>Por fim, podemos usar essa fun\u00e7\u00e3o a n\u00edvel de tela, utilizando um Scaffold como content. Vamos reutilizar parte do c\u00f3digo que vimos na se\u00e7\u00e3o sobre Scaffold, adicionando um navigationIcon na TopAppBar para exibir o \u00edcone comumente usado em um Navigation Drawer. <code>drawerState.open()</code> \u00e9 uma suspension function, por isso temos que utilizar coroutineScope.</p> <pre><code>@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun HomeScreen() {\n    val coroutineScope = rememberCoroutineScope()\n    val drawerState = rememberDrawerState(DrawerValue.Closed)\n    MyNavigationDrawer(drawerState = drawerState) {\n        Scaffold(\n            topBar = {\n                TopAppBar(\n                    colors = TopAppBarDefaults.topAppBarColors(\n                        containerColor = MaterialTheme.colorScheme.primaryContainer\n                    ),\n                    title = {\n                        Text(\"TopAppBar\")\n                    },\n                    navigationIcon = {\n                        IconButton(\n                            onClick = {\n                                coroutineScope.launch {\n                                    drawerState.open()\n                                }\n                            }\n                        ) {\n                            Icon(\n                                imageVector = Icons.Default.Menu,\n                                contentDescription = \"Menu\"\n                            )\n                        }\n                    }\n                )\n            },\n            floatingActionButton = {\n                FloatingActionButton(onClick = {}) {\n                    Icon(\n                        imageVector = Icons.Default.Add,\n                        contentDescription = \"Add\"\n                    )\n                }\n            }\n        ) { paddingValues -&gt;\n            Column(\n                verticalArrangement = Arrangement.Center,\n                horizontalAlignment = Alignment.CenterHorizontally,\n                modifier = Modifier\n                    .padding(paddingValues)\n                    .fillMaxSize()\n            ) {\n                Text(\n                    text = \"Conte\u00fado da tela\",\n                    fontSize = 24.sp\n                )\n            }\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"components/navigationdrawer/#opcoes-de-controle-e-personalizacao","title":"Op\u00e7\u00f5es de controle e personaliza\u00e7\u00e3o","text":"<p>Por padr\u00e3o, o Navigatrion Drawer abre com o gesto de arrastar. Voc\u00ea pode desativar isso definindo <code>gesturesEnabled = false</code> na ModalNavigationDrawer.</p> <p>Tanto o ModalDrawerSheet quanto NavigationDrawerItem possuem op\u00e7\u00f5es de personaliza\u00e7\u00e3o que voc\u00ea pode usar para mudar a apar\u00eancia dos itens, como shape e cores.</p>"},{"location":"components/navigationdrawer/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Navigation drawer (documenta\u00e7\u00e3o)</li> <li>Navigation drawer (Material Design 3)</li> <li>Material 3 Navigation Drawer with Android Jetpack Compose (artigo)</li> </ul>"},{"location":"components/others/","title":"Outros componentes","text":"<p>Para evitar deixar essa se\u00e7\u00e3o longa demais e como existem diversos outros componentes, vou apenas citar o nome de mais alguns. A documenta\u00e7\u00e3o \u00e9 bem rica e possui detalhes de como implementar cada um deles. Os componentes mostrados anteriormente s\u00e3o importantes e devem te dar uma boa base de como os outros funcionam no Compose.</p> <p>As imagens usadas aqui tamb\u00e9m s\u00e3o da pr\u00f3pria documenta\u00e7\u00e3o de cada componente.</p>"},{"location":"components/others/#alertdialog","title":"AlertDialog","text":"<p>AlertDialogs s\u00e3o fundamentais em qualquer aplicativo e o Compose tamb\u00e9m oferece esse componente com f\u00e1cil utiliza\u00e7\u00e3o. Al\u00e9m do componente tradicional do M3, voc\u00ea tamb\u00e9m tem acesso ao componente Dialog, que pode ser usado para criar dialogs mais personalizados sem estar preso aos paddings/diretrizes que o AlertDialog tradicional possui. Confira na documenta\u00e7\u00e3o.</p> <p></p>"},{"location":"components/others/#topappbar-e-bottomappbar","title":"TopAppBar e BottomAppBar","text":"<p>TopAppBar tamb\u00e9m \u00e9 um componente essencial. Compose oferece diversas op\u00e7\u00f5es para se utilizar, como CenterAlignedTopAppBar, al\u00e9m de op\u00e7\u00f5es de comportamento de rolagem.</p> <p>Ele \u00e9 comumente utilizado com o componente Scaffold e tamb\u00e9m existe a vers\u00e3o inversa do TopAppBar, o BottomAppBar. Nas imagens abaixo voc\u00ea v\u00ea exemplos de um TopAppBar e BottomAppBar, respectivamente. Confira na documenta\u00e7\u00e3o.</p> <p></p> <p></p>"},{"location":"components/others/#pager","title":"Pager","text":"<p>Pager \u00e9 um componente que oferece a fun\u00e7\u00e3o de pagina\u00e7\u00e3o de Composables, bem comum em visualizadores de imagens, por exemplo. Ele \u00e9 semelhante ao ViewPager do XML. Existem as op\u00e7\u00f5es de HorizontalPager e VerticalPager, onde o nome j\u00e1 sugere bem o que cada um faz. Confira na documenta\u00e7\u00e3o.</p> <p></p>"},{"location":"components/others/#floating-action-button","title":"Floating Action Button","text":"<p>Floating Action Button (FAB) \u00e9 um componente bem conhecido. Ele tamb\u00e9m \u00e9 comumente utilizado junto do Scaffold. Confira na documenta\u00e7\u00e3o.</p> <p></p>"},{"location":"components/others/#progress","title":"Progress","text":"<p>Progress \u00e9 um componente bastante comum e utilizado. Confira na documenta\u00e7\u00e3o.</p> <p></p>"},{"location":"components/others/#chip","title":"Chip","text":"<p>Chip tamb\u00e9m \u00e9 um componente bem comum. Confira na documenta\u00e7\u00e3o.</p> <p></p>"},{"location":"components/others/#conclusao","title":"Conclus\u00e3o","text":"<p>H\u00e1 v\u00e1rios outros componentes que n\u00e3o foram citados aqui, mas que s\u00e3o bem utilizados e tamb\u00e9m vale a pena mencionar, como o NavigationBar, ModalBottomSheet e DropdownMenu. Todos eles est\u00e3o presentes na documenta\u00e7\u00e3o do pacote do Material Design 3 do Compose, incluindo alguns exemplos de implementa\u00e7\u00e3o e imagens.</p>"},{"location":"components/others/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>androidx.compose.material3 (documenta\u00e7\u00e3o)</li> </ul>"},{"location":"components/scaffold/","title":"Scaffold","text":"<p>Diferente dos componentes citados anteriormente, os componentes a seguir s\u00e3o mais a n\u00edvel de tela. Scaffold \u00e9 uma estrutura fundamental que fornece um meio padronizado para interfaces complexas. Ele tamb\u00e9m fornece uma API simples que voc\u00ea pode usar para montar rapidamente a estrutura do seu app de acordo com as diretrizes do Material Design.</p> <p>Scaffold aceita v\u00e1rios Composables como par\u00e2metros, entre os quais est\u00e3o:</p> <ul> <li>topBar: a barra de aplicativos na parte superior da tela.</li> <li>bottomBar: a barra de aplicativos na parte inferior da tela, que tamb\u00e9m pode ser uma barra de navega\u00e7\u00e3o;</li> <li>floatingActionButton: um bot\u00e3o que paira sobre o canto inferior direito da tela que voc\u00ea pode usar para expor as principais a\u00e7\u00f5es.</li> </ul> <p>Veja um pequeno exemplo de um Scaffold:</p> <pre><code>@Composable\nprivate fun Scaffold() {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                colors = topAppBarColors(\n                    containerColor = MaterialTheme.colorScheme.primaryContainer,\n                    titleContentColor = MaterialTheme.colorScheme.primary,\n                ),\n                title = {\n                    Text(\"TopAppBar\")\n                }\n            )\n        },\n        bottomBar = {\n            BottomAppBar(\n                containerColor = MaterialTheme.colorScheme.primaryContainer,\n                contentColor = MaterialTheme.colorScheme.primary,\n            ) {\n                Text(\n                    text = \"BottomAppBar\",\n                    textAlign = TextAlign.Center,\n                    modifier = Modifier\n                        .fillMaxWidth()\n                )\n            }\n        },\n        floatingActionButton = {\n            FloatingActionButton(onClick = {}) {\n                Icon(\n                    imageVector = Icons.Default.Add,\n                    contentDescription = \"Add\"\n                )\n            }\n        }\n    ) { innerPadding -&gt;\n        Column(\n            verticalArrangement = Arrangement.Center,\n            horizontalAlignment = Alignment.CenterHorizontally,\n            modifier = Modifier\n                .padding(innerPadding)\n                .fillMaxSize()\n        ) {\n            Text(\n                text = \"Conte\u00fado da tela\",\n                fontSize = 24.sp\n            )\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"components/scaffold/#paddingvalues","title":"PaddingValues","text":"<p>Scaffold exp\u00f5e um PaddingValues que deve ser usado no Composable do content, que no c\u00f3digo acima est\u00e1 sendo nomeado como innerPadding e usado pela Column. Se n\u00e3o usarmos ele, a tela pode ficar inconsistente. Voc\u00ea pode ler esse artigo e/ou esse para ver exemplos visuais e saber um pouco mais sobre isso.</p>"},{"location":"components/scaffold/#parametro-bottombar","title":"Par\u00e2metro bottomBar","text":"<p>O par\u00e2metro bottomBar pode ser usado tanto para criar uma BottomAppBar quanto uma NavigationBar. Veja as imagens de exemplo abaixo de uma BottomAppBar e NavigationBar, respectivamente, retiradas diretamente do site do Material Design 3.</p> <p></p> <p></p>"},{"location":"components/scaffold/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Scaffold (documenta\u00e7\u00e3o)</li> </ul>"},{"location":"components/selectioncontrols/","title":"Checkbox, RadioButton e Switch","text":"<p>Os componentes Checkbox, RadioButton e Switch fazem parte da categoria de controles de sele\u00e7\u00e3o, permitindo aos usu\u00e1rios selecionarem entre um estado marcado/desmarcado ou ativado/desativado.</p>"},{"location":"components/selectioncontrols/#checkbox","title":"Checkbox","text":"<p>O Checkbox \u00e9 utilizado principalmente para representar um estado de \"marcado/desmarcado\", al\u00e9m de uma sele\u00e7\u00e3o m\u00faltipla e n\u00e3o exclusiva de itens. A implementa\u00e7\u00e3o b\u00e1sica de um Checkbox segue o c\u00f3digo abaixo:</p> <pre><code>@Composable\nprivate fun Checkbox() {\n    var checked by remember { mutableStateOf(true) }\n    Checkbox(\n        checked = checked,\n        onCheckedChange = { isChecked -&gt;\n            checked = isChecked\n        }\n    )\n}\n</code></pre> <p></p> <p>N\u00e3o h\u00e1 muito segredo, mas como pode ver, ele s\u00f3 possui a estrutura para o Checkbox em si. O formato de layout com texto ao lado deve ser montado personalizadamente. Isso tamb\u00e9m vale para o RadioButton e Switch. Vamos ver ent\u00e3o uma implementa\u00e7\u00e3o comum, com um Text() ao lado. Al\u00e9m disso, tamb\u00e9m podemos definir as cores para os diferentes estados (checked, unchecked etc.) atrav\u00e9s do par\u00e2metro colors. Veja o c\u00f3digo:</p> <pre><code>@Composable\nprivate fun Checkbox() {\n    var checked by remember { mutableStateOf(true) }\n    Row(\n        verticalAlignment = Alignment.CenterVertically,\n        modifier = Modifier\n            .clip(RoundedCornerShape(16.dp))\n            .clickable { checked = !checked }\n            .padding(horizontal = 6.dp)\n    ) {\n        Checkbox(\n            checked = checked,\n            onCheckedChange = { isChecked -&gt;\n                checked = isChecked\n            },\n            colors = CheckboxDefaults.colors(\n                checkedColor = Color.Black,\n                uncheckedColor = Color.Red,\n                checkmarkColor = Color.Yellow\n            )\n        )\n        Text(\n            text = \"Tema Dark\",\n            fontSize = 18.sp,\n            modifier = Modifier.padding(start = 6.dp)\n        )\n    }\n}\n</code></pre> <p></p>"},{"location":"components/selectioncontrols/#radiobutton","title":"RadioButton","text":"<p>Diferente do Checkbox, o RadioButton possui os par\u00e2metros principais como selected e onClick. Ele \u00e9 mais comumente usado para uma lista de op\u00e7\u00f5es onde um \u00fanico item \u00e9 selecion\u00e1vel. Tamb\u00e9m \u00e9 poss\u00edvel definir cores personalizadas para ele, mas vamos usar as cores padr\u00e3o. Veja o pequeno exemplo:</p> <pre><code>@Composable\nprivate fun RadioButton() {\n    val options = listOf(\"Padr\u00e3o do sistema\", \"Dark\", \"Light\")\n    var selectedOption by remember { mutableStateOf(options[0]) }\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .padding(18.dp)\n    ) {\n        Text(\n            text = \"Selecione o tema do app\",\n            fontSize = 22.sp\n        )\n        Spacer(Modifier.height(18.dp))\n        options.forEach { option -&gt;\n            Row(\n                verticalAlignment = Alignment.CenterVertically,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .clip(RoundedCornerShape(16.dp))\n                    .clickable { selectedOption = option }\n            ) {\n                RadioButton(\n                    selected = (option == selectedOption),\n                    onClick = { selectedOption = option }\n                )\n                Text(\n                    text = option,\n                    fontSize = 18.sp,\n                    modifier = Modifier.padding(start = 6.dp)\n                )\n            }\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"components/selectioncontrols/#switch","title":"Switch","text":"<p>Switch \u00e9 comumente utilizado para representar um estado de \"ligado/desligado\" e \u00e9 bem similar ao Checkbox em implementa\u00e7\u00e3o, mas h\u00e1 um par\u00e2metro adicional thumbContent que voc\u00ea pode utilizar para personalizar o conte\u00fado desenhado dentro da thumb. No c\u00f3digo de exemplo abaixo, estamos modificando o \u00edcone de acordo com o estado atual do Switch, al\u00e9m de definir algumas cores personalizadas.</p> <pre><code>@Composable\nprivate fun Switch() {\n    var checked by remember { mutableStateOf(true) }\n    Row(\n        verticalAlignment = Alignment.CenterVertically,\n        modifier = Modifier\n            .clip(RoundedCornerShape(16.dp))\n            .clickable { checked = !checked }\n            .padding(horizontal = 6.dp)\n    ) {\n        Switch(\n            checked = checked,\n            onCheckedChange = { isChecked -&gt;\n                checked = isChecked\n            },\n            thumbContent = {\n                val icon = if (checked) Icons.Filled.Check else Icons.Filled.Close\n                Icon(\n                    imageVector = icon,\n                    contentDescription = null,\n                    modifier = Modifier.size(SwitchDefaults.IconSize),\n                )\n            },\n            colors = SwitchDefaults.colors(\n                checkedThumbColor = Color.White,\n                uncheckedThumbColor = Color.Black,\n                checkedTrackColor = Color.Black,\n                uncheckedTrackColor = Color.DarkGray,\n                checkedIconColor = Color.Black,\n                uncheckedIconColor = Color.White,\n                checkedBorderColor = Color.Green,\n                uncheckedBorderColor = Color.Red\n            )\n        )\n        Text(\n            text = \"Tema Dark\",\n            fontSize = 18.sp,\n            modifier = Modifier.padding(start = 6.dp)\n        )\n    }\n}\n</code></pre> <p></p> <ul> <li>Se desejar ter o \u00edcone personalizado apenas quando estiver no estado de ativado, voc\u00ea pode tornar thumbContent null quando o estado for desativado. Por exemplo:</li> </ul> <pre><code>@Composable\nprivate fun Switch() {\n    var checked by remember { mutableStateOf(true) }\n    Row(\n       ...\n    ) {\n        Switch(\n            ...,\n            thumbContent = if (checked) {\n                {\n                    Icon(\n                        imageVector = Icons.Filled.Check,\n                        contentDescription = null,\n                        modifier = Modifier.size(SwitchDefaults.IconSize),\n                    )\n                }\n            } else {\n                null\n            },\n            ...\n        )\n        ...\n    }\n}\n</code></pre>"},{"location":"components/selectioncontrols/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Checkbox (Material Design 3)</li> <li>Switch (documenta\u00e7\u00e3o)</li> <li>Switch (Material Design 3)</li> </ul>"},{"location":"components/slider/","title":"Slider","text":"<p>Slider \u00e9 um componente importante para usarmos quando precisamos de sele\u00e7\u00f5es em um intervalo de valores.</p> <p>Vamos ver uma implementa\u00e7\u00e3o b\u00e1sica abaixo, com um valueRange entre 0 e 100. <code>roundToInt()</code> est\u00e1 sendo usado no Text() para arredondar o valor do sliderPosition para um n\u00famero mais amig\u00e1vel, caso contr\u00e1rio ter\u00edamos algo como 25.2683..., o que n\u00e3o \u00e9 o que queremos no exemplo.</p> <pre><code>@Composable\nprivate fun Slider() {\n    var sliderPosition by remember { mutableFloatStateOf(0f) }\n    Column {\n        Slider(\n            value = sliderPosition,\n            onValueChange = { position -&gt;\n                sliderPosition = position\n            },\n            valueRange = 0f..100f\n        )\n        Text(\n            text = sliderPosition.roundToInt().toString(),\n            modifier = Modifier.align(Alignment.CenterHorizontally)\n        )\n    }\n}\n</code></pre> <p></p> <p>Tamb\u00e9m temos a op\u00e7\u00e3o de steps, que \u00e9 \u00fatil para o usu\u00e1rio selecionar valores entre etapas rapidamente. Por exemplo:</p> <pre><code>@Composable\nprivate fun Slider() {\n    var sliderPosition by remember { mutableFloatStateOf(0f) }\n    Column {\n        Slider(\n            ...\n            steps = 4\n        )\n        ...\n    }\n}\n</code></pre> <p></p> <p>Tamb\u00e9m temos uma outra op\u00e7\u00e3o de Slider: RangeSlider. A diferen\u00e7a nele \u00e9 que o usu\u00e1rio pode selecionar 2 valores entre intervalos.</p> <pre><code>@Composable\nprivate fun RangeSlider() {\n    var sliderPosition by remember { mutableStateOf(0f..100f) }\n    Column {\n        RangeSlider(\n            value = sliderPosition,\n            onValueChange = { position -&gt;\n                sliderPosition = position\n            },\n            valueRange = 0f..100f\n        )\n        Text(\n            text = \"Start: ${sliderPosition.start.roundToInt()} / End: ${sliderPosition.endInclusive.roundToInt()}\",\n            modifier = Modifier.align(Alignment.CenterHorizontally)\n        )\n    }\n}\n</code></pre> <p></p> <p>Ambos t\u00eam outros par\u00e2metros \u00fateis, como a colors para modificar as cores e onValueChangeFinished, que \u00e9 acionada quando o usu\u00e1rio finaliza a sele\u00e7\u00e3o. Podemos usar onValueChangeFinished para chamar alguma l\u00f3gica de neg\u00f3cio ou algo do tipo.</p>"},{"location":"components/slider/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Slider (documenta\u00e7\u00e3o)</li> <li>Sliders (Material Design 3)</li> </ul>"},{"location":"components/surface/","title":"Surface","text":"<p>Surface \u00e9 um dos primeiros componentes que temos contato, j\u00e1 que ele est\u00e1 presente no onCreate() da MainActivity ao criarmos um projeto Compose. Ele fornece uma superf\u00edcie de Material Design com alguns par\u00e2metros que podem ser usados para definir cor, borda, eleva\u00e7\u00e3o, shape etc. Cada superf\u00edcie existe em uma determinada eleva\u00e7\u00e3o, o que influencia como esse peda\u00e7o de superf\u00edcie se relaciona visualmente com outras superf\u00edcies e como essa superf\u00edcie \u00e9 modificada pela varia\u00e7\u00e3o tonal.</p>"},{"location":"components/surface/#surface-e-cores","title":"Surface e cores","text":"<p>Vamos ver um pequeno exemplo pr\u00e1tico de como o Surface pode influenciar em propriedades de seus componentes filhos, como cores. O c\u00f3digo abaixo possui 2 textos iguais com um elemento pai definindo a cor de fundo como <code>MaterialTheme.colorScheme.background</code>. Estamos usando Box no segundo exemplo, por\u00e9m poderia ser qualquer outro tipo de layout.</p> <pre><code>@Composable\nprivate fun Surface() {\n    Column(\n        modifier = Modifier\n            .background(Color(0xFF1A237E))\n            .padding(12.dp)\n    ) {\n        Surface(color = MaterialTheme.colorScheme.background) {\n            Text(\n                text = \"Texto com Surface\",\n                modifier = Modifier.padding(8.dp)\n            )\n        }\n        Spacer(Modifier.height(20.dp))\n        Box(modifier = Modifier.background(MaterialTheme.colorScheme.background)) {\n            Text(\n                text = \"Texto sem Surface\",\n                modifier = Modifier.padding(8.dp)\n            )\n        }\n    }\n}\n</code></pre> <p>Agora, dependendo do tema atual (dark ou light) e de como as cores do seu tema estiverem definidas, a cor do texto que est\u00e1 sobre o Surface ir\u00e1 se comportar de maneira diferente da cor do texto sobre o Box.</p> <ul> <li>Tema definido como dark:</li> </ul> <p></p> <ul> <li>Tema definido como light:</li> </ul> <p></p> <p>Perceba que a cor do texto no Box n\u00e3o muda, enquanto o texto no Surface \u00e9 alternada. De acordo com a documenta\u00e7\u00e3o: \"Se nenhum contentColor for definida, Surface tentar\u00e1 combinar sua cor de fundo com uma cor definida no ColorScheme do tema e retornar\u00e1 a cor do conte\u00fado correspondente. Por exemplo, se a cor do Surface for ColorScheme.surface, contentColor ser\u00e1 definido como ColorScheme.onSurface. Se a cor n\u00e3o fizer parte da paleta do tema, contentColor manter\u00e1 o mesmo valor definido acima desta Surface.\"</p> <p>Ou seja, o que aconteceu \u00e9 que o Text() no Surface est\u00e1 definindo a cor como <code>MaterialTheme.colorScheme.onBackground</code>, j\u00e1 que definimos a cor do Surface como <code>MaterialTheme.colorScheme.background</code>.</p>"},{"location":"components/surface/#tela-inteira","title":"Tela inteira","text":"<p>Agora que j\u00e1 vimos um exemplo simples, vamos criar uma tela inteira e adicionar uma fun\u00e7\u00e3o para alternar entre o tema dark e light ao tocar num \u00edcone para ver como o Surface pode influenciar nas caracter\u00edsticas do design. Vamos criar uma tela b\u00e1sica de login com componentes que j\u00e1 vimos antes, ent\u00e3o n\u00e3o h\u00e1 nada a comentar sobre o c\u00f3digo:</p> <pre><code>@Composable\nfun LoginScreen(onThemeChange: () -&gt; Unit) {\n    var email by remember { mutableStateOf(\"\") }\n    var password by remember { mutableStateOf(\"\") }\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(26.dp)\n    ) {\n        TextField(\n            value = email,\n            onValueChange = { email = it },\n            label = {\n                Text(text = \"E-mail\")\n            },\n            modifier = Modifier.fillMaxWidth()\n        )\n        Spacer(Modifier.height(12.dp))\n        TextField(\n            value = password,\n            onValueChange = { password = it },\n            label = {\n                Text(text = \"Senha\")\n            },\n            modifier = Modifier.fillMaxWidth()\n        )\n        Spacer(Modifier.height(18.dp))\n        Button(\n            onClick = {},\n            contentPadding = PaddingValues(12.dp),\n            modifier = Modifier.fillMaxWidth()\n        ) {\n            Text(text = \"Login\")\n        }\n        Spacer(Modifier.height(18.dp))\n        IconButton(onClick = onThemeChange) {\n            Icon(\n                painter = painterResource(id = R.drawable.baseline_dark_mode_24),\n                contentDescription = null,\n                modifier = Modifier\n                    .size(38.dp)\n            )\n        }\n    }\n}\n</code></pre> <p>Agora, modifique o onCreate() da MainActivity para adicionar essa tela:</p> <pre><code>class MainActivity : ComponentActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            var darkTheme by remember { mutableStateOf(false) }\n            MyAppTheme(darkTheme = darkTheme) {\n                Surface(\n                    modifier = Modifier.fillMaxSize(),\n                    color = MaterialTheme.colorScheme.background\n                ) {\n                    LoginScreen(onThemeChange = { darkTheme = !darkTheme })\n                }\n            }\n        }\n    }\n}\n</code></pre> <p></p> <p>Como pode ver, est\u00e1 funcionando tudo corretamente. As cores se adaptam de acordo com o tema, mesmo que n\u00e3o tenhamos definido explicitamente algumas delas para alguns componentes. Agora vamos remover o Surface e ver como fica:</p> <pre><code>class MainActivity : ComponentActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            var darkTheme by remember { mutableStateOf(false) }\n            MyAppTheme(darkTheme = darkTheme) {\n                LoginScreen(onThemeChange = { darkTheme = !darkTheme })\n            }\n        }\n    }\n}\n</code></pre> <p></p> <p>Como \u00e9 poss\u00edvel observar, o mesmo resultado n\u00e3o \u00e9 atingido e agora temos algumas inconsist\u00eancias no tema do app.</p> <p>Por conta dessas caracter\u00edsticas, \u00e9 recomendado utilizar Surface como pai de nosso conte\u00fado Compose no onCreate().</p>"},{"location":"components/surface/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Surface (documenta\u00e7\u00e3o)</li> </ul>"},{"location":"components/text/","title":"Componentes importantes","text":"<p>Componentes obviamente s\u00e3o uma parte fundamental de qualquer app e nessa se\u00e7\u00e3o voc\u00ea ver\u00e1 alguns dos mais importantes que podem ser usados no Compose. J\u00e1 vimos os componentes Text() e Image() em algumas se\u00e7\u00f5es anteriores, mas nessa veremos outros de uma maneira um pouco mais ampla.</p> <p>Todos os componentes possuem diversos par\u00e2metros e op\u00e7\u00f5es de personaliza\u00e7\u00e3o, ent\u00e3o obviamente n\u00e3o abordaremos todos eles. Voc\u00ea pode navegar no componente espec\u00edfico ou colocar seu mouse sobre a fun\u00e7\u00e3o do componente para ver os par\u00e2metros.</p>"},{"location":"components/text/#estado-no-compose","title":"Estado no Compose","text":"<p>Um conceito extremamente importante antes de aprendermos sobre os componentes \u00e9 o conceito de estado no Compose. H\u00e1 uma se\u00e7\u00e3o sobre isso mais a frente. Ela poderia ser facilmente uma das primeiras se\u00e7\u00f5es desse conte\u00fado, mas por quest\u00f5es de conveni\u00eancia, eu preferi deixar ela um pouco para depois. Estando mais familiarizado com componentes, fun\u00e7\u00f5es Composable e o mundo do Compose na pr\u00e1tica com elementos visuais, acredito que fica mais f\u00e1cil entender e absorver melhor a se\u00e7\u00e3o sobre estados. Se preferir, voc\u00ea pode l\u00ea-la antes de se introduzir nos componentes Composable.</p>"},{"location":"components/text/#recursos","title":"Recursos","text":"<p>Antes de falarmos sobre o Text() e outros componentes, \u00e9 importante tamb\u00e9m sabermos que podemos usar recursos criados no projeto com facilidade. Recursos s\u00e3o arquivos adicionais e conte\u00fado est\u00e1tico que seu c\u00f3digo usa, como bitmaps, strings, instru\u00e7\u00f5es de anima\u00e7\u00e3o e muito mais. Dois tipos de recursos bastante utilizados s\u00e3o os de strings e os de cores. Compose oferece algumas fun\u00e7\u00f5es Composable simples para isso, veja nos exemplos abaixo:</p> <ul> <li><code>Text(text = stringResource(R.string.compose))</code></li> <li><code>Text(text = stringResource(R.string.congratulate, \"New Year\", 2024))</code></li> <li><code>Divider(color = colorResource(R.color.purple_200))</code></li> </ul> <p>Veja a documenta\u00e7\u00e3o para saber um pouco mais.</p>"},{"location":"components/text/#text","title":"Text","text":"<p>O componente Text() n\u00e3o tem muitos segredos, ent\u00e3o vamos ver apenas alguns poucos exemplos. Voc\u00ea pode ver os conte\u00fados auxiliares para aplicar mais personaliza\u00e7\u00f5es nos textos.</p> <pre><code>@Composable\nprivate fun Text() {\n    Text(\n        text = \"Jetpack Compose\",\n        color = Color.Blue,\n        fontSize = 16.sp,\n        fontWeight = FontWeight.Bold,\n        fontFamily = FontFamily.SansSerif,\n        letterSpacing = 4.sp\n    )\n}\n</code></pre> <p></p>"},{"location":"components/text/#parametro-overflow-e-modifierbasicmarquee","title":"Par\u00e2metro overflow e Modifier.basicMarquee()","text":"<p>\u00c0s vezes, temos textos longos demais e queremos aplicar algum pequeno efeito para indicar isso. O par\u00e2metro overlow no Text() pode ser usada para aplicar o efeito de retic\u00eancias (...) quando o texto for muito extenso e n\u00e3o couber na tela, se definirmos ele com TextOverflow.Ellipsis. Seguindo a mesma ideia, temos o <code>Modifier.basicMarquee()</code>, que pode ser usado para aplicar uma anima\u00e7\u00e3o de rolagem de texto. Ele n\u00e3o necessariamente funciona apenas com textos e ainda \u00e9 experimental, por isso devemos usar a anota\u00e7\u00e3o no c\u00f3digo abaixo, por\u00e9m, pode ser bastante \u00fatil em alguns casos.</p> <p>Para que ambos fa\u00e7am sentido, \u00e9 necess\u00e1rio tamb\u00e9m definir o n\u00famero m\u00e1ximo de linhas do Text() com o par\u00e2metro maxLines. Veja o pequeno exemplo abaixo:</p> <pre><code>@OptIn(ExperimentalFoundationApi::class)\n@Composable\nprivate fun LongText() {\n    val longText = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam eget ligula\" +\n            \" eu lectus lobortis condimentum. Aliquam nonummy auctor massa.\"\n    Column(\n        modifier = Modifier\n            .background(Color.Black)\n            .padding(12.dp)\n    ) {\n        Text(\n            text = longText,\n            color = Color.White,\n            fontSize = 18.sp,\n            fontStyle = FontStyle.Italic,\n            maxLines = 1,\n            overflow = TextOverflow.Ellipsis\n        )\n        Spacer(Modifier.height(16.dp))\n        Text(\n            text = longText,\n            color = Color.White,\n            fontSize = 18.sp,\n            fontStyle = FontStyle.Italic,\n            maxLines = 1,\n            modifier = Modifier.basicMarquee()\n        )\n    }\n}\n</code></pre> <p></p> <ul> <li><code>Modifier.basicMarquee()</code> possui alguns outros par\u00e2metros interessantes, como mudar o n\u00famero m\u00e1ximo de itera\u00e7\u00f5es, velocidade etc. No exemplo, n\u00e3o definimos nenhum deles para fins de conveni\u00eancia.</li> </ul>"},{"location":"components/text/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Style text (documenta\u00e7\u00e3o)</li> </ul>"},{"location":"components/textfield/","title":"TextField","text":"<p>No TextField voc\u00ea come\u00e7ar\u00e1 a ver conceitos interessantes que se repetir\u00e3o bastante no Compose. Vamos falar sobre alguns deles antes de ver os exemplos de c\u00f3digo.</p> <ul> <li>Como se trata de um campo de texto edit\u00e1vel, o TextField usar\u00e1 o que j\u00e1 falamos no come\u00e7o sobre estados (o texto) e eventos (quando o usu\u00e1rio digitar algo). No exemplo do c\u00f3digo, temos uma linha importante: <code>var text by remember { mutableStateOf(\"\") }</code>. Basicamente essa vari\u00e1vel ser\u00e1 lida como um estado que, ao ser modificada, acionar\u00e1 a recomposi\u00e7\u00e3o. Ou seja, o texto do TextField mudar\u00e1. Veremos explica\u00e7\u00f5es melhores sobre isso na se\u00e7\u00e3o sobre estados.</li> <li>TextField tem diversos par\u00e2metros que recebem como argumentos fun\u00e7\u00f5es Composable. Por exemplo, label. Ao inv\u00e9s de passarmos apenas uma String ou algo do tipo, podemos colocar o componente Text() ou o que quisermos de Composable. Isso \u00e9 muito \u00fatil no Compose e j\u00e1 vimos isso v\u00e1rias vezes na se\u00e7\u00e3o de layouts de forma impl\u00edcita. Por exemplo, Column tem como \u00faltimo par\u00e2metro uma Composable: <code>content: @Composable() (ColumnScope.() -&gt; Unit)</code>.</li> <li>Ele usa o padr\u00e3o de state hoisting (eleva\u00e7\u00e3o de estado). Recebe o valor com value e, quando esse valor muda, aciona onValueChange com o novo valor. Esse mesmo comportamento se repetir\u00e1 em v\u00e1rios outros componentes que voc\u00ea ver\u00e1 nessa se\u00e7\u00e3o. Tamb\u00e9m veremos mais disso na se\u00e7\u00e3o sobre estados.</li> </ul> <p>Vamos ao exemplo de um TextField:</p> <pre><code>@Composable\nprivate fun TextField() {\n    var text by remember { mutableStateOf(\"\") }\n    TextField(\n        value = text,\n        onValueChange = { newText -&gt;\n            text = newText\n        },\n        label = {\n            Text(text = \"Label\")\n        },\n        colors = TextFieldDefaults.colors(\n            unfocusedIndicatorColor = Color.Blue,\n            unfocusedLabelColor = Color.Blue\n        )\n    )\n}\n</code></pre> <p></p> <p>Se trocarmos o par\u00e2metro label por placeholder, quando digitarmos algo, o placeholder n\u00e3o ir\u00e1 aparecer:</p> <p></p> <p>Tamb\u00e9m temos v\u00e1rias outras op\u00e7\u00f5es, como leadingIcon, trailingIcon e keyboardOptions:</p> <pre><code>@Composable\nprivate fun TextField() {\n    var text by remember { mutableStateOf(\"\") }\n    TextField(\n        value = text,\n        onValueChange = { newText -&gt;\n            text = newText\n        },\n        label = {\n            Text(text = \"E-mail\")\n        },\n        leadingIcon = {\n            Icon(\n                imageVector = Icons.Default.Email,\n                contentDescription = \"Email icon\"\n            )\n        },\n        trailingIcon = {\n            IconButton(onClick = { text = \"\" }) {\n                Icon(\n                    imageVector = Icons.Default.Close,\n                    contentDescription = \"Close icon\"\n                )\n            }\n        },\n        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Email),\n        colors = TextFieldDefaults.colors(\n            unfocusedIndicatorColor = Color.Blue,\n            focusedLabelColor = Color.Blue\n        )\n    )\n}\n</code></pre> <p></p>"},{"location":"components/textfield/#e-bom-lembrar","title":"\u00c9 bom lembrar...","text":"<p>Veja que usamos 2 \u00edcones. N\u00f3s poder\u00edamos definir as cores desses \u00edcones com o par\u00e2metro tint, mas n\u00e3o fizemos isso no exemplo acima. No TextField, evite modificar as cores de componentes como esse diretamente. Atrav\u00e9s da op\u00e7\u00e3o colors do TextField, voc\u00ea pode alterar as cores do leadingIcon e trailingIcon, tanto nos estados focused quanto unfocused, assim como foi feito na unfocusedIndicatorColor. Se adicionarmos uma cor manualmente ao Icon(), perderemos essa fun\u00e7\u00e3o de cores din\u00e2micas nesses 2 estados do TextField.</p>"},{"location":"components/textfield/#outlinedtextfield","title":"OutlinedTextField","text":"<p>Tamb\u00e9m temos a varia\u00e7\u00e3o do TextField: OutlinedTextField. Basta mudar o nome TextField para OutlinedTextField que o estilo mudar\u00e1. No exemplo abaixo, tamb\u00e9m usamos uma transforma\u00e7\u00e3o de texto em formato de senha com visualTransformation.</p> <pre><code>@Composable\nprivate fun OutlinedTextField() {\n    var text by remember { mutableStateOf(\"\") }\n    OutlinedTextField(\n        value = text,\n        onValueChange = { newText -&gt;\n            text = newText\n        },\n        label = {\n            Text(text = \"Senha\")\n        },\n        visualTransformation = PasswordVisualTransformation(),\n        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password),\n        colors = TextFieldDefaults.colors(\n            unfocusedIndicatorColor = Color.Blue,\n            unfocusedLabelColor = Color.Blue,\n            unfocusedContainerColor = Color.White\n        )\n    )\n}\n</code></pre> <p></p> <p>Voc\u00ea tamb\u00e9m pode mudar o shape do TextField com o par\u00e2metro shape, como por exemplo: <code>shape = CircleShape</code>.</p> <p></p>"},{"location":"components/textfield/#basictextfield-e-basictextfield2","title":"BasicTextField e BasicTextField2","text":"<p>Compose tamb\u00e9m oferece a op\u00e7\u00e3o de BasicTextField, que \u00e9 basicamente um TextField sem decora\u00e7\u00f5es que pode ser usado quando voc\u00ea quiser personalizar um TextField completamente. As op\u00e7\u00f5es que voc\u00ea viu acima s\u00e3o fornecidas atrav\u00e9s do pacote do Material Design 3, que implementa nativamente diretrizes do Material Design 3, enquanto o BasicTextField \u00e9 do androidx.compose.foundation.text. As implementa\u00e7\u00f5es do Material Design 3 s\u00e3o mais recomendadas e ser\u00e3o suficientes na maioria das vezes. Consulte a documenta\u00e7\u00e3o caso queira saber mais sobre TextFields. N\u00e3o colocarei imagens de exemplo porque visualmente ele \u00e9 simplesmente um Text() edit\u00e1vel, mas a implementa\u00e7\u00e3o b\u00e1sica \u00e9 semelhante ao que j\u00e1 vimos.</p> <pre><code>@Composable\nprivate fun BasicTextField() {\n    var text by remember { mutableStateOf(\"\") }\n    BasicTextField(\n        value = text,\n        onValueChange = { newText -&gt;\n            text = newText\n        }\n    )\n}\n</code></pre> <p>A partir do Jetpack Compose 1.6.0, uma nova op\u00e7\u00e3o foi inclu\u00edda: BasicTextField2. Ela tem como foco corrigir alguns problemas atuais do BasicTextField, bem como adicionar algumas novas funcionalidades. Atualmente ainda est\u00e1 em fase experimental. Al\u00e9m de suportar a mesma estrutura de c\u00f3digo que vimos acima, ele tamb\u00e9m inclui uma nova estrutura onde o estado do TextField \u00e9 gerenciado internamente pelo componente. Veja a implementa\u00e7\u00e3o b\u00e1sica:</p> <pre><code>@OptIn(ExperimentalFoundationApi::class)\n@Composable\nprivate fun BasicTextField2() {\n    val textFieldState = rememberTextFieldState()\n    BasicTextField2(state = textFieldState)\n}\n</code></pre> <p>Voc\u00ea pode ler mais sobre esse novo componente nessa sequ\u00eancia de artigos: BasicTextField2: A TextField of Dreams: parte 1 e parte 2.</p>"},{"location":"components/textfield/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Text fields (Material Design 3)</li> </ul>"},{"location":"content-info/changelog/","title":"Hist\u00f3rico de altera\u00e7\u00f5es","text":"<p>Hist\u00f3rico das principais mudan\u00e7as no conte\u00fado. Note que apenas altera\u00e7\u00f5es relevantes s\u00e3o adicionadas aqui. Eventuais pequenas corre\u00e7\u00f5es de texto ou c\u00f3digo, por exemplo, n\u00e3o ser\u00e3o listadas.</p>"},{"location":"content-info/changelog/#11022024","title":"11/02/2024","text":"<ul> <li>T\u00f3picos sobre Switch e Checkbox movidos para Checkbox, RadioButton e Switch na se\u00e7\u00e3o de componentes importantes.</li> </ul>"},{"location":"content-info/changelog/#10022024","title":"10/02/2024","text":"<ul> <li>Jornada iniciada! </li> </ul>"},{"location":"content-info/contributing/","title":"Guia de Contribui\u00e7\u00e3o","text":"<p>O Jetpack Compose \u00e9 atualizado constantemente e manter um conte\u00fado sobre ele no mesmo ritmo pode ser desafiador. N\u00e3o importa se voc\u00ea est\u00e1 apenas come\u00e7ando ou j\u00e1 \u00e9 experiente no Compose, sua ajuda para manter esse conte\u00fado atualizado e com uma qualidade minimamente razo\u00e1vel \u00e9 muito bem-vinda!</p>"},{"location":"content-info/contributing/#como-posso-contribuir","title":"Como posso contribuir?","text":"<p>O reposit\u00f3rio principal n\u00e3o aceita pull requests. Para contribuir com esse projeto, voc\u00ea pode fazer isso atrav\u00e9s de issues. Para manter minha pr\u00f3pria linha de racioc\u00ednio e explica\u00e7\u00f5es, bem como c\u00f3digos, screenshots, demos etc., n\u00e3o \u00e9 permitido abrir pull requests adicionando novos conte\u00fados ou corrigindo conte\u00fados atuais.</p> <p>H\u00e1 diversas coisas que podem ficar desatualizadas com o tempo e enquanto voc\u00ea estiver lendo o conte\u00fado, pode perceber isso. Por exemplo, v\u00e1rias se\u00e7\u00f5es possuem links para partes espec\u00edficas da documenta\u00e7\u00e3o, al\u00e9m de refer\u00eancias para artigos externos, o que podem quebrar com o tempo.</p>"},{"location":"content-info/contributing/#contribuindo-com-sugestoes","title":"Contribuindo com sugest\u00f5es","text":"<p>Voc\u00ea pode contribuir fazendo sugest\u00f5es diversas. Por exemplo, se estiver lendo uma se\u00e7\u00e3o e acreditar que ela pode ser melhorada adicionando exemplo X ou Y, abra uma issue adicionando o c\u00f3digo desejado para que eu possa atualizar futuramente.</p>"},{"location":"content-info/contributing/#lista-de-coisas-mais-comuns-que-voce-pode-notar-e-contribuir","title":"Lista de coisas mais comuns que voc\u00ea pode notar e contribuir:","text":"<ul> <li>Palavras escritas erradas;</li> <li>Links quebrados;</li> <li>Erros de c\u00f3digo;</li> <li>Melhoria/atualiza\u00e7\u00e3o em c\u00f3digo existente.</li> </ul>"},{"location":"layouts/box/","title":"Box","text":"<p>Diferente de Column e Row, Box n\u00e3o alinha os elementos em uma dire\u00e7\u00e3o vertical ou horizontal. Cada elemento ser\u00e1 colocado um sobre o outro, semelhante ao que acontece quando n\u00e3o especificamos um layout. Algo tamb\u00e9m similar ao que temos no FramewLayout, com cada componente sobrepondo o outro em uma esp\u00e9cie de camadas.</p> <p>A diferen\u00e7a principal \u00e9 que voc\u00ea pode aplicar o alinhamento de cada componente manualmente com mais flexibilidade, atrav\u00e9s do <code>Modifier.align()</code>. Diferente da Column, por exemplo, voc\u00ea n\u00e3o est\u00e1 preso a um alinhamento horizontal. Veja:</p> <pre><code>@Composable\nfun BoxExample() {\n    Box(modifier = Modifier.size(200.dp)) {\n        Text(\n            text = \"Top start\",\n            modifier = Modifier.align(Alignment.TopStart)\n        )\n        Text(\n            text = \"Top end\",\n            modifier = Modifier.align(Alignment.TopEnd)\n        )\n        Text(\n            text = \"Center\",\n            modifier = Modifier.align(Alignment.Center)\n        )\n        Text(\n            text = \"Bottom start\",\n            modifier = Modifier.align(Alignment.BottomStart)\n        )\n        Text(\n            text = \"Bottom end\",\n            modifier = Modifier.align(Alignment.BottomEnd)\n        )\n    }\n}\n</code></pre> <p></p> <p>Veja um exemplo de layout b\u00e1sico que pode ser criado utilizando Box e como ele pode ser \u00fatil:</p> <pre><code>@Composable\nfun VideoItem() {\n    Box(\n        modifier = Modifier\n            .width(200.dp)\n            .height(100.dp)\n    ) {\n        Image(\n            painter = painterResource(id = R.drawable.img_sample),\n            contentDescription = \"Video image\",\n            contentScale = ContentScale.Crop,\n            modifier = Modifier\n                .fillMaxSize()\n        )\n        Icon(\n            painter = painterResource(id = R.drawable.baseline_play_circle_outline_24),\n            contentDescription = \"Play icon\",\n            tint = Color.White,\n            modifier = Modifier\n                .size(50.dp)\n                .align(Alignment.Center),\n        )\n        Text(\n            text = \"15:23\",\n            color = Color.White,\n            fontSize = 12.sp,\n            modifier = Modifier\n                .background(Color.Black)\n                .padding(2.dp)\n                .align(Alignment.BottomEnd)\n        )\n    }\n}\n</code></pre> <p></p> <p>Lembre-se que a ordem dos componentes importa, pois cada componente ser\u00e1 colocado um sobre o outro. Portanto, se trocarmos a posi\u00e7\u00e3o do Icon() e Image() do exemplo acima, deixando Icon() em primeiro e Image() em segundo, o \u00edcone n\u00e3o ser\u00e1 exibido na tela. Isso acontece porque a imagem sobrep\u00f5es o \u00edcone, j\u00e1 que ela est\u00e1 ocupando todo o espa\u00e7o com <code>Modifier.fillMaxSize()</code>, enquanto o \u00edcone est\u00e1 usando um tamanho fixo de 50.dp e em uma camada inferior a da imagem.</p> <ul> <li>Box tamb\u00e9m tem uma op\u00e7\u00e3o de alinhamento: contentAlignment. O padr\u00e3o \u00e9 <code>Alignment.TopStart</code>. Ao definir contentAlignment como <code>Alignment.Center</code>, por exemplo, os componentes ainda ser\u00e3o colocados uns sobre os outros, mas iniciando no centro.</li> </ul>"},{"location":"layouts/box/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Compose layout basics (documenta\u00e7\u00e3o)</li> </ul>"},{"location":"layouts/column/","title":"Layouts","text":"<p>Construir seus layouts \u00e9 obviamente uma parte fundamental em qualquer app. Essa se\u00e7\u00e3o descreve um pouco sobre o layout Column.</p>"},{"location":"layouts/column/#sem-layout","title":"Sem layout","text":"<p>Sem especificar um layout, os componentes Composable v\u00e3o ser colocados uns sobre os outros, deixando completamente desorganizado. Veja um exemplo:</p> <pre><code>@Composable\nfun Profile() {\n    Image(\n        painter = painterResource(id = R.drawable.baseline_person_24),\n        contentDescription = \"Profile image\",\n        modifier = Modifier.size(50.dp)\n    )\n    Text(text = \"John\")\n}\n</code></pre> <p></p>"},{"location":"layouts/column/#column","title":"Column","text":"<p>Como o nome sugere, uma Column \u00e9 uma esp\u00e9cie de coluna onde cada elemento \u00e9 colocado um abaixo do outro, verticalmente. \u00c9 o equivalente a um LinearLayout com a orienta\u00e7\u00e3o vertical. Vamos usar o c\u00f3digo anterior e envolv\u00ea-lo em uma Column para ver como fica:</p> <pre><code>@Composable\nfun Profile() {\n    Column {\n        Image(\n            painter = painterResource(id = R.drawable.baseline_person_24),\n            contentDescription = \"Profile image\",\n            modifier = Modifier.size(50.dp)\n        )\n        Text(text = \"John\")\n    }\n}\n</code></pre> <p></p>"},{"location":"layouts/column/#alinhamento-de-uma-column","title":"Alinhamento de uma Column","text":"<p>Uma Column possui mais 2 par\u00e2metros que podem ser usados para alinhar o conte\u00fado horizontal e vertical. Veja como ficaria o alinhamento horizontal ao modificar o horizontalAlignment:</p> Alignment.StartAlignment.CenterHorizontallyAlignment.End <p></p> <pre><code>@Composable\nfun Profile() {\n    Column(\n       horizontalAlignment = Alignment.Start,\n       modifier = Modifier.width(250.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p></p> <pre><code>@Composable\nfun Profile() {\n    Column(\n       horizontalAlignment = Alignment.CenterHorizontally,\n       modifier = Modifier.width(250.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p></p> <pre><code>@Composable\nfun Profile() {\n    Column(\n       horizontalAlignment = Alignment.End,\n       modifier = Modifier.width(250.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p>E, claro, tamb\u00e9m podemos modificar o verticalArrangement.</p> Arrangement.TopArrangement.CenterArrangement.BottomArrangement.SpaceBetween <p></p> <pre><code>@Composable\nfun Profile() {\n    Column(\n       verticalArrangement = Arrangement.Top,\n       modifier = Modifier.size(150.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p></p> <pre><code>@Composable\nfun Profile() {\n    Column(\n       verticalArrangement = Arrangement.Center,\n       modifier = Modifier.size(150.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p></p> <pre><code>@Composable\nfun Profile() {\n    Column(\n       verticalArrangement = Arrangement.Bottom,\n       modifier = Modifier.size(150.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p></p> <pre><code>@Composable\nfun Profile() {\n    Column(\n       verticalArrangement = Arrangement.SpaceBetween,\n       modifier = Modifier.size(150.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p>Tamb\u00e9m podemos fazer uma combina\u00e7\u00f5es de verticalArrangement e horizontalAlignment para deixar todo o conte\u00fado centralizado verticalmente e horizontalmente, por exemplo.</p> <pre><code>@Composable\nfun Profile() {\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier.size(150.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p></p>"},{"location":"layouts/column/#modificando-o-alinhamento-manualmente-em-cada-componente","title":"Modificando o alinhamento manualmente em cada componente","text":"<p>Tamb\u00e9m \u00e9 poss\u00edvel modificar o alinhamento dos componentes diretamente atrav\u00e9s do <code>Modifier.align()</code>. Por exemplo, ao inv\u00e9s de usarmos <code>horizontalAlignment = Alignment.CenterHorizontally</code> na Column em si, podemos obter o mesmo resultado aplicando <code>Modifier.align()</code> em cada componente:</p> <pre><code>@Composable\nfun Profile() {\n    Column(\n        modifier = Modifier.width(250.dp)\n    ) {\n        Image(\n            painter = painterResource(id = R.drawable.baseline_person_24),\n            contentDescription = \"Profile image\",\n            modifier = Modifier\n                .size(50.dp)\n                .align(Alignment.CenterHorizontally)\n        )\n        Text(\n            text = \"John\",\n            modifier = Modifier.align(Alignment.CenterHorizontally)\n        )\n    }\n}\n</code></pre> <p></p> <ul> <li>\u00c9 importante notar que dentro da Column s\u00f3 podemos modificar o alinhamento horizontal dessa forma. Se tentarmos aplicar <code>Alignment.Bottom</code>, por exemplo, voc\u00ea ver\u00e1 um erro, pois <code>Modifier.align()</code> espera um <code>Alignment.Horizontal</code> e n\u00e3o um <code>Alignment.Vertical</code>, como \u00e9 o caso de <code>Alignment.Bottom</code>. Tamb\u00e9m vale ressaltar que <code>Modifier.align()</code> tem prioridade sobre o horizontalAlignment da Column. Portanto, se voc\u00ea usar <code>horizontalAlignment = Alignment.End</code> na Column, mas <code>Modifier.align(Alignment.Start)</code> no componente, ele ser\u00e1 alinhado com <code>Alignment.Start</code>.</li> </ul>"},{"location":"layouts/column/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Compose layout basics (documenta\u00e7\u00e3o)</li> </ul>"},{"location":"layouts/constraintlayout/","title":"ConstraintLayout","text":"<p>ConstraintLayout tem um comportamento similar ao que vemos no ConstraintLayout do XML. Ele permite posicionar Composables em rela\u00e7\u00e3o a outros Composables. Uma das principais diferen\u00e7as entre ele e os demais layouts citados anteriormente \u00e9 que para utiliz\u00e1-lo voc\u00ea precisa importar sua depend\u00eancia no build.gradle (app) (confira a vers\u00e3o atual na documenta\u00e7\u00e3o):</p> <pre><code>implementation(\"androidx.constraintlayout:constraintlayout-compose:$version\")\n</code></pre>"},{"location":"layouts/constraintlayout/#quando-usar","title":"Quando usar","text":"<p>De acordo com a documenta\u00e7\u00e3o oficial, considere usar ConstraintLayout nos seguintes cen\u00e1rios:</p> <ul> <li>Para evitar o aninhamento de v\u00e1rios Columns e Rows para posicionar elementos na tela para melhorar a legibilidade do c\u00f3digo.</li> <li>Para posicionar Composables em rela\u00e7\u00e3o a outros Composables ou para posicionar Composables com base em guidelines, barriers ou chains.</li> </ul> <p>\u00c9 importante notar que no sistema de Views, ConstraintLayout era a maneira recomendada de criar layouts grandes e complexos, j\u00e1 que uma hierarquia de Views plana era melhor para o desempenho do que Views aninhadas, como v\u00e1rios LinearLayouts. No entanto, isso n\u00e3o \u00e9 uma preocupa\u00e7\u00e3o no Compose, que \u00e9 capaz de lidar com efici\u00eancia com hierarquias profundas de layout e voc\u00ea n\u00e3o precisa se preocupar com o aninhamento de Columns, Rows e Box em quest\u00e3o de desempenho.</p>"},{"location":"layouts/constraintlayout/#utilizacao","title":"Utiliza\u00e7\u00e3o","text":"<p>ConstraintLayout no Compose funciona da seguinte forma:</p> <ul> <li>Voc\u00ea cria refer\u00eancias para cada Composable usando <code>createRefs()</code> ou <code>createRefFor()</code>;</li> <li>As restri\u00e7\u00f5es s\u00e3o fornecidas usando o <code>Modifier.constrainAs()</code> no Composable desejado, que toma a refer\u00eancia como par\u00e2metro e permite especificar suas restri\u00e7\u00f5es no lambda: <code>Modifier.constrainAs() { // restri\u00e7\u00f5es }</code>;</li> <li>As restri\u00e7\u00f5es s\u00e3o especificadas usando <code>linkTo()</code> ou outros m\u00e9todos \u00fateis;</li> <li><code>parent</code> \u00e9 uma refer\u00eancia existente que pode ser usada para especificar restri\u00e7\u00f5es para o pr\u00f3prio <code>ConstraintLayout</code>.</li> </ul> <p>Vamos reutilizar um pouco do que j\u00e1 fizemos nos layouts anteriores e ver isso na pr\u00e1tica.</p>"},{"location":"layouts/constraintlayout/#usando-como-uma-column","title":"Usando como uma Column","text":"<p>O c\u00f3digo abaixo ter\u00e1 o mesmo resultado de uma Column, como fizemos no exemplo que vimos na se\u00e7\u00e3o de Column:</p> <pre><code>@Composable\nfun Profile() {\n    ConstraintLayout {\n        // Refer\u00eancias\n        val (profileImage, profileName) = createRefs()\n\n        Image(\n            painter = painterResource(id = R.drawable.baseline_person_24),\n            contentDescription = \"Profile image\",\n            modifier = Modifier\n                .size(50.dp)\n                // Atribui a refer\u00eancia \"profileImage\" a esse Composable Image()\n                .constrainAs(profileImage) {\n                    // Especificamos as constraints, onde \"parent\" \u00e9 o pr\u00f3prio ConstraintLayout\n                    top.linkTo(parent.top)\n                    start.linkTo(parent.start)\n                }\n        )\n\n        Text(\n            text = \"John\",\n            modifier = Modifier\n                .constrainAs(profileName) {\n                    top.linkTo(profileImage.bottom)\n                }\n        )\n    }\n}\n</code></pre> <p></p>"},{"location":"layouts/constraintlayout/#usando-como-uma-row","title":"Usando como uma Row","text":"<p>Se alterarmos a constraint do Text() para <code>start.linkTo(profileImage.end)</code> no c\u00f3digo acima, teremos o mesmo resultado de uma Row:</p> <pre><code>@Composable\nfun Profile() {\n    ConstraintLayout {\n        ...\n        Text(\n            text = \"John\",\n            modifier = Modifier\n                .constrainAs(profileName) {\n                    start.linkTo(profileImage.end)\n                }\n        )\n    }\n}\n</code></pre> <p></p>"},{"location":"layouts/constraintlayout/#usando-como-um-box","title":"Usando como um Box","text":"<p>Tamb\u00e9m podemos fazer com o ConstraintLayout o mesmo layout que fizemos com Box anteriormente. Isso acontece porque ConstraintLayout tamb\u00e9m n\u00e3o coloca os elementos em uma dire\u00e7\u00e3o espec\u00edfica, mas uns sobre os outros se n\u00e3o adicionarmos constraints que mudem isso. Veja o exemplo:</p> <pre><code>@Composable\nfun VideoItem() {\n    ConstraintLayout(\n        modifier = Modifier\n            .width(200.dp)\n            .height(100.dp)\n    ) {\n        val (videoImage, playIcon, duration) = createRefs()\n        Image(\n            painter = painterResource(id = R.drawable.img_sample),\n            contentDescription = \"Video image\",\n            contentScale = ContentScale.Crop,\n            modifier = Modifier\n                .fillMaxSize()\n                .constrainAs(videoImage) {\n                    start.linkTo(parent.start)\n                }\n        )\n        Icon(\n            painter = painterResource(id = R.drawable.baseline_play_circle_outline_24),\n            contentDescription = \"Play icon\",\n            tint = Color.White,\n            modifier = Modifier\n                .size(50.dp)\n                .constrainAs(playIcon) {\n                    start.linkTo(videoImage.start)\n                    end.linkTo(videoImage.end)\n                    top.linkTo(videoImage.top)\n                    bottom.linkTo(videoImage.bottom)\n                }\n        )\n        Text(\n            text = \"15:23\",\n            color = Color.White,\n            fontSize = 12.sp,\n            modifier = Modifier\n                .background(Color.Black)\n                .padding(2.dp)\n                .constrainAs(duration) {\n                    bottom.linkTo(videoImage.bottom)\n                    end.linkTo(videoImage.end)\n                }\n        )\n    }\n}\n</code></pre> <p></p>"},{"location":"layouts/constraintlayout/#conclusao","title":"Conclus\u00e3o","text":"<p>Nos exemplos, vimos que em grande parte podemos fazer com ConstraintLayout o mesmo que fazemos com outros layouts. Isso n\u00e3o significa que esse seja o objetivo dele e voc\u00ea deva sempre utilizar ConstraintLayout para tudo. Sempre considere se \u00e9 necess\u00e1rio utiliz\u00e1-lo e se ele atende suas necessidades. Normalmente, na maioria das vezes, voc\u00ea ir\u00e1 utilizar combina\u00e7\u00f5es de Column, Row e Box.</p>"},{"location":"layouts/constraintlayout/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>ConstraintLayout in Compose (documenta\u00e7\u00e3o)</li> </ul>"},{"location":"layouts/row/","title":"Row","text":"<p>Enquanto uma Column alinha os elementos um abaixo do outro de forma vertical, uma Row alinha um ao lado do outro, de forma horizontal. \u00c9 o equivalente a um LinearLayout com a orienta\u00e7\u00e3o horizontal.</p> <pre><code>@Composable\nfun Profile() {\n    Row {\n        Image(\n            painter = painterResource(id = R.drawable.baseline_person_24),\n            contentDescription = \"Profile image\",\n            modifier = Modifier.size(50.dp)\n        )\n        Text(text = \"John\")\n    }\n}\n</code></pre> <p></p>"},{"location":"layouts/row/#alinhamento-de-uma-row","title":"Alinhamento de uma Row","text":"<p>Assim como a Column, Row possui mais 2 par\u00e2metros que podem ser usados para alinhar o conte\u00fado. Vamos modificar o horizontalArrangement e ver como fica:</p> Arrangement.StartArrangement.CenterArrangement.EndArrangement.SpaceBetweenArrangement.SpaceEvenly <p></p> <pre><code>@Composable\nfun Profile() {\n    Row(\n       horizontalArrangement = Arrangement.Start,\n       modifier = Modifier.width(150.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p></p> <pre><code>@Composable\nfun Profile() {\n    Row(\n       horizontalArrangement = Arrangement.Center,\n       modifier = Modifier.width(150.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p></p> <pre><code>@Composable\nfun Profile() {\n    Row(\n       horizontalArrangement = Arrangement.End,\n       modifier = Modifier.width(150.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p></p> <pre><code>@Composable\nfun Profile() {\n    Row(\n       horizontalArrangement = Arrangement.SpaceBetween,\n       modifier = Modifier.width(150.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p></p> <pre><code>@Composable\nfun Profile() {\n    Row(\n       horizontalArrangement = Arrangement.SpaceEvenly,\n       modifier = Modifier.width(150.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p>Tamb\u00e9m podemos fazer uma combina\u00e7\u00e3o de horizontalArrangement e verticalAlignment para deixar todo o conte\u00fado centralizado, por exemplo.</p> <pre><code>@Composable\nfun Profile() {\n    Row(\n        horizontalArrangement = Arrangement.Center,\n        verticalAlignment = Alignment.CenterVertically,\n        modifier = Modifier.size(150.dp)\n    ) {\n        ...\n    }\n}\n</code></pre> <p></p>"},{"location":"layouts/row/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Compose layout basics (documenta\u00e7\u00e3o)x</li> </ul>"},{"location":"screens/navigation/","title":"Navega\u00e7\u00e3o","text":"<p>J\u00e1 criamos as duas telas principais no t\u00f3pico anterior, ent\u00e3o agora veremos uma forma de navegar entre elas.</p>"},{"location":"screens/navigation/#navigation-component","title":"Navigation Component","text":"<p>O Navigation Component \u00e9 bem conhecido no sistema de Views e tamb\u00e9m possui uma vers\u00e3o para Compose. Por ser o componente oficial de navega\u00e7\u00e3o, vamos utiliz\u00e1-lo. \u00c9 importante saber que existem diversas alternativas para atingir essa fun\u00e7\u00e3o, como por exemplo as bibliotecas Voyager e Decompose, que inclusive oferecem alguns recursos a mais que o Navigation Component n\u00e3o possui.</p> <p>Antes de tudo, adicione a depend\u00eancia do Navigation Component (cheque a vers\u00e3o atual na documenta\u00e7\u00e3o):</p> <pre><code>implementation(\"androidx.navigation:navigation-compose:$version\")\n</code></pre> <p>Existem 3 conceitos principais no Navigation Component:</p> <ul> <li>Navigation Graph: Uma estrutura de dados que define todos os destinos de navega\u00e7\u00e3o no aplicativo e como eles se conectam. No caso desse projeto de exemplo, o arquivo AppNavHost que vamos criar mais a frente ser\u00e1 nosso gr\u00e1fico de navega\u00e7\u00e3o.</li> <li>NavHost: O componente principal onde faz refer\u00eancia a um NavController, assim como define um destino inicial. Ele tamb\u00e9m \u00e9 respons\u00e1vel por conter as composable() (extension function de NavGraphBuilder) que s\u00e3o usadas para compor as telas do app. Cada tela \u00e9 um destino e possui uma rota exclusiva do tipo String.</li> <li>NavController: O coordenador central para gerenciar a navega\u00e7\u00e3o entre destinos. O NavController oferece m\u00e9todos para navegar entre destinos, lidar com deep links, gerenciar backstack e muito mais.</li> </ul>"},{"location":"screens/navigation/#organizando","title":"Organizando","text":"<p>Seguindo o que j\u00e1 v\u00ednhamos fazendo, vamos criar um novo pacote chamado navigation. Mais uma vez, essa organiza\u00e7\u00e3o \u00e9 opcional e voc\u00ea pode escolher os nomes que preferir. Nesse pacote, crie dois novos arquivos, chamados AppNavHost e Screen. Veja o exemplo abaixo:</p> <pre><code>...\nnavigation:\n    AppNavHost.kt\n    Screen.kt\nscreens:\n    home:\n        HomeScreen.kt\n        ...\n    tracking:\n        TrackingScreen.kt\n        ...\n...\n</code></pre>"},{"location":"screens/navigation/#criando-a-classe-screen","title":"Criando a classe Screen","text":"<p>O que vamos ter na Screen \u00e9 nada mais do que as nossas telas, organizando com uma sealed class. Veja o c\u00f3digo dela abaixo:</p> <pre><code>const val TRACKING_CODE = \"tracking_code\"\nconst val TRACKING_CEP = \"tracking_cep\"\n\nsealed class Screen(val route: String) {\n    data object HomeScreen : Screen(\"home_screen\")\n    data object TrackingScreen : Screen(\n        \"tracking_screen/{$TRACKING_CODE}/{$TRACKING_CEP}\"\n    ) {\n        fun routeWithArgs(code: String, cep: Int) = \"tracking_screen/$code/$cep\"\n    }\n}\n</code></pre> <p>Deixei as constantes no mesmo arquivo, mas voc\u00ea pode coloc\u00e1-las em outro lugar se preferir.</p> <p>Como voc\u00ea pode observar, a Screen possui uma propriedade chamada route. Ela ser\u00e1 \u00fatil para identificar o nome da rota da tela no nosso gr\u00e1fico de navega\u00e7\u00e3o. O Navigation Component funciona por meio de \"rotas\", onde cada tela possui uma rota e para navegar para uma outra tela, n\u00f3s passamos a rota da mesma. Como a TrackingScreen \u00e9 uma tela que vai receber alguns dados, ela \u00e9 um pouco diferente, contendo tamb\u00e9m os poss\u00edveis argumentos. Tamb\u00e9m criamos nela  uma fun\u00e7\u00e3o auxiliar que cria uma rota com argumentos, que ser\u00e3o o code e cep.</p>"},{"location":"screens/navigation/#criando-o-appnavhost","title":"Criando o AppNavHost","text":"<p>Vamos ent\u00e3o criar o AppNavHost, inicialmente apenas com a HomeScreen para comentarmos por partes:</p> <pre><code>@Composable\nfun AppNavHost(navController: NavHostController) {\n    NavHost(\n        navController = navController,\n        startDestination = Screen.HomeScreen.route\n    ) {\n        composable(route = Screen.HomeScreen.route) {\n            HomeScreen(\n                onNavigateToTracking = { code, cep -&gt;\n                    navController.navigate(\n                        Screen.TrackingScreen.routeWithArgs(code, cep)\n                    )\n                }\n            )\n        }\n    }\n}\n</code></pre> <p>Vamos aos pontos importantes:</p> <ul> <li>Nosso AppNavHost faz uso da fun\u00e7\u00e3o NavHost, que possui como argumentos obrigat\u00f3rios um navController e um startDestination. \u00c9 atrav\u00e9s do NavHostController que podemos navegar de uma tela \u00e0 outra, por exemplo. J\u00e1 o startDestination, como o pr\u00f3prio nome diz, \u00e9 o destino inicial que ser\u00e1 usado por esse NavHost, que no nosso caso \u00e9 a HomeScreen.</li> <li>Dentro do NavHost, podemos utilizar a fun\u00e7\u00e3o composable(), respons\u00e1vel por definir a nossa tela. \u00c9 preciso especificar uma rota, o que fazemos definindo com a rota da HomeScreen. Ela tamb\u00e9m possui v\u00e1rios outros par\u00e2metros, como arguments e algumas op\u00e7\u00f5es de anima\u00e7\u00e3o, que vamos ver mais a frente.</li> <li>Como content da composable(), usamos a nossa HomeScreen de fato. Quando onNavigateToTracking for acionada, navegamos da HomeScreen para a TrackingScreen. Para isso utilizamos a fun\u00e7\u00e3o navigate() do NavHostController.</li> </ul> <p>Agora que j\u00e1 vimos os principais pontos, vamos finalizar o AppNavHost com a composable() da TrackingScreen:</p> <pre><code>@Composable\nfun AppNavHost(navController: NavHostController) {\n    NavHost(\n        navController = navController,\n        startDestination = Screen.HomeScreen.route\n    ) {\n        composable(route = Screen.HomeScreen.route) {\n            HomeScreen(\n                onNavigateToTracking = { code, cep -&gt;\n                    navController.navigate(\n                        Screen.TrackingScreen.routeWithArgs(code, cep)\n                    )\n                }\n            )\n        }\n\n        composable(\n            route = Screen.TrackingScreen.route,\n            arguments = listOf(\n                navArgument(name = TRACKING_CODE) {\n                    type = NavType.StringType\n                },\n                navArgument(name = TRACKING_CEP) {\n                    type = NavType.IntType\n                }\n            )\n        ) { navBackStackEntry -&gt;\n            navBackStackEntry.arguments?.let { bundle -&gt;\n                TrackingScreen(\n                    code = bundle.getString(TRACKING_CODE) ?: \"\",\n                    cep = bundle.getInt(TRACKING_CEP),\n                    onNavigateBack = { navController.popBackStack() }\n                )\n            }\n        }\n    }\n}\n</code></pre> <p>Como a TrackingScreen \u00e9 uma tela que vai receber argumentos, precisamos especificar isso atrav\u00e9s do par\u00e2metro arguments da composable(). Passamos ent\u00e3o uma lista de argumentos, onde cada um deles \u00e9 um navArgument. Como name, utilizamos as constantes que criamos antes. J\u00e1 como o type, especificamos qual \u00e9 o tipo de argumento esperado, que pode ser uma String (StringType), um Boolean (BoolType), um Int (IntType) etc. Como estamos esperando uma String para o code e um Int para o cep, especificamos ambos.</p> <p>Na chamada da TrackingScreen, temos mais alguns pontos de destaque. Para obter os argumentos, utilizamos o NavBackStackEntry dispon\u00edvel no lambda da composable(), usando navBackStackEntry.arguments. Como o Bundle retornado de navBackStackEntry.arguments pode ser nulo, fazemos uma pequena verifica\u00e7\u00e3o para evitar um NullPointerException. No onNavigateBack, chamamos navController.popBackStack(), que ir\u00e1 retornar \u00e0 tela anterior.</p>"},{"location":"screens/navigation/#adicionando-o-appnavhost-na-mainactivity","title":"Adicionando o AppNavHost na MainActivity","text":"<p>Como agora as nossas telas ser\u00e3o gerenciadas pelo AppNavHost, temos que modificar o conte\u00fado exibido no setContent do onCreate() da MainActivity. Veja o c\u00f3digo:</p> <pre><code>class MainActivity : ComponentActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyAppTheme {\n                Surface(\n                    modifier = Modifier.fillMaxSize(),\n                    color = MaterialTheme.colorScheme.background\n                ) {\n                    val navController = rememberNavController()\n                    AppNavHost(navController)\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>E \u00e9 isso! O app j\u00e1 deve se comportar devidamente com a navega\u00e7\u00e3o entre as duas telas, como pode ver na imagem abaixo.</p> <p></p>"},{"location":"screens/navigation/#usando-savedstatehandle","title":"Usando SavedStateHandle","text":"<p>Atualmente estamos obtendo os argumentos passados da HomeScreen diretamente com o NavBackStackEntry no AppNavHost, mais especificamente na composable() da rota da TrackingScreen. No entanto, existe tamb\u00e9m uma outra maneira de obter esses argumentos atrav\u00e9s do m\u00f3dulo SavedStateHandle. Vamos fazer isso e ver como as coisas mudam um pouco.</p>"},{"location":"screens/navigation/#modificando-o-trackingviewmodel","title":"Modificando o TrackingViewModel","text":"<p>Precisamos primeiro alterar o TrackingViewModel que j\u00e1 fizemos antes. Veja como ele ficar\u00e1 agora:</p> <pre><code>class TrackingViewModel(\n    private val savedStateHandle: SavedStateHandle\n) : ViewModel() {\n    private val _uiState = MutableStateFlow(\n        TrackingUiState(\n            code = savedStateHandle.get&lt;String&gt;(TRACKING_CODE) ?: \"\",\n            cep = savedStateHandle.get&lt;Int&gt;(TRACKING_CEP) ?: 0,\n        )\n    )\n    val uiState: StateFlow&lt;TrackingUiState&gt; = _uiState.asStateFlow()\n}\n</code></pre> <p>Foi adicionado a propriedade do SavedStateHandle e a fun\u00e7\u00e3o getTrackingInfo() foi removida. Como vimos na vers\u00e3o anterior, getTrackingInfo() s\u00f3 servia para inicializar o code e cep. Nessa nova vers\u00e3o, a TrackingUiState \u00e9 inicializada diretamente com os valores do SavedStateHandle atrav\u00e9s da fun\u00e7\u00e3o get(), que espera uma key para buscar o argumento. Como ela pode retornar null se n\u00e3o houver nada encontrado com a key passada, adicionamos com um valor padr\u00e3o.</p> <p>O SavedStateHandle pode ser usado de outras formas, inclusive com Flows, por\u00e9m n\u00e3o vamos ver essa abordagem aqui, pois n\u00e3o \u00e9 o caso.</p>"},{"location":"screens/navigation/#modificando-a-trackingscreen","title":"Modificando a TrackingScreen","text":"<p>Como agora vamos obter os argumentos diretamente do ViewModel, n\u00e3o precisamos mais que a TrackingScreen tenha os par\u00e2metros code e cep. Al\u00e9m disso, a abordagem para instanciar o TrackingViewModel vai mudar, pois agora ele espera um argumento SavedStateHandle. Veja como ela fica agora:</p> <pre><code>@Composable\nfun TrackingScreen(\n    onNavigateBack: () -&gt; Unit,\n    trackingViewModel: TrackingViewModel = viewModel {\n        val savedStateHandle = createSavedStateHandle()\n        TrackingViewModel(savedStateHandle)\n    }\n) {\n    val uiState by trackingViewModel.uiState.collectAsStateWithLifecycle()\n    TrackingContent(\n        uiState = uiState,\n        onNavigateBack = onNavigateBack\n    )\n}\n</code></pre> <p>Note que para utilizar a fun\u00e7\u00e3o viewModel que possui um lambda para criar o SavedStateHandle atrav\u00e9s da fun\u00e7\u00e3o createSavedStateHandle(), voc\u00ea precisa da seguinte depend\u00eancia (cheque a vers\u00e3o atual na documenta\u00e7\u00e3o):</p> <pre><code>implementation(\"androidx.lifecycle:lifecycle-viewmodel-compose:$version\")\n</code></pre> <p>Como o Navigation Component j\u00e1 inclui essa depend\u00eancia por padr\u00e3o, voc\u00ea n\u00e3o precisa adicion\u00e1-la explicitamente se n\u00e3o desejar.</p> <ul> <li>Normalmente se utiliza alguma biblioteca para inje\u00e7\u00e3o de depend\u00eancias, ent\u00e3o esse processo de instancia\u00e7\u00e3o do TrackingViewModel usando a fun\u00e7\u00e3o createSavedStateHandle() n\u00e3o seria necess\u00e1rio.</li> </ul>"},{"location":"screens/navigation/#modificando-o-appnavhost","title":"Modificando o AppNavHost","text":"<p>Agora tamb\u00e9m precisamo fazer leves altera\u00e7\u00f5es no AppNavHost, removendo os argumentos da TrackingScreen que n\u00e3o existem mais:</p> <pre><code>@Composable\nfun AppNavHost(navController: NavHostController) {\n    NavHost(\n        navController = navController,\n        startDestination = Screen.HomeScreen.route\n    ) {\n        ...\n\n        composable(\n            route = Screen.TrackingScreen.route,\n            arguments = listOf(\n                navArgument(name = TRACKING_CODE) {\n                    type = NavType.StringType\n                },\n                navArgument(name = TRACKING_CEP) {\n                    type = NavType.IntType\n                }\n            )\n        ) {\n            TrackingScreen(onNavigateBack = { navController.popBackStack() })\n        }\n    }\n}\n</code></pre>"},{"location":"screens/navigation/#adicionando-animacao-ao-navegar-entre-as-telas","title":"Adicionando anima\u00e7\u00e3o ao navegar entre as telas","text":"<p>Se voc\u00ea olhar bem a imagem demonstrando a navega\u00e7\u00e3o do app, ver\u00e1 que n\u00e3o h\u00e1 nenhuma grande anima\u00e7\u00e3o. A fun\u00e7\u00e3o composable() possui alguns par\u00e2metros para modificar as anima\u00e7\u00f5es de transi\u00e7\u00e3o, que s\u00e3o: enterTransition, exitTransition, popEnterTransition e popExitTransition, onde podemos utilizar anima\u00e7\u00f5es do tipo EnterTransition e ExitTransition.</p> <p>Vamos ver um exemplo b\u00e1sico de quando essas anima\u00e7\u00f5es s\u00e3o usadas. Digamos que a HomeScreen navegue para a TrackingScreen:</p> <ul> <li>TrackingScreen executa enterTransition.</li> <li>HomeScreen executa exitTransition.</li> </ul> <p>N\u00f3s voltamos \u00e0 tela anterior (HomeScreen), seja tocando no bot\u00e3o voltar ou no \u00edcone de arrow back:</p> <ul> <li>TrackingScreen executa popExitTransition.</li> <li>HomeScreen executa popEnterTransition.</li> </ul> <p>Agora que j\u00e1 sabemos como funciona, vamos aplicar uma pequena anima\u00e7\u00e3o de slide ao abrir e fechar a TrackingScreen. Veja como a composable() da TrackingScreen fica agora:</p> <pre><code>private const val ANIMATION_DURATION = 700\n\n@Composable\nfun AppNavHost(navController: NavHostController) {\n    NavHost(\n        ...\n    ) {\n        ...\n        composable(\n            route = Screen.TrackingScreen.route,\n            arguments = listOf(\n                navArgument(name = TRACKING_CODE) {\n                    type = NavType.StringType\n                },\n                navArgument(name = TRACKING_CEP) {\n                    type = NavType.IntType\n                }\n            ),\n            enterTransition = {\n                slideIntoContainer(\n                    towards = AnimatedContentTransitionScope.SlideDirection.Right,\n                    animationSpec = tween(durationMillis = ANIMATION_DURATION)\n                )\n            },\n            popExitTransition = {\n                slideOutOfContainer(\n                    towards = AnimatedContentTransitionScope.SlideDirection.Left,\n                    animationSpec = tween(durationMillis = ANIMATION_DURATION)\n                )\n            }\n        ) {\n            TrackingScreen(onNavigateBack = { navController.popBackStack() })\n        }\n    }\n}\n</code></pre> <p>Usamos as fun\u00e7\u00f5es slideIntoContainer() e slideOutOfContainer() fornecidas pelo Compose para criar uma anima\u00e7\u00e3o de slide com uma dire\u00e7\u00e3o. Veja o resultado:</p> <p></p> <p>Modificando para SlideDirection.Up na slideIntoContainer() e SlideDirection.Down na slideOutOfContainer(), temos o seguinte:</p> <p></p> <p>E claro, tamb\u00e9m \u00e9 poss\u00edvel utilizar anima\u00e7\u00f5es personalizadas, bem como outros tipos de anima\u00e7\u00e3o, mas para n\u00e3o se estender muito, vamos ficando por aqui nesse t\u00f3pico.</p>"},{"location":"screens/navigation/#resolvendo-um-problema-comum-de-navegacao","title":"Resolvendo um problema comum de navega\u00e7\u00e3o","text":"<p>Existe um problema no Navigation Component da navega\u00e7\u00e3o abrindo m\u00faltiplas telas ou telas em branco ao voltar com navController.popBackStack() com m\u00faltiplos cliques. No nosso c\u00f3digo atual, se o usu\u00e1rio tocar o bot\u00e3o de \"rastrear\" na HomeScreen m\u00faltiplas vezes em um curto per\u00edodo de tempo, a TrackingScreen ser\u00e1 aberta m\u00faltiplas vezes. Um outro problema similar acontece quando o \u00edcone de arrow back \u00e9 tocado m\u00faltiplas vezes na TrackingScreen e uma tela em branco \u00e9 exibida. Isso tamb\u00e9m pode acontecer com dispositivos mais lentos, onde \u00e0s vezes d\u00e3o duplo clique acidental.</p> <p>Voc\u00ea pode checar essa issue e essa para refer\u00eancia. Como antigamente s\u00f3 era poss\u00edvel navegar com anima\u00e7\u00e3o atrav\u00e9s da Navigation-Animation da Accompanist, essas issues se encontram no reposit\u00f3rio dela.</p> <p>Veja a imagem abaixo para ter ideia do problema:</p> <p></p> <p>Existem algumas formas de resolver isso. Uma delas seria desabilitar m\u00faltiplos cliques no componente em um curto per\u00edodo de tempo, mas isso pode ser complicado e n\u00e3o atinge diretamente o problema, j\u00e1 que se trata de um problema na navega\u00e7\u00e3o. Uma outra op\u00e7\u00e3o para esse caso \u00e9 criar uma fun\u00e7\u00e3o auxiliar que verifica se o status atual do Lifecycle \u00e9 Lifecycle.State.RESUMED, pois caso contr\u00e1rio, significa que esse NavBackStackEntry j\u00e1 processou um evento de navega\u00e7\u00e3o. Veja o c\u00f3digo abaixo:</p> <pre><code>private fun NavBackStackEntry.lifecycleIsResumed() =\n        this.lifecycle.currentState == Lifecycle.State.RESUMED\n</code></pre> <p>Agora basta fazer uma verifica\u00e7\u00e3o com essa fun\u00e7\u00e3o antes de navegar:</p> <pre><code>@Composable\nfun AppNavHost(navController: NavHostController) {\n    NavHost(\n       ...\n    ) {\n        composable(\n            route = Screen.HomeScreen.route,\n            ...\n        ) { navBackStackEntry -&gt;\n            HomeScreen(\n                onNavigateToTracking = { code, cep -&gt;\n                    if (navBackStackEntry.lifecycleIsResumed()) {\n                        navController.navigate(\n                            Screen.TrackingScreen.routeWithArgs(code, cep)\n                        )\n                    }\n                },\n            )\n        }\n\n        composable(\n            route = Screen.TrackingScreen.route,\n            ...\n        ) { navBackStackEntry -&gt;\n            TrackingScreen(\n                onNavigateBack = {\n                    if (navBackStackEntry.lifecycleIsResumed()) {\n                        navController.popBackStack()\n                    }\n                }\n            )\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"screens/navigation/#problema-de-argumento-com-url","title":"Problema de argumento com URL","text":"<p>Outro problema comum que pode ocorrer \u00e9 um java.lang.IllegalArgumentException ao tentar passar URLs como argumento. Digamos que tent\u00e1ssemos passar uma URL https://site.com como code e 123456 como cep no c\u00f3digo do projeto atual, ter\u00edamos a seguinte mensagem de erro crashando o app: <code>java.lang.IllegalArgumentException: Navigation destination that matches request NavDeepLinkRequest{ uri=android-app://androidx.navigation/tracking_screen/https://site.com/123456 } cannot be found in the navigation graph ComposeNavGraph</code>.</p> <p>O erro \u00e9 bem claro: a rota n\u00e3o foi encontrada no gr\u00e1fico de navega\u00e7\u00e3o. Isso n\u00e3o \u00e9 um problema particular de URLs, mas da barra (/). Como as rotas no Navigation Component funcionam num padr\u00e3o de URLs, a barra acaba interferindo na rota esperada. Pensando num conceito de navega\u00e7\u00e3o web, \u00e9 como se a nossa URL fosse https://trackingscreen.com/CODE/CEP e tent\u00e1ssemos navegar para https://trackingscreen.com/CODE///CEP, que claramente \u00e9 uma URL inv\u00e1lida.</p> <p>Para resolver isso, voc\u00ea pode codificar a URL antes de pass\u00e1-la como argumento. Por exemplo:</p> <pre><code>@Composable\nfun AppNavHost(navController: NavHostController) {\n    NavHost(\n        ...\n    ) {\n        composable(route = Screen.HomeScreen.route ) { navBackStackEntry -&gt;\n            HomeScreen(\n                onNavigateToPage = { url -&gt;\n                    if (navBackStackEntry.lifecycleIsResumed()) {\n                        val encodedUrl = URLEncoder.encode(url, \"utf-8\")\n                        navController.navigate(\n                            Screen.PageScreen.routeWithArgs(encodedUrl)\n                        )\n                    }\n                }\n            )\n        }\n        ...\n    }\n}\n</code></pre> <p>N\u00e3o \u00e9 necess\u00e1rio usar <code>URLDecoder.decode()</code> na composable() da PageScreen, pois o argumento ser\u00e1 decodificado automaticamente na navega\u00e7\u00e3o.</p>"},{"location":"screens/navigation/#conclusao","title":"Conclus\u00e3o","text":"<p>H\u00e1 v\u00e1rios outros pontos que n\u00e3o foram abordados nessa se\u00e7\u00e3o sobre Navigation Component. Voc\u00ea pode ver alguns deles na documenta\u00e7\u00e3o oficial, como argumentos opcionais e deep links.</p>"},{"location":"screens/navigation/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Navigation with Compose (documenta\u00e7\u00e3o)</li> <li>Jetpack Compose Navigation (codelab)</li> <li>Navigation in Jetpack Compose. Full guide Beginner to Advanced (artigo)</li> </ul>"},{"location":"screens/screens/","title":"Telas, ViewModels e navega\u00e7\u00e3o","text":"<p>Na grande maioria das vezes, os aplicativos possuem mais de uma tela e uma navega\u00e7\u00e3o entre elas. Nessa se\u00e7\u00e3o veremos um pouco sobre a constru\u00e7\u00e3o de um app simples com telas, uma navega\u00e7\u00e3o entre elas e tamb\u00e9m um componente muito conhecido e utilizado no Android, que \u00e9 o ViewModel.</p>"},{"location":"screens/screens/#o-que-faremos","title":"O que faremos","text":"<p>Vamos construir um app bem b\u00e1sico com apenas duas telas. Ser\u00e1 um app do tipo rastreador de encomendas, com uma tela inicial e uma tela de informa\u00e7\u00f5es sobre o rastreio. Para n\u00e3o tornar as coisas muito complexas e como esse n\u00e3o \u00e9 o objetivo dessa se\u00e7\u00e3o, n\u00e3o h\u00e1 uma funcionalidade real no app, nem conex\u00e3o com a internet ou coisas do tipo.</p> <p>Diferente das se\u00e7\u00f5es anteriores, dessa vez teremos uma pequena organiza\u00e7\u00e3o a mais. Voc\u00ea pode fazer da forma que preferir, mas vamos utilizar um padr\u00e3o bem utilizado, que \u00e9 o de um nome de pacote por tela. Primeiro criaremos um pacote screens onde ter\u00e1 mais dois pacotes representando as duas telas, home e tracking. Cada pacote ter\u00e1 um arquivo relacionado aquela tela. Veja o exemplo abaixo:</p> <pre><code>...\nscreens:\n    home:\n        HomeScreen.kt\n        HomeViewModel.kt\n        ...\n    tracking:\n        TrackingScreen.kt\n        ...\n...\n</code></pre>"},{"location":"screens/screens/#criando-as-strings","title":"Criando as strings","text":"<p>Dessa vez n\u00e3o usaremos hardcoded strings, mas colocaremos todos os textos em res/strings.xml. Abaixo est\u00e3o todas as strings que usaremos nessa se\u00e7\u00e3o.</p> <pre><code>&lt;resources&gt;\n    &lt;string name=\"app_name\"&gt;Compose Journey&lt;/string&gt;\n\n    &lt;string name=\"tracker\"&gt;Rastreador&lt;/string&gt;\n    &lt;string name=\"tracking_code\"&gt;C\u00f3digo de rastreio&lt;/string&gt;\n    &lt;string name=\"cep\"&gt;CEP&lt;/string&gt;\n    &lt;string name=\"track\"&gt;Rastrear&lt;/string&gt;\n    &lt;string name=\"tracking\"&gt;Rastreamento&lt;/string&gt;\n    &lt;string name=\"order_status\"&gt;Status: Em tr\u00e2nsito&lt;/string&gt;\n&lt;/resources&gt;\n</code></pre>"},{"location":"screens/screens/#criando-a-homescreen","title":"Criando a HomeScreen","text":"<p>Vamos come\u00e7ar criando a HomeScreen:</p> Ver c\u00f3digo da HomeScreen <pre><code>const val UndefinedCep = -1\n\n@Composable\nfun HomeScreen(onNavigateToTracking: (code: String, cep: Int) -&gt; Unit) {\n    var code by remember { mutableStateOf(\"\") }\n    var cepNumber by remember { mutableIntStateOf(UndefinedCep) }\n    val cepText: String = remember(cepNumber) {\n        if (cepNumber == UndefinedCep) \"\" else cepNumber.toString()\n    }\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp)\n    ) {\n        val verticalSpacing = 14.dp\n        Text(\n            text = stringResource(id = R.string.tracker),\n            color = MaterialTheme.colorScheme.primary,\n            fontSize = 34.sp,\n            fontWeight = FontWeight.Bold\n        )\n        Spacer(Modifier.height(verticalSpacing + verticalSpacing))\n        CommonTextField(\n            text = code,\n            onTextChange = {\n                code = it\n            },\n            label = stringResource(id = R.string.tracking_code),\n            leadingIcon = Icons.Default.Info\n        )\n        Spacer(Modifier.height(verticalSpacing))\n        CommonTextField(\n            text = cepText,\n            onTextChange = { updatedCep -&gt;\n                updatedCep.toIntOrNull()?.let { cep -&gt;\n                    cepNumber = cep\n                }\n                if (updatedCep.isBlank()) {\n                    cepNumber = UndefinedCep\n                }\n            },\n            label = stringResource(id = R.string.cep),\n            leadingIcon = Icons.Default.LocationOn,\n            keyboardType = KeyboardType.Number\n        )\n        Spacer(Modifier.height(verticalSpacing + verticalSpacing))\n        Button(\n            onClick = {\n                onNavigateToTracking.invoke(code, cepNumber)\n            },\n            contentPadding = PaddingValues(16.dp),\n            modifier = Modifier.fillMaxWidth()\n        ) {\n            Text(stringResource(id = R.string.track))\n        }\n    }\n}\n\n@Composable\nprivate fun CommonTextField(\n    text: String,\n    onTextChange: (String) -&gt; Unit,\n    label: String,\n    leadingIcon: ImageVector,\n    modifier: Modifier = Modifier,\n    keyboardType: KeyboardType = KeyboardType.Text\n) {\n    OutlinedTextField(\n        value = text,\n        onValueChange = onTextChange,\n        label = {\n            Text(text = label)\n        },\n        leadingIcon = {\n            Icon(\n                imageVector = leadingIcon,\n                contentDescription = null\n            )\n        },\n        shape = RoundedCornerShape(16.dp),\n        singleLine = true,\n        keyboardOptions = KeyboardOptions(keyboardType = keyboardType),\n        modifier = modifier.fillMaxWidth()\n    )\n}\n</code></pre> <p></p> <p>\u00c9 uma tela comum sem muitos segredos. Criamos a fun\u00e7\u00e3o CommonTextField(), sendo uma forma de componentizar o OutlinedTextField expondo apenas algumas das op\u00e7\u00f5es de personaliza\u00e7\u00f5es que fazem sentido pra gente nesse contexto, al\u00e9m de usar o padr\u00e3o de state hoisting que j\u00e1 vimos antes. Um destaque que vale a pena mencionar na HomeScreen() \u00e9 o uso da CommonTextField() de CEP com uma pequena l\u00f3gica para impedir a inser\u00e7\u00e3o de outros caracteres que n\u00e3o sejam n\u00fameros para um CEP. Mesmo definindo <code>keyboardType = KeyboardType.Number</code>, o usu\u00e1rio ainda pode colar ou digitar caracteres como pontos (.), v\u00edrgulas (,) etc., ent\u00e3o desejamos evitar isso.</p> <p>Outro ponto importante \u00e9 o lambda onNavigateToTracking como par\u00e2metro da HomeScreen(). Voc\u00ea ver\u00e1 mais sobre ele mais a frente, quando chegarmos no t\u00f3pico sobre navega\u00e7\u00e3o. Mas a princ\u00edpio, a utilidade dele \u00e9 ser invocado quando quisermos navegar da HomeScreen() para a TrackingScreen(), que tamb\u00e9m criaremos mais a frente. Como pode ver, ele \u00e9 invocado no onClick do Button() de rastrear.</p>"},{"location":"screens/screens/#viewmodel-e-state-holder","title":"ViewModel e state holder","text":"<p>Digamos que voc\u00ea precise validar o CEP ou at\u00e9 mesmo o c\u00f3digo de rastreio, seja verificando se possuem determinada quantidade de caracteres ou se s\u00e3o v\u00e1lidos de acordo com alguma l\u00f3gica de neg\u00f3cios vinda de uma API, por exemplo. Uma solu\u00e7\u00e3o bem comum seria fazer isso atrav\u00e9s de um ViewModel.</p> <p>Um ViewModel ajuda a abstrair a l\u00f3gica de neg\u00f3cios e tamb\u00e9m pode ser detentora de estado (state holder) no n\u00edvel de tela. Ele exp\u00f5e o estado \u00e0 UI e encapsula a l\u00f3gica de neg\u00f3cios relacionada. Sua principal vantagem \u00e9 que ele armazena em cache o estado e o persiste durante altera\u00e7\u00f5es de configura\u00e7\u00e3o, como rota\u00e7\u00e3o de tela.</p> <p>Pensando na nossa ideia de app, em outras palavras o ViewModel seria uma ponte entre os dados da tela e uma l\u00f3gica de neg\u00f3cios, em, por exemplo, um esquema do tipo: HomeScreen &lt;--&gt; HomeViewModel &lt;--&gt; TrackingRepository, onde ao tocar no bot\u00e3o rastrear da HomeScreen, chamar\u00edamos uma fun\u00e7\u00e3o do HomeViewModel, que por sua vez chamaria uma fun\u00e7\u00e3o do TrackingRepository para obter alguma informa\u00e7\u00e3o, retornando essa informa\u00e7\u00e3o para o HomeViewModel e posteriormente atualizando a UI da HomeScreen. No projeto que vamos fazer, esse \"esquema\" n\u00e3o faz muito sentido, pois ao tocar no bot\u00e3o rastrear, vamos navegar para a TrackingScreen.</p> <ul> <li>\u00c9 prov\u00e1vel que voc\u00ea j\u00e1 tenha conhecimento sobre ViewModel e algum padr\u00e3o de arquitetura, como MVVM, por\u00e9m, achei interessante deixar essa pequena introdu\u00e7\u00e3o. N\u00e3o teremos nada relacionado a reposit\u00f3rios ou busca de dados em uma API nessa se\u00e7\u00e3o, pois esse n\u00e3o \u00e9 o objetivo.</li> </ul>"},{"location":"screens/screens/#uistate-e-uievent","title":"UiState e UiEvent","text":"<p>Antes de tudo, precisamos elevar o estado da nossa HomeScreen para que possa ser usado posteriormente pelo HomeViewModel. Vamos fazer isso criando uma data class HomeUiState e, al\u00e9m dela, uma sealed class HomeUiEvent, representando os dados e eventos \u00fateis da tela. Veja o c\u00f3digo de ambas abaixo:</p> <pre><code>const val UndefinedCep = -1\n\ndata class HomeUiState(\n    val code: String = \"\",\n    val cep: Int = UndefinedCep\n) {\n    val cepText: String = if (cep == UndefinedCep) \"\" else cep.toString()\n    val canNavigateToTrackingScreen: Boolean = code.isNotBlank() &amp;&amp; cepText.isNotBlank()\n}\n\nsealed class HomeUiEvent {\n    data class CodeChanged(val code: String) : HomeUiEvent()\n    data class CepChanged(val cep: Int) : HomeUiEvent()\n}\n</code></pre> <p>Na HomeUiState, n\u00f3s temos mais uma propriedade a mais do que vimos antes, que \u00e9 a canNavigateToTrackingScreen. O nome dela diz tudo, mas basicamente ser\u00e1 usada apenas para habilitar ou desabilitar o bot\u00e3o de rastrear, respons\u00e1vel por navegar para a pr\u00f3xima tela. Precisamos de um cep do tipo String porque TextField s\u00f3 funciona com Strings (cep poderia ser do tipo String e evitar\u00edamos ter cepText, mas para fins de exemplo, vamos manter como est\u00e1). Tamb\u00e9m inicializamos code e cep com valores padr\u00e3o. \u00c9 \u00fatil sempre inicializar os dados com valores padr\u00e3o para facilitar a cria\u00e7\u00e3o posteriormente.</p> <p>J\u00e1 a HomeUiEvent ser\u00e1 \u00fatil para encapsular a l\u00f3gica de eventos que podem acontecer na nossa tela. No caso, a mudan\u00e7a nos valores de code e cep. Tamb\u00e9m h\u00e1 o evento de navegar para a pr\u00f3xima tela que ocorre com o toque no bot\u00e3o de rastrear, mas n\u00e3o vamos incluir ele por aqui. Essa classe far\u00e1 mais sentido quando criarmos o HomeViewModel e reconstruir a HomeScreen logo abaixo.</p>"},{"location":"screens/screens/#criando-o-homeviewmodel","title":"Criando o HomeViewModel","text":"<p>Agora vamos criar o HomeViewModel que serve como o state holder da nossa HomeScreen:</p> <pre><code>class HomeViewModel : ViewModel() {\n    private val _uiState = MutableStateFlow(HomeUiState())\n    val uiState: StateFlow&lt;HomeUiState&gt; = _uiState.asStateFlow()\n\n    fun onUiEvent(event: HomeUiEvent) {\n        when (event) {\n            is HomeUiEvent.CodeChanged -&gt; {\n                _uiState.update { it.copy(code = event.code) }\n            }\n            is HomeUiEvent.CepChanged -&gt; {\n                _uiState.update { it.copy(cep = event.cep) }\n            }\n        }\n    }\n}\n</code></pre> <p>Estamos utilizando StateFlow para armazenar o estado da UI. Poderia ser feito de diversas outras formas, inclusive com mutableState(), mas vamos usar a abordagem com Flow. Como \u00fanica fun\u00e7\u00e3o, temos onUiEvent(). Como n\u00e3o podemos modificar o estado da UI diretamente pela HomeScreen ao utilizarmos essa abordagem, encapsulamos essa l\u00f3gica no ViewModel e tornamos essa tarefa um pouco mais f\u00e1cil. Outro padr\u00e3o comum poderia ser criar uma fun\u00e7\u00e3o para modificar cada estado, como onCodeChanged(newCode: String), mas tamb\u00e9m n\u00e3o vamos por esse caminho, j\u00e1 que \u00e9 praticamente o mesmo com pequenas diferen\u00e7as. Chamaremos onUiEvent sempre que necess\u00e1rio na HomeScreen.</p>"},{"location":"screens/screens/#refazendo-a-homescreen","title":"Refazendo a HomeScreen","text":"<p>Como agora o estado da tela est\u00e1 no HomeViewModel, temos que fazer algumas altera\u00e7\u00f5es na HomeScreen. A primeira delas \u00e9 criar uma nova fun\u00e7\u00e3o chamada HomeContent que ter\u00e1 um c\u00f3digo bem similar ao que j\u00e1 vimos antes, por\u00e9m, dessa vez utilizando a HomeUiState e HomeUiEvent. Basicamente ela ter\u00e1 o conte\u00fado principal da HomeScreen, recebendo o estado e expondo os eventos.</p> Ver c\u00f3digo da HomeContent <pre><code>@Composable\nfun HomeContent(\n    uiState: HomeUiState,\n    onUiEvent: (HomeUiEvent) -&gt; Unit,\n    onNavigateToTracking: () -&gt; Unit\n) {\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp)\n    ) {\n        val verticalSpacing = 14.dp\n        Text(\n            text = stringResource(id = R.string.tracker),\n            color = MaterialTheme.colorScheme.primary,\n            fontSize = 34.sp,\n            fontWeight = FontWeight.Bold\n        )\n        Spacer(Modifier.height(verticalSpacing + verticalSpacing))\n        CommonTextField(\n            text = uiState.code,\n            onTextChange = {\n                onUiEvent.invoke(HomeUiEvent.CodeChanged(it))\n            },\n            label = stringResource(id = R.string.tracking_code),\n            leadingIcon = Icons.Default.Info\n        )\n        Spacer(Modifier.height(verticalSpacing))\n        CommonTextField(\n            text = uiState.cepText,\n            onTextChange = { updatedCep -&gt;\n                updatedCep.toIntOrNull()?.let { cep -&gt;\n                    onUiEvent.invoke(HomeUiEvent.CepChanged(cep))\n                }\n                if (updatedCep.isBlank()) {\n                    onUiEvent.invoke(HomeUiEvent.CepChanged(UndefinedCep))\n                }\n            },\n            label = stringResource(id = R.string.cep),\n            leadingIcon = Icons.Default.LocationOn,\n            keyboardType = KeyboardType.Number\n        )\n        Spacer(Modifier.height(verticalSpacing + verticalSpacing))\n        Button(\n            onClick = onNavigateToTracking,\n            contentPadding = PaddingValues(16.dp),\n            enabled = uiState.canNavigateToTrackingScreen,\n            modifier = Modifier.fillMaxWidth()\n        ) {\n            Text(text = stringResource(id = R.string.track))\n        }\n    }\n}\n</code></pre> <p>Como pode ver, n\u00e3o estamos usando o HomeViewModel ainda. Agora vamos refazer a HomeScreen que usar\u00e1 o HomeViewModel e a HomeContent. Veja o c\u00f3digo completo:</p> Ver c\u00f3digo da HomeScreen <pre><code>@Composable\nfun HomeScreen(\n    onNavigateToTracking: (code: String, cep: Int) -&gt; Unit,\n    homeViewModel: HomeViewModel = viewModel()\n) {\n    val uiState by homeViewModel.uiState.collectAsStateWithLifecycle()\n    HomeContent(\n        uiState = uiState,\n        onUiEvent = homeViewModel::onUiEvent,\n        onNavigateToTracking = {\n            onNavigateToTracking.invoke(uiState.code, uiState.cep)\n        }\n    )\n}\n\n@Composable\nfun HomeContent(\n    uiState: HomeUiState,\n    onUiEvent: (HomeUiEvent) -&gt; Unit,\n    onNavigateToTracking: () -&gt; Unit\n) {\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(24.dp)\n    ) {\n        val verticalSpacing = 14.dp\n        Text(\n            text = stringResource(id = R.string.tracker),\n            color = MaterialTheme.colorScheme.primary,\n            fontSize = 34.sp,\n            fontWeight = FontWeight.Bold\n        )\n        Spacer(Modifier.height(verticalSpacing + verticalSpacing))\n        CommonTextField(\n            text = uiState.code,\n            onTextChange = {\n                onUiEvent.invoke(HomeUiEvent.CodeChanged(it))\n            },\n            label = stringResource(id = R.string.tracking_code),\n            leadingIcon = Icons.Default.Info\n        )\n        Spacer(Modifier.height(verticalSpacing))\n        CommonTextField(\n            text = uiState.cepText,\n            onTextChange = { updatedCep -&gt;\n                updatedCep.toIntOrNull()?.let { cep -&gt;\n                    onUiEvent.invoke(HomeUiEvent.CepChanged(cep))\n                }\n                if (updatedCep.isBlank()) {\n                    onUiEvent.invoke(HomeUiEvent.CepChanged(UndefinedCep))\n                }\n            },\n            label = stringResource(id = R.string.cep),\n            leadingIcon = Icons.Default.LocationOn,\n            keyboardType = KeyboardType.Number\n        )\n        Spacer(Modifier.height(verticalSpacing + verticalSpacing))\n        Button(\n            onClick = onNavigateToTracking,\n            contentPadding = PaddingValues(16.dp),\n            enabled = uiState.canNavigateToTrackingScreen,\n            modifier = Modifier.fillMaxWidth()\n        ) {\n            Text(text = stringResource(id = R.string.track))\n        }\n    }\n}\n\n@Composable\nprivate fun CommonTextField(\n    text: String,\n    onTextChange: (String) -&gt; Unit,\n    label: String,\n    leadingIcon: ImageVector,\n    modifier: Modifier = Modifier,\n    keyboardType: KeyboardType = KeyboardType.Text\n) {\n    OutlinedTextField(\n        value = text,\n        onValueChange = onTextChange,\n        label = {\n            Text(text = label)\n        },\n        leadingIcon = {\n            Icon(\n                imageVector = leadingIcon,\n                contentDescription = null\n            )\n        },\n        shape = RoundedCornerShape(16.dp),\n        singleLine = true,\n        keyboardOptions = KeyboardOptions(keyboardType = keyboardType),\n        modifier = modifier.fillMaxWidth()\n    )\n}\n</code></pre> <p>Na fun\u00e7\u00e3o HomeScreen, instanciamos o HomeViewModel e observamos o estado da UI coletando o StateFlow de uiState com a fun\u00e7\u00e3o collectAsStateWithLifecycle(). Qualquer altera\u00e7\u00e3o no estado da UI ir\u00e1 refletir na HomeContent. Lembre-se que para utilizar essa fun\u00e7\u00e3o, \u00e9 necess\u00e1rio importar a depend\u00eancia abaixo (cheque a vers\u00e3o atual na documenta\u00e7\u00e3o):</p> <pre><code>implementation(\"androidx.lifecycle:lifecycle-runtime-compose:$version\")\n</code></pre>"},{"location":"screens/screens/#por-que-criar-duas-funcoes-homescreen-e-homecontent","title":"Por que criar duas fun\u00e7\u00f5es, HomeScreen e HomeContent?","text":"<p>N\u00e3o \u00e9 o caso nesse projeto, mas normalmente o ViewModel usa algumas classes com inje\u00e7\u00e3o de depend\u00eancias, utilizando alguma biblioteca para isso, como Hilt. Por exemplo, o nosso HomeViewModel poderia ser algo como abaixo:</p> <pre><code>@HiltViewModel\nclass HomeViewModel @Inject constructor(\n    private val trackingRepository: TrackingRepository\n) : ViewModel() {\n    // Restante do c\u00f3digo\n}\n</code></pre> <p>Nesse cen\u00e1rio bem comum, Previews t\u00eam uma limita\u00e7\u00e3o em rela\u00e7\u00e3o a ViewModels. Se criarmos todo o conte\u00fado da tela e ao mesmo tempo instanciarmos o ViewModel na mesma fun\u00e7\u00e3o, n\u00f3s obter\u00edamos um erro ao tentar visualizar o layout com Preview e o layout n\u00e3o seria exibido. Em resumo, isso \u00e9 feito principalmente para tornar as Previews acess\u00edveis e tamb\u00e9m facilitar passar dados mais controlados para a tela em outros casos, como testes e as pr\u00f3prias Previews.</p> <p>O Now in Android segue um padr\u00e3o similar, mas tendo nomenclaturas com sufixo Route e Screen. Por exemplo, HomeRoute e HomeScreen. Os nomes das fun\u00e7\u00f5es ficam a seu crit\u00e9rio, \u00e9 claro.</p>"},{"location":"screens/screens/#criando-a-trackingscreen-trackingviewmodel-e-trackinguistate","title":"Criando a TrackingScreen, TrackingViewModel e TrackingUiState","text":"<p>Agora que j\u00e1 vimos alguns dos conceitos b\u00e1sicos que estamos usando, vamos criar a TrackingScreen, TrackingViewModel e TrackingUiState. Antes de tudo, crie um novo pacote chamado tracking onde esses arquivos ser\u00e3o criados, assim como j\u00e1 discutimos antes sobre a organiza\u00e7\u00e3o.</p> Ver c\u00f3digo da TrackingScreen <pre><code>@Composable\nfun TrackingScreen(\n    code: String,\n    cep: Int,\n    onNavigateBack: () -&gt; Unit,\n    trackingViewModel: TrackingViewModel = viewModel()\n) {\n    val uiState by trackingViewModel.uiState.collectAsStateWithLifecycle()\n    LaunchedEffect(Unit) {\n        trackingViewModel.getTrackingInfo(code = code, cep = cep)\n    }\n    TrackingContent(\n        uiState = uiState,\n        onNavigateBack = onNavigateBack\n    )\n}\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nprivate fun TrackingContent(\n    uiState: TrackingUiState,\n    onNavigateBack: () -&gt; Unit\n) {\n    Scaffold(\n        topBar = {\n            CenterAlignedTopAppBar(\n                title = { Text(text = stringResource(id = R.string.tracking)) },\n                colors = TopAppBarDefaults.topAppBarColors(\n                    containerColor = MaterialTheme.colorScheme.primary,\n                    titleContentColor = MaterialTheme.colorScheme.onPrimary,\n                    navigationIconContentColor = MaterialTheme.colorScheme.onPrimary\n                ),\n                navigationIcon = {\n                    IconButton(onClick = onNavigateBack) {\n                        Icon(\n                            imageVector = Icons.AutoMirrored.Default.ArrowBack,\n                            contentDescription = null\n                        )\n                    }\n                }\n            )\n        }\n    ) { paddingValues -&gt;\n        MainContent(\n            uiState = uiState,\n            modifier = Modifier.padding(paddingValues)\n        )\n    }\n}\n\n@Composable\nprivate fun MainContent(\n    uiState: TrackingUiState,\n    modifier: Modifier = Modifier\n) {\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = modifier\n            .fillMaxSize()\n            .padding(24.dp)\n    ) {\n        Card(\n            shape = RoundedCornerShape(16.dp),\n            modifier = Modifier.padding(12.dp)\n        ) {\n            Column(\n                horizontalAlignment = Alignment.CenterHorizontally,\n                modifier = Modifier.padding(24.dp)\n            ) {\n                Text(\n                    text = stringResource(id = R.string.tracking_code),\n                    fontSize = 16.sp,\n                    fontWeight = FontWeight.Normal\n                )\n                Spacer(Modifier.height(2.dp))\n                Text(\n                    text = uiState.code,\n                    fontSize = 22.sp,\n                    fontWeight = FontWeight.Bold,\n                    textAlign = TextAlign.Center\n                )\n                Spacer(Modifier.height(16.dp))\n                Text(\n                    text = stringResource(id = R.string.cep),\n                    fontSize = 16.sp,\n                    fontWeight = FontWeight.Normal\n                )\n                Spacer(Modifier.height(2.dp))\n                Text(\n                    text = uiState.cep.toString(),\n                    fontSize = 22.sp,\n                    fontWeight = FontWeight.Bold,\n                    textAlign = TextAlign.Center\n                )\n            }\n        }\n        Spacer(Modifier.height(16.dp))\n        Row(verticalAlignment = Alignment.CenterVertically) {\n            Icon(\n                imageVector = Icons.Default.LocationOn,\n                contentDescription = null\n            )\n            Spacer(Modifier.width(6.dp))\n            Text(\n                text = stringResource(id = R.string.order_status),\n                fontSize = 18.sp,\n                fontWeight = FontWeight.Normal,\n                textAlign = TextAlign.Center\n            )\n        }\n    }\n}\n</code></pre> <p></p> <p>A TrackingScreen n\u00e3o possui nada do que j\u00e1 n\u00e3o vimos antes, mas como destaque, \u00e9 poss\u00edvel perceber que ela possui 2 par\u00e2metros, code e cep, que s\u00e3o os que iremos passar quando navegar da HomeScreen, al\u00e9m do onNavigateBack, que ser\u00e1 acionado quando o \u00edcone de arrow back for tocado para voltar \u00e0 tela anterior. Ela tamb\u00e9m utiliza uma fun\u00e7\u00e3o do TrackingViewModel chamada getTrackingInfo(), que veremos posteriormente que \u00e9 apenas uma forma de inicializar o estado da tela. Estamos usando LaunchedEffect(Unit) para que essa fun\u00e7\u00e3o seja chamada apenas na primeira composi\u00e7\u00e3o da tela.</p> <p>\u00c9 importante notar que em um cen\u00e1rio real, onde getTrackingInfo() fosse uma fun\u00e7\u00e3o que busca informa\u00e7\u00f5es em um reposit\u00f3rio com base no c\u00f3digo de rastreio e cep e devesse ser chamada apenas na primeira vez que a tela \u00e9 exibida, cham\u00e1-la dessa forma com LaunchedEffect(Unit) talvez n\u00e3o fosse o mais ideal, pois a fun\u00e7\u00e3o ainda seria chamada em rota\u00e7\u00f5es de tela e buscaria os dados novamente. Mas funciona bem como exemplo.</p> <pre><code>class TrackingViewModel : ViewModel() {\n    private val _uiState = MutableStateFlow(TrackingUiState())\n    val uiState: StateFlow&lt;TrackingUiState&gt; = _uiState.asStateFlow()\n\n    fun getTrackingInfo(\n        code: String,\n        cep: Int\n    ) {\n        _uiState.update { it.copy(code = code, cep = cep) }\n    }\n}\n</code></pre> <p>TrackingViewModel tamb\u00e9m n\u00e3o tem nada demais, ent\u00e3o pouparei os coment\u00e1rios.</p> <pre><code>data class TrackingUiState(\n    val code: String = \"\",\n    val cep: Int = 0\n)\n</code></pre> <p>Existe uma pequena observa\u00e7\u00e3o sobre a TrackingUiState. Como pode ver, ela \u00e9 bastante parecida com a HomeUiState. Normalmente ela teria mais propriedades, como por exemplo, uma para especificar o estado atual da tela, seja loading, success ou error, j\u00e1 que na teoria essa tela iria buscar informa\u00e7\u00f5es de algum dado remoto e isso demoraria um pouco para ser exibido, podendo tamb\u00e9m ocasionar em erro. Mas para fins de simplifica\u00e7\u00e3o, n\u00e3o teremos nada disso. Como tamb\u00e9m n\u00e3o teremos nenhum evento muito importante e esses dados n\u00e3o v\u00e3o mudar, n\u00e3o faremos uma TrackingUiEvent aqui.</p>"},{"location":"screens/screens/#conclusao","title":"Conclus\u00e3o","text":"<p>Chegamos ao fim do t\u00f3pico sobre telas e ViewModels. No pr\u00f3ximo t\u00f3pico dessa se\u00e7\u00e3o, veremos finalmente a navega\u00e7\u00e3o entre essas duas telas, onde a HomeScreen ir\u00e1 passar os dados code e cep para a TrackingScreen.</p>"},{"location":"side-effects/disposableeffect/","title":"Disposable Effect","text":"<p>Para side effects que precisam ser limpos ap\u00f3s uma mudan\u00e7a nos valores das keys ou se o Composable sair da composi\u00e7\u00e3o, use DisposableEffect. Ele \u00e9 um pouco semelhante ao LaunchedEffect, que aceita um n\u00famero vari\u00e1vel de keys e reinicia o efeito caso o valor de uma das keys mude, por\u00e9m, possui uma cl\u00e1usula onDispose final obrigat\u00f3ria que pode ser usada para fazer a limpeza, liberar recursos, remover eventos de listeners etc. </p> <p>Veja um exemplo simples retirado da pr\u00f3pria documenta\u00e7\u00e3o oficial, que pode ser usado para enviar eventos anal\u00edticos com base em eventos do Lifecycle usando um LifecycleObserver:</p> <pre><code>@Composable\nprivate fun LifecycleObserver(\n    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,\n    onStart: () -&gt; Unit,\n    onStop: () -&gt; Unit,\n) {\n    // Atualiza com seguran\u00e7a os lambdas atuais quando um novo \u00e9 fornecido\n    val currentOnStart by rememberUpdatedState(onStart)\n    val currentOnStop by rememberUpdatedState(onStop)\n\n    // Se `lifecycleOwner` mudar, descarta e reinicia o efeito\n    DisposableEffect(lifecycleOwner) {\n        val observer = LifecycleEventObserver { _, event -&gt;\n            if (event == Lifecycle.Event.ON_START) {\n                currentOnStart()\n            } else if (event == Lifecycle.Event.ON_STOP) {\n                currentOnStop()\n            }\n        }\n\n        // Adiciona o observer ao ciclo de vida\n        lifecycleOwner.lifecycle.addObserver(observer)\n\n        // Quando o efeito deixar a composi\u00e7\u00e3o, remove o observer\n        onDispose {\n            lifecycleOwner.lifecycle.removeObserver(observer)\n        }\n    }\n}\n</code></pre>"},{"location":"side-effects/disposableeffect/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Side-effects in Compose (documenta\u00e7\u00e3o)</li> <li>How to Use DisposableEffect in Jetpack Compose (artigo)</li> </ul>"},{"location":"side-effects/launchedeffect/","title":"Side Effects","text":"<p>Um side effect (efeito colateral) \u00e9 uma mudan\u00e7a no estado do aplicativo que ocorre fora do escopo de uma fun\u00e7\u00e3o Composable. Devido ao ciclo de vida e \u00e0s propriedades dos Composables, como recomposi\u00e7\u00f5es imprevis\u00edveis, execu\u00e7\u00e3o de recomposi\u00e7\u00f5es de Composables em ordens diferentes ou recomposi\u00e7\u00f5es que podem ser descartadas (como falamos na se\u00e7\u00e3o de conhecimentos b\u00e1sicos iniciais), o ideal \u00e9 que fun\u00e7\u00f5es Composable sejam livres de efeitos colaterais.</p> <p>No entanto, efeitos colaterais \u00e0s vezes s\u00e3o necess\u00e1rios. Por exemplo, para desencadear um evento \u00fanico, como mostrar um Snackbar ou navegar para outra tela dada uma determinada condi\u00e7\u00e3o de estado. Essas a\u00e7\u00f5es devem ser chamadas a partir de um ambiente controlado que esteja ciente do ciclo de vida do Composable.</p>"},{"location":"side-effects/launchedeffect/#launchedeffect","title":"LaunchedEffect","text":"<p>Para chamar suspend functions dentro de uma fun\u00e7\u00e3o Composable, podemos utilizar o LaunchedEffect. Quando LaunchedEffect entrar na composi\u00e7\u00e3o, ele lan\u00e7a uma coroutine com o bloco de c\u00f3digo passado como par\u00e2metro. A coroutine ser\u00e1 cancelada se o LaunchedEffect sair da composi\u00e7\u00e3o.</p> <p>Vamos ver um exemplo simples, que pode n\u00e3o ser o mais ideal em um projeto \"real\", mas que pode exemplificar bem um uso do LaunchedEffect. Temos uma classe ProfileDataSource com uma suspend function getProfileName(). Por fim, temos uma Composable Profile() respons\u00e1vel por exibir um loading ou texto de sucesso, exibindo o nome de perfil obtido atrav\u00e9s da getProfileName(), ou um texto de erro. Obviamente, isso n\u00e3o \u00e9 poss\u00edvel no cen\u00e1rio comum de uma fun\u00e7\u00e3o Composable, pois n\u00e3o podemos simplesmente chamar getProfileName() na Profile(). Primeiro, porque \u00e9 uma suspend function, e, segundo, porque ela seria chamada in\u00fameras vezes devido a recomposi\u00e7\u00e3o. Veja o exemplo de c\u00f3digo:</p> <pre><code>class ProfileDataSource {\n\n    suspend fun getProfileName(): String {\n        delay(3000L)\n        return \"Compose Journey\"\n    }\n}\n\nenum class State {\n    Loading,\n    Success,\n    Error\n}\n\n@Composable\nprivate fun Profile() {\n    val profileDataSource = remember { ProfileDataSource() }\n    var state by remember { mutableStateOf(State.Loading) }\n    var profileName by remember { mutableStateOf(\"\") }\n\n    // Isso n\u00e3o \u00e9 poss\u00edvel\n    profileName = profileDataSource.getProfileName()\n\n    Column(\n        verticalArrangement = Arrangement.Center,\n        horizontalAlignment = Alignment.CenterHorizontally,\n        modifier = Modifier.fillMaxSize()\n    ) {\n        when (state) {\n            State.Loading -&gt; {\n                CircularProgressIndicator(color = Color.Blue)\n            }\n            State.Success -&gt; {\n                Text(text = \"Nome do perfil: $profileName\")\n            }\n            State.Error -&gt; {\n                Text(text = \"Erro ao obter o nome do perfil.\")\n            }\n        }\n    }\n}\n</code></pre> <p>Para resolver esse problema, podemos utilizar o LaunchedEffect:</p> <pre><code>@Composable\nprivate fun Profile() {\n    val profileDataSource = remember { ProfileDataSource () }\n    var state by remember { mutableStateOf(State.Loading) }\n    var profileName by remember { mutableStateOf(\"\") }\n\n    LaunchedEffect(Unit) {\n        profileName = profileDataSource.getProfileName()\n        state = State.Success\n    }\n\n    ...\n}\n</code></pre> <p>Dessa forma, obtemos o nome do perfil e fazemos a atualiza\u00e7\u00e3o necess\u00e1ria em state. </p>"},{"location":"side-effects/launchedeffect/#chaves","title":"Chaves","text":"<p>O argumento Unit que passamos no c\u00f3digo que vimos antes \u00e9 uma chave (key). LaunchedEffect aceita um n\u00famero vari\u00e1vel de chaves. Quando o valor de uma das chaves muda, a coroutine existente ser\u00e1 cancelada e o trecho de LaunchedEffect ser\u00e1 iniciado em uma nova coroutine. Basicamente \u00e9 um mecanismo parecido com o remember() e tamb\u00e9m vemos isso em outros side effects. Passamos Unit como chave porque queremos executar o trecho de c\u00f3digo apenas na primeira composi\u00e7\u00e3o, j\u00e1 que Unit serve como uma constante.</p> <p>Veja um pequeno c\u00f3digo de timer abaixo que exemplifica o LaunchedEffect reagindo com as mudan\u00e7as de valores de uma chave. Poder\u00edamos fazer o c\u00f3digo abaixo de in\u00fameras formas diferentes, mas novamente, serve como um exemplo.</p> <pre><code>@Composable\nprivate fun CountdownTimer() {\n    val initialTime = 5\n    var currentTime by remember { mutableIntStateOf(initialTime) }\n\n    LaunchedEffect(key1 = currentTime) {\n        if (currentTime &gt; 0) {\n            delay(1000L)\n            currentTime -= 1\n        }\n    }\n\n    Box(\n        contentAlignment = Alignment.Center,\n        modifier = Modifier\n            .size(250.dp)\n            .clickable { currentTime = initialTime }\n            .padding(50.dp)\n            .border(\n                width = 3.dp,\n                color = Color.Red,\n                shape = CircleShape\n            )\n    ) {\n        Text(\n            text = \"$currentTime\",\n            fontSize = 24.sp,\n            fontWeight = FontWeight.Bold\n        )\n    }\n}\n</code></pre> <p></p> <p>No exemplo acima, estamos usando a suspend function delay() e o LaunchedEffect ir\u00e1 atualizar currentTime enquanto ele for maior que 0. Uma vez que ele atualiza currentTime para 4 na primeira execu\u00e7\u00e3o ap\u00f3s 1 segundo do delay, o valor da chave muda e o LaunchedEffect reinicia.</p>"},{"location":"side-effects/launchedeffect/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Side-effects in Compose (documenta\u00e7\u00e3o)</li> <li>Jetpack Compose Side-Effects I \u2014 LaunchedEffect (artigo)</li> </ul>"},{"location":"side-effects/others/","title":"Outros side effects","text":"<p>Al\u00e9m dos j\u00e1 citados anteriormente, que s\u00e3o os mais comumente utilizados, existem alguns outros side effects que podem ser usados em determinadas situa\u00e7\u00f5es. Para evitar alongar a se\u00e7\u00e3o sobre esse tema, vamos ver apenas um pequeno resumo retirado da documenta\u00e7\u00e3o sobre cada um dos demais.</p>"},{"location":"side-effects/others/#producestate","title":"produceState","text":"<p>produceState lan\u00e7a uma corrotina com escopo para composi\u00e7\u00e3o que pode enviar valores para um State. Use-o para converter o estado n\u00e3o-Compose em estado Compose, por exemplo, trazendo estado externo orientado por assinatura, como Flow, LiveData ou RxJava para a composi\u00e7\u00e3o. Leia mais na documenta\u00e7\u00e3o.</p>"},{"location":"side-effects/others/#derivedstateof","title":"derivedStateOf","text":"<p>derivedStateOf converte um ou v\u00e1rios objetos de estado em outro estado. No Compose, a recomposi\u00e7\u00e3o ocorre sempre que um objeto de estado observado ou uma entrada Composable muda. Um objeto de estado ou entrada pode mudar com mais frequ\u00eancia do que a UI realmente precisa atualizar, levando a uma recomposi\u00e7\u00e3o desnecess\u00e1ria.</p> <p>Voc\u00ea deve usar o derivedStateOf quando suas entradas para um Composable mudam com mais frequ\u00eancia do que o necess\u00e1rio para recompor. Isso geralmente ocorre quando algo muda com frequ\u00eancia, como uma posi\u00e7\u00e3o de rolagem, mas o Composable s\u00f3 precisa reagir a isso quando ultrapassa um determinado limite. derivedStateOf cria um novo objeto de estado Compose e voc\u00ea pode observar que ele atualiza apenas o necess\u00e1rio. Dessa forma, ele atua de forma semelhante ao distinctUntilChanged() do Kotlin Flows.</p> <p>Leia mais na documenta\u00e7\u00e3o e veja tamb\u00e9m esse artigo sobre quando usar derivedStateOf.</p>"},{"location":"side-effects/others/#snapshotflow","title":"snapshotFlow","text":"<p>snapshotFlow converte o estado do Compose (State) em um cold Flow. snapshotFlow executa seu bloco quando coletado e emite o resultado dos objetos State lidos nele. Quando um dos objetos State lidos dentro do bloco snapshotFlow sofrer muta\u00e7\u00e3o, o Flow emitir\u00e1 o novo valor para seu coletor se o novo valor n\u00e3o for igual ao valor emitido anteriormente (esse comportamento tamb\u00e9m \u00e9 semelhante ao de Flow.distinctUntilChanged()). Leia mais na documenta\u00e7\u00e3o."},{"location":"side-effects/others/#conclusao","title":"Conclus\u00e3o","text":"<p>Vimos nessa se\u00e7\u00e3o o que s\u00e3o e como trabalhar com side effects, al\u00e9m de ser not\u00f3rio que existem v\u00e1rios para diferentes situa\u00e7\u00f5es. Apesar disso, pode ser comum n\u00e3o os utilizar muito, at\u00e9 porque, como vimos logo no in\u00edcio da se\u00e7\u00e3o, o ideal \u00e9 que fun\u00e7\u00f5es Composable sejam livres de efeitos colaterais.</p> <p>Pode ser um pouco confuso entender tudo de in\u00edcio ou quando utilizar alguns deles, mas n\u00e3o se preocupe com isso. Com o tempo e com a pr\u00e1tica, entend\u00ea-los ser\u00e1 apenas um efeito colateral. :)</p> <p>Como sempre, n\u00e3o se esque\u00e7a de ler mais sobre eles na documenta\u00e7\u00e3o oficial.</p>"},{"location":"side-effects/others/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Side-effects in Compose (documenta\u00e7\u00e3o)</li> <li>Advanced State and Side Effects in Jetpack Compose (codelab)</li> </ul>"},{"location":"side-effects/remembercoroutinescope/","title":"rememberCoroutineScope","text":"<p>rememberCoroutineScope \u00e9 uma fun\u00e7\u00e3o Composable que retorna um CoroutineScope vinculada ao ponto da composi\u00e7\u00e3o onde \u00e9 chamada. O escopo ser\u00e1 cancelado quando a chamada sair da composi\u00e7\u00e3o.</p> <p>Diferente da LaunchedEffect que s\u00f3 pode ser usada dentro de uma outra fun\u00e7\u00e3o Composable por ser uma fun\u00e7\u00e3o Composable, rememberCoroutineScope \u00e9 \u00fatil para iniciar uma coroutine fora de uma Composable, mas com escopo para que seja cancelada automaticamente ao sair da composi\u00e7\u00e3o.</p> <p>Ele \u00e9 bem comum de ser utilizado, tanto que j\u00e1 o utilizamos uma vez quando aprendemos sobre o componente Navigation Drawer. Um outro exemplo que podemos ver sua utiliza\u00e7\u00e3o \u00e9 na implementa\u00e7\u00e3o de uma Pager. No c\u00f3digo abaixo, n\u00e3o podemos chamar <code>pagerState.animateScrollToPage(5)</code> no onClick do Button(), pois animateScrollToPage() \u00e9 uma suspend function. Para isso podemos recorrer ao rememberCoroutineScope.</p> <pre><code>@OptIn(ExperimentalFoundationApi::class)\n@Composable\nprivate fun MyHorizontalPager() {\n    val pagerState = rememberPagerState(pageCount = { 10 })\n    Column {\n        HorizontalPager(state = pagerState) { page -&gt;\n            Text(\n                text = \"P\u00e1gina atual: $page\",\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(100.dp)\n            )\n        }\n\n        val coroutineScope = rememberCoroutineScope()\n        Button(\n            onClick = {\n                // animateScrollToPage() \u00e9 uma suspend function\n                coroutineScope.launch {\n                    pagerState.animateScrollToPage(5)\n                }\n            },\n            modifier = Modifier.align(Alignment.CenterHorizontally)\n        ) {\n            Text(text = \"Pular para a p\u00e1gina 5\")\n        }\n    }\n}\n</code></pre>"},{"location":"side-effects/remembercoroutinescope/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Side-effects in Compose (documenta\u00e7\u00e3o)</li> <li>Jetpack Compose Side-Effects II \u2014 rememberCoroutineScope (artigo)</li> </ul>"},{"location":"side-effects/rememberupdatedstate/","title":"rememberUpdatedState","text":"<p>LaunchedEffect reinicia quando o valor de uma das keys muda. No entanto, em algumas situa\u00e7\u00f5es voc\u00ea pode querer capturar um valor em seu efeito que, se for alterado, voc\u00ea n\u00e3o deseja que o efeito seja reiniciado. Para isso, \u00e9 necess\u00e1rio utilizar rememberUpdatedState para criar uma refer\u00eancia a este valor que possa ser capturado e atualizado. Essa abordagem \u00e9 \u00fatil para efeitos que cont\u00eam opera\u00e7\u00f5es de longa dura\u00e7\u00e3o que podem ser caras ou proibitivas para recriar e reiniciar.</p> <p>Lendo o enunciado acima, pode parecer muito confuso e a documenta\u00e7\u00e3o oficial tamb\u00e9m n\u00e3o ajuda muito nesse caso. Ent\u00e3o vamos criar um exemplo simplificado de download de arquivo. Novamente, o c\u00f3digo demonstrado abaixo n\u00e3o \u00e9 uma abordagem recomendada, mas serve de exemplo para esse t\u00f3pico.</p> <p>Primeiro, vamos criar uma suspend function downloadFile():</p> <pre><code>private suspend fun downloadFile(onDownloadFinished: () -&gt; Unit) {\n    withContext(Dispatchers.IO) {\n        delay(3000)\n        withContext(Dispatchers.Main) {\n            onDownloadFinished.invoke()\n        }\n    }\n}\n</code></pre> <p>Ela n\u00e3o cont\u00e9m nada demais, possui apenas um delay de 3 segundos para simular um download de arquivo. Ap\u00f3s o delay, invoca onDownloadFinished(), que ser\u00e1 usado posteriormente para exibir um Toast.</p> <p>Agora vamos criar a nossa fun\u00e7\u00e3o que utiliza um LaunchedEffect:</p> <pre><code>@Composable\nprivate fun FileDownload(\n    url: String,\n    onFileNameObtained: (String) -&gt; Unit,\n    fileName: String,\n    onDownloadFinished: () -&gt; Unit\n) {\n    val context = LocalContext.current\n    LaunchedEffect(Unit) {\n        onFileNameObtained.invoke(URLUtil.guessFileName(url, null, null))\n        downloadFile(\n            onDownloadFinished = {\n                Toast.makeText(\n                    context,\n                    \"Arquivo \\\"$fileName\\\" baixado com sucesso!\",\n                    Toast.LENGTH_SHORT\n                ).show()\n                onDownloadFinished.invoke()\n            }\n        )\n    }\n}\n</code></pre> <p>J\u00e1 vimos LaunchedEffect antes, ent\u00e3o sabemos o que vai acontecer. N\u00e3o queremos que ele seja reiniciado quando o valor de alguma key muda, por isso passamos Unit como key, informando que o nosso c\u00f3digo no LaunchedEffect s\u00f3 ser\u00e1 executado uma vez na composi\u00e7\u00e3o. Assim que entramos no LaunchedEffect, usamos <code>URLUtil.guessFileName()</code>, que \u00e9 uma fun\u00e7\u00e3o que obt\u00e9m o nome de arquivo a partir de uma URL, e ent\u00e3o informamos ao chamador da FileDownload() que o nome de arquivo real foi obtido e ele faz o que desejar com isso. No nosso caso, isso servir\u00e1 para atualizar fileName posteriormente, pois inicialmente ele possui um nome desconhecido.</p> <p>Quando o download \u00e9 conclu\u00eddo, uma mensagem Toast \u00e9 exibida na tela.</p> <p>Agora vamos criar a DownloadScreen() que faz uso da FileDownload():</p> <pre><code>@Composable\nprivate fun DownloadScreen() {\n    val fileUrl = \"https://site.com/files/video-123.mp4\"\n    val defaultFileName = \"???\"\n    var fileName by remember { mutableStateOf(defaultFileName) }\n    var isDownloadingFile by remember { mutableStateOf(false) }\n\n    if (isDownloadingFile) {\n        FileDownload(\n            url = fileUrl,\n            fileName = fileName,\n            onFileNameObtained = { realFileName -&gt;\n                fileName = realFileName\n            },\n            onDownloadFinished = {\n                isDownloadingFile = false\n            }\n        )\n    }\n\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center,\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(16.dp)\n    ) {\n        if (isDownloadingFile) {\n            Column(horizontalAlignment = Alignment.CenterHorizontally) {\n                LinearProgressIndicator(\n                    strokeCap = StrokeCap.Round,\n                    modifier = Modifier.fillMaxWidth()\n                )\n                Spacer(Modifier.height(14.dp))\n                Text(\n                    text = \"Baixando arquivo... Aguarde.\",\n                    fontSize = 22.sp,\n                    textAlign = TextAlign.Center\n                )\n            }\n        } else {\n            Text(\n                text = \"Nenhum arquivo sendo baixado no momento.\",\n                fontSize = 22.sp,\n                textAlign = TextAlign.Center\n            )\n        }\n\n        Spacer(Modifier.height(18.dp))\n\n        Button(\n            onClick = {\n                fileName = defaultFileName\n                isDownloadingFile = true\n            },\n            enabled = !isDownloadingFile\n        ) {\n            Text(\n                text = \"Baixar\",\n                fontSize = 18.sp\n            )\n        }\n    }\n}\n</code></pre> <p>\u00c9 uma tela simples que simula um download de arquivo. Quando tocamos no bot\u00e3o de baixar, definimos isDownloadingFile como true, fazendo ent\u00e3o nossa FileDownload() entrar na composi\u00e7\u00e3o e iniciar o download. Como j\u00e1 vimos na FileDownload(), antes mesmo do download iniciar, fileName \u00e9 atualizado de \"???\" para o nome real obtido a partir da URL, que no caso \u00e9 \"video-123.mp4\".</p> <p>O resultado que esperamos \u00e9 que um Toast com a mensagem \"Arquivo \"video-123.mp4\" baixado com sucesso!\" seja exibido na tela ap\u00f3s 3 segundos, quando o download finalizar. Veja o resultado real:</p> <p></p> <p>Claramente n\u00e3o funcionou. Mas o que aconteceu? Vamos reler o que foi afirmado antes sobre o LaunchedEffect na nossa FileDownload(): N\u00e3o queremos que ele seja reiniciado quando o valor de alguma key muda, por isso passamos Unit como key, informando que o nosso c\u00f3digo no LaunchedEffect s\u00f3 ser\u00e1 executado uma vez na composi\u00e7\u00e3o.</p> <p>fileName at\u00e9 \u00e9 atualizado com sucesso ao obter o nome real do arquivo e isso acontece bem antes do download finalizar (o delay de 3 segundos), por\u00e9m, o c\u00f3digo no LaunchedEffect n\u00e3o saber\u00e1 disso, pois ele n\u00e3o ser\u00e1 reiniciado. Significa que quando usamos o trecho a seguir no onDownloadFinished:</p> <pre><code>Toast.makeText(\n    context,\n    \"Arquivo \\\"$fileName\\\" baixado com sucesso!\",\n    Toast.LENGTH_SHORT\n).show()\n</code></pre> <p>A refer\u00eancia que temos de fileName ainda \u00e9 a primeira antes de entrarmos no LaunchedEffect, ou seja, na primeira composi\u00e7\u00e3o. Ap\u00f3s entrarmos, mesmo que onFileNameObtained() seja invocado logo no in\u00edcio e atualize com sucesso o fileName, o que ainda temos \u00e9 ??? como o valor de fileName.</p> <p>Nesse tipo de situa\u00e7\u00e3o, podemos utilizar rememberUpdatedState. Vamos fazer apenas uma pequena altera\u00e7\u00e3o na FileDownload():</p> <pre><code>@Composable\nprivate fun FileDownload(\n    url: String,\n    onFileNameObtained: (String) -&gt; Unit,\n    fileName: String,\n    onDownloadFinished: () -&gt; Unit\n) {\n    val context = LocalContext.current\n    val realFileName by rememberUpdatedState(newValue = fileName)\n    LaunchedEffect(Unit) {\n        onFileNameObtained.invoke(URLUtil.guessFileName(url, null, null))\n        downloadFile(\n            onDownloadFinished = {\n                Toast.makeText(\n                    context,\n                    \"Arquivo \\\"$realFileName\\\" baixado com sucesso!\",\n                    Toast.LENGTH_SHORT\n                ).show()\n                onDownloadFinished.invoke()\n            }\n        )\n    }\n}\n</code></pre> <p></p> <p>Agora temos o trecho m\u00e1gico <code>val realFileName by rememberUpdatedState(newValue = fileName)</code> que usa fileName para se manter atualizada. Dessa forma, ao usarmos ela no Toast, obteremos o resultado desejado, pois realFileName agora ter\u00e1 o valor atualizado de fileName, mesmo sem precisarmos reiniciar o LaunchedEffect e consequentemente o \"download\".</p> <p>\u00c9 claro que todo esse exemplo foi criado apenas com o intuito de ilustrar a funcionalidade do rememberUpdatedState. Para fins pr\u00e1ticos, a fun\u00e7\u00e3o FileDownload() n\u00e3o precisaria existir e poder\u00edamos ter o seguinte c\u00f3digo na DownloadScreen():</p> <pre><code>@Composable\nprivate fun DownloadScreen() {\n    ...\n\n    if (isDownloadingFile) {\n        val context = LocalContext.current\n        LaunchedEffect(Unit) {\n            fileName = URLUtil.guessFileName(fileUrl, null, null)\n            downloadFile(\n                onDownloadFinished = {\n                    Toast.makeText(\n                        context,\n                        \"Arquivo \\\"$fileName\\\" baixado com sucesso!\",\n                        Toast.LENGTH_SHORT\n                    ).show()\n                    isDownloadingFile = false\n                }\n            )\n        }\n    }\n\n    ...\n}\n</code></pre> <p>O resultado seria o mesmo, pois agora estamos alterando o valor de fileName de fato antes de ser usado pelo Toast, dentro do mesmo escopo, o que n\u00e3o acontece no caso da FileDownload(), que delega essa fun\u00e7\u00e3o para seu chamador e o LaunchedEffect/Toast n\u00e3o tem mais ci\u00eancia sobre a atualiza\u00e7\u00e3o ap\u00f3s a primeira composi\u00e7\u00e3o.</p>"},{"location":"side-effects/rememberupdatedstate/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Side-effects in Compose (documenta\u00e7\u00e3o)</li> <li>Jetpack Compose Side-Effects III \u2014 rememberUpdatedState (artigo)</li> </ul>"},{"location":"side-effects/sideeffect/","title":"SideEffect","text":"<p>Para compartilhar o estado do Compose com objetos n\u00e3o gerenciados pelo Compose, use o SideEffect. Usar SideEffect garante que o efeito seja executado ap\u00f3s cada recomposi\u00e7\u00e3o bem-sucedida. Diferente do LaunchedEffect e DisposableEffect, SideEffect n\u00e3o possui a fun\u00e7\u00e3o de chaves (keys).</p> <p>Vamos ver um pequeno exemplo tamb\u00e9m retirado da documenta\u00e7\u00e3o:</p> <pre><code>@Composable\nfun rememberFirebaseAnalytics(user: User): FirebaseAnalytics {\n    val analytics: FirebaseAnalytics = remember {\n        FirebaseAnalytics()\n    }\n\n    // Em cada composi\u00e7\u00e3o bem-sucedida, atualiza o FirebaseAnalytics com\n    // o userType do usu\u00e1rio atual, garantindo que eventos de an\u00e1lise futuros\n    // tenham esses metadados anexados\n    SideEffect {\n        analytics.setUserProperty(\"userType\", user.userType)\n    }\n    return analytics\n}\n</code></pre>"},{"location":"side-effects/sideeffect/#conteudos-auxiliares","title":"Conte\u00fados auxiliares:","text":"<ul> <li>Side-effects in Compose (documenta\u00e7\u00e3o)</li> </ul>"}]}